# Python-S7 通信项目技术笔记

---

## 一、TIA Portal 配置要点

### 1. 非优化访问设置（必须）

**为什么必须关闭优化访问？**
```scl
DATA_BLOCK "DB200_Traj"
{ S7_Optimized_Access := 'FALSE' }  // ← 必须设为 FALSE
```

| 设置            | 内存布局                 | Snap7 兼容性            |
|-----------------|--------------------------|-------------------------|
| 优化访问 (TRUE)  | 编译器自动重排，提高效率 | ❌ 偏移量不确定，无法访问 |
| 非优化访问 (FALSE) | 严格按声明顺序排列       | ✅ 固定偏移量，可精确读写 |

**验证方法**：
- 在 TIA Portal 中打开 DB200_Traj
- 查看"偏移量"列，应显示：`0.0, 4.0, 8.0, 12.0, 14.0...`
- 如果偏移量不连续或缺失，说明优化访问未关闭

**手动设置步骤**：
1. 右键 DB200_Traj → 属性
2. 找到"优化块访问" → **取消勾选**
3. 保存并重新编译

---scl编码一定要用UTF-8 with BOM

### 2. 调试验证清单

**在 TIA Portal 中确认两件事**：
1. 程序块中确实有 `DB200_Traj` (DB 编号为 200)
2. DB 属性中"优化块访问"已**取消勾选**

**只要以上两条正确，Python 的 `db_read(200, 0, 16)` 就能正常工作。**

---

### 3. MC 块调试方法

**查看 MC_MoveAbsolute 实例 DB 的信号**：

在线打开 `MC_MoveAbs_DB_X` 或 `MC_MoveAbs_DB_Y`，监控：
- **Execute**：运动时应为 TRUE（说明 FB 输出已连接）
- **Done**：运动结束时应变为 TRUE
- **Busy**：运动期间应为 TRUE
- **Error**：错误时应为 TRUE

**引脚连线调试**：
```
OB1 里的连线                          等价的 SCL 代码
────────────────────────────────      ──────────────────────────────────────
DB_PythonFollow.X轴目标位置           "MC_MoveAbs_DB_X".Position
  → MC_MoveAbs_X.Position             := "DB_PythonFollow".X轴目标位置;

MC_MoveAbs_X.Done                     "DB_PythonFollow".X轴定位完成
  → DB_PythonFollow.X轴定位完成        := "MC_MoveAbs_DB_X".Done;
```

---

## 二、SCL 编程规范

### 1. 变量命名规则：`#` 符号的使用

**易错点**：在 CASE 分支标签前多写了 `#`，TIA 不认。

```scl
// ✅ 正确写法
VAR CONSTANT
    c状态_空闲 : Int := 0;        // 常量定义（不加 #）
END_VAR

VAR
    主状态 : Int := 0;             // 局部变量（使用时加 #）
END_VAR

CASE #主状态 OF                     // 变量加 #
    c状态_空闲:                     // 常量不加 #
        // ...
END_CASE;
```

**规则总结**：
| 类型               | 定义时     | 使用时     | 示例                  |
|--------------------|-----------|-----------|----------------------|
| 局部变量 (VAR)      | 不加 `#`  | 加 `#`    | `#主状态`, `#X轴定位完成` |
| 常量 (CONSTANT)     | 不加 `#`  | 不加 `#`  | `c状态_空闲`, `c状态_执行运动` |
| DB 变量            | 不加 `#`  | 不加 `#`  | `"DB200_Traj".NewPoint` |

---

### 2. 状态变化检测技巧（边沿检测）

```scl
// 检测状态是否改变（上升沿/下降沿检测）
#b新状态 := (#主状态 <> #上次状态);  // 状态发生变化时为 TRUE
#上次状态 := #主状态;                // 保存当前状态供下次比较

IF #b新状态 THEN
    // 状态发生变化时执行的操作
    // 例如：记录日志、清除计数器等
END_IF;
```

**符号说明**：
| 符号         | 含义                                      |
|--------------|-------------------------------------------|
| `#b新状态`   | 布尔型变量（`b` 前缀表示 Bool 类型）       |
| `:=`         | 赋值运算符                                |
| `<>`         | 不等于（相当于其他语言的 `!=`）            |
| `#主状态`    | 当前状态值                                |
| `#上次状态`  | 上一个扫描周期记录的状态值                 |

---

## 三、数据类型与存储

### 1. bit / byte / word 概念

**类比理解**：
- **bit（位）**：一个灯泡，0/1，开/关，对应 PLC 的 `BOOL`
- **byte（字节）**：一排 8 个灯泡，一次性看 8 个状态，常写成 `DBB14`
- **word（字）**：2 字节 = 16 个灯泡，主要用来存"数值"，常写成 `DBW20`

### 2. DB200 字节布局示例

```
DB200_Traj 内存布局：
Offset  Size  Type   Variable       说明
------  ----  -----  -------------  ---------------------------
0       4     Real   X_Setpoint     X 轴目标位置
4       4     Real   Y_Setpoint     Y 轴目标位置
8       4     Real   Velocity       运动速度
12      2     Int    PointIndex     当前点索引
14.0    1bit  Bool   NewPoint       ← DBB14 的 bit 0
14.1    1bit  Bool   Busy           ← DBB14 的 bit 1
14.2    1bit  Bool   Done           ← DBB14 的 bit 2
14.3    1bit  Bool   Error          ← DBB14 的 bit 3
14.4    1bit  Bool   Enable         ← DBB14 的 bit 4
```

---

## 四、Python Snap7 操作

### 1. `get_bool()` / `set_bool()` 参数说明

```python
# 读取第 14 字节的各个位
status_byte = plc.db_read(200, 14, 1)  # 读 1 个字节

busy = get_bool(status_byte, 0, 1)   # bit 1
done = get_bool(status_byte, 0, 2)   # bit 2
error = get_bool(status_byte, 0, 3)  # bit 3
```

**参数含义**：
```python
get_bool(status_byte, byte_index, bit_index)
         │            │            └─ 该字节里的第几位 (0-7)
         │            └─ 字节数组的索引（0 表示第一个字节）
         └─ 从 PLC 读回的字节数组
```

**对应关系**：
| Python 代码                | PLC 地址      | 说明              |
|----------------------------|---------------|-------------------|
| `get_bool(data, 0, 1)`     | `DBB14.1`     | 第 14 字节的 bit 1 |
| `get_bool(data, 0, 2)`     | `DBB14.2`     | 第 14 字节的 bit 2 |
| `get_bool(data, 0, 3)`     | `DBB14.3`     | 第 14 字节的 bit 3 |

### 2. 完整读写示例

```python
# 写入操作（读-改-写模式）
data = plc.db_read(200, 0, 16)        # 读取 16 字节
set_real(data, 0, 100.5)              # 偏移 0：写入 X 目标
set_real(data, 4, 50.2)               # 偏移 4：写入 Y 目标
set_bool(data, 14, 0, True)           # 偏移 14.0：NewPoint=TRUE
plc.db_write(200, 0, data)            # 一次性写回

# 读取操作
data = plc.db_read(200, 14, 1)        # 读取第 14 字节
done = get_bool(data, 0, 2)           # 提取 bit 2（Done）
```

---

## 五、FB/MC 块原理

### 1. 引脚与实例 DB 的关系

**核心概念**：
- **输入引脚 (IN)**：从实例 DB 的对应字段读取值
- **输出引脚 (OUT)**：把计算结果写入实例 DB 的对应字段
- **连线**：在 OB1 调用块之前/之后，把一个 DB 字段的值复制到另一个 DB 字段

**一句话总结**：
> 在 TIA 里，引脚连线 = DB 字段之间的赋值；FB/MC 的输入输出其实就是在读写自己实例 DB 的字段。

### 2. 实例 DB 的读写机制

```
调用 FB 的过程：
1. OB1 把输入引脚的值写入 FB 实例 DB
2. FB 内部逻辑执行（读取实例 DB 的输入，计算，写入输出）
3. OB1 把 FB 实例 DB 的输出值读出，赋值给目标变量
```

**示例**：
```scl
// OB1 中调用 MC_MoveAbsolute
"MC_MoveAbs_DB_X"(
    Axis := "X轴",
    Execute := "DB_PythonFollow".X轴定位启动,
    Position := "DB_PythonFollow".X轴目标位置,
    Done => "DB_PythonFollow".X轴定位完成
);

// 等价的底层操作：
// 步骤 1：写入输入
"MC_MoveAbs_DB_X".Execute := "DB_PythonFollow".X轴定位启动;
"MC_MoveAbs_DB_X".Position := "DB_PythonFollow".X轴目标位置;

// 步骤 2：执行 MC 内部逻辑（自动）

// 步骤 3：读取输出
"DB_PythonFollow".X轴定位完成 := "MC_MoveAbs_DB_X".Done;
```

---

## 六、SCL 静态变量详解：`r目标X` 和 `r目标Y`

### 1. 声明与使用

```scl
VAR
    主状态 : Int := 0;
    r目标X : LReal;     // 静态变量，保持目标 X
    r目标Y : LReal;     // 静态变量，保持目标 Y
END_VAR

// 在"等待新点"状态
IF "DB200_Traj".NewPoint THEN
    // 第1步：从 DB200 读取并类型转换
    #r目标X := REAL_TO_LREAL("DB200_Traj".X_Setpoint);  // Real → LReal
    #r目标Y := REAL_TO_LREAL("DB200_Traj".Y_Setpoint);

    // 第2步：赋值给输出引脚
    #X轴目标位置 := #r目标X;
    #Y轴目标位置 := #r目标Y;

    #主状态 := #c状态_执行运动;
END_IF;
```

### 2. 三个核心作用

| 作用              | 详细说明                                                     | 类比理解                   |
|-------------------|--------------------------------------------------------------|----------------------------|
| **1. 类型转换**   | `Real`(32位) → `LReal`(64位)，满足 MC_MoveAbsolute 要求     | 把"整数"转换为"浮点数"     |
| **2. 数据隔离**   | 运动执行期间，Python 修改 DB200 不会影响当前目标             | "拍照"保存目标，执行中不变 |
| **3. 状态保持**   | 静态变量（VAR 段），值跨扫描周期保持，直到下一个新点到来才更新 | "记忆功能"，记住要去哪里   |

### 3. 时序保护机制

```
时刻  │ DB200.X_Setpoint │ r目标X │ 正在执行的运动目标
─────┼──────────────────┼────────┼──────────────────
T1   │ 100.0            │ -      │ -（空闲）
T2   │ 100.0            │ 100.0  │ 100.0 ✓（锁定）
T3   │ 200.0 ◀Python改  │ 100.0  │ 100.0 ✓（不受影响）
T4   │ 200.0            │ 100.0  │ 100.0 → Done
T5   │ 200.0            │ 200.0  │ 200.0 ✓（新点）
```

**如果不使用 `r目标X/Y`，会发生什么？**
```scl
// ❌ 错误方式（直接用 DB200）
#X轴目标位置 := REAL_TO_LREAL("DB200_Traj".X_Setpoint);

// 问题：运动执行期间，Python 每修改一次 DB200，目标就会变化！
```

---

## 七、通信协议

### OPC UA 简介

**OPC UA** (Open Platform Communications Unified Architecture) 是一种用于工业自动化的机器对机器 (M2M) 通信协议标准。

**本项目未使用 OPC UA**，而是直接使用 **S7 协议**（通过 Snap7 库），优势：
- ✅ 无需配置 OPC UA 服务器
- ✅ 更低的延迟（直接读写 DB）
- ✅ 简单的客户端代码（单文件实现）

---

## 八、常见错误排查

| 错误现象                  | 可能原因                          | 解决方案                       |
|---------------------------|-----------------------------------|--------------------------------|
| Python 读取数据全为 0     | DB 号错误或不存在                 | 确认 DB200 存在且编号正确       |
| Snap7 报权限错误          | 未启用 PUT/GET 访问               | CPU 属性 → 启用 PUT/GET 通信   |
| PLC 不响应 NewPoint       | Enable 未置位                     | 检查 DB200.Enable 是否为 TRUE  |
| 数据错乱/偏移量不对       | DB 启用了优化访问                 | 关闭优化访问，重新编译          |
| CASE 语句报语法错误       | 常量前加了 `#`                    | 常量直接写名称，不加 `#`        |

---

**文档更新**：2024-12-05
**整理要点**：技术原理 + 调试技巧 + 常见错误
1. 新增 wait_idle() 方法（第 95-145 行）  在发送新点前等待 PLC 完全空闲，确保： • Enable = TRUE（Python 模式开启）  • Busy = FALSE（不在执行中）  • Done = TRUE（上一个点已完成）  • NewPoint = FALSE（上一个点已被消费）   这样可以避免在上一个点未完全处理完时发送新点，减少丢点。 2. 修改 write_point() 方法（第 147-187 行）  在写新点时主动清 Done 标志：                    避免 Python 在刚发完点后，因残留的 Done=1 而误判“已完成”。 3. 修改 run() 方法（第 244-287 行）  在发送新点前先调用 wait_idle()：                    改进效果  1. 防止丢点：确保上一个点完全处理完再发下一个点  2. 避免误判：主动清 Done，防止残留状态干扰
---

## 九、Python-PLC 通讯优化方案（2024-12-05 更新）

### 1. 新增 `wait_idle()` 方法

**位置**：代码第 95-145 行

**核心作用**：在发送新点前等待 PLC 完全空闲

**等待条件**（所有条件必须同时满足）：

| 信号         | 期望状态  | 含义                     |
|--------------|-----------|--------------------------|
| `Enable`     | `TRUE`    | Python 模式已开启        |
| `Busy`       | `FALSE`   | PLC 不在执行运动         |
| `Done`       | `TRUE`    | 上一个点已完成           |
| `NewPoint`   | `FALSE`   | 上一个点已被 PLC 消费    |

**防止问题**：
- ❌ **丢点**：上一个点未处理完就发送新点
- ❌ **状态混乱**：PLC 还在忙时覆盖目标位置

---

### 2. 修改 `write_point()` 方法

**位置**：代码第 147-187 行

**关键改进**：在写新点时主动清除 `Done` 标志

```python
# 写入新点数据
set_real(data, 0, x)              # X 目标位置
set_real(data, 4, y)              # Y 目标位置
set_bool(data, 14, 0, True)       # NewPoint = TRUE
set_bool(data, 14, 2, False)      # Done = FALSE ← 主动清除
plc.db_write(200, 0, data)
```

**为什么要清 Done？**

```
时序问题示例：
T1: Python 发送点 A → NewPoint=1, Done=0
T2: PLC 完成点 A → NewPoint=0, Done=1  ← Done 残留
T3: Python 发送点 B → NewPoint=1, Done=1 ← 残留的 Done=1
T4: Python 立即读到 Done=1 → 误判"点 B 已完成"
```

**解决方案**：每次发送新点时主动清 `Done`，确保新点的完成状态从 `FALSE` 开始。

---

### 3. 修改 `run()` 方法

**位置**：代码第 244-287 行

**核心改进**：在发送新点前先调用 `wait_idle()`

```python
def run(self, trajectory):
    """运行轨迹"""
    for i, (x, y) in enumerate(trajectory):
        print(f"发送点 {i+1}/{len(trajectory)}: ({x:.1f}, {y:.1f})")

        # ✅ 关键：先等待 PLC 空闲
        if not self.wait_idle(timeout=10.0):
            print("❌ PLC 未空闲，跳过此点")
            continue

        # ✅ 然后发送新点
        self.write_point(x, y)

        # ✅ 等待完成
        self.wait_for_done(timeout=10.0)
```

---

### 4. 改进效果总结

| 改进项                | 解决的问题                           | 效果                     |
|-----------------------|--------------------------------------|--------------------------|
| **wait_idle()**       | 上一个点未处理完就发送新点           | ✅ 防止丢点              |
| **清除 Done 标志**    | Done 残留导致误判"已完成"            | ✅ 避免状态混乱          |
| **run() 中先等待**    | 高速发送导致 PLC 来不及处理          | ✅ 确保每个点都被处理    |

**核心设计思想**：
> **"等待-清除-发送-等待"四步法**，确保 Python 和 PLC 之间的状态同步。

---

**文档最后更新**：2024-12-05
