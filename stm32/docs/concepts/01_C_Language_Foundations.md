# 📘 第1章：嵌入式 C 语言基石

> **摘要**：本章汇总了嵌入式开发（特别是 STM32）中必不可少的 C 语言核心概念。掌握这些是理解底层寄存器操作的前提。

---

## 1. 🔢 进制与数据表示

### 为什么用十六进制 (Hex)?
在嵌入式开发中，寄存器通常是 32 位的。
*   **二进制**: `1011 0010 1010 0101 1111 0000 1100 1110` (太长，难读)
*   **十六进制**: `0xB2A5F0CE` (简洁，一位 Hex 对应四位 Bin)

> **💡 小贴士**: 看到 `0x` 开头就要反应过来是十六进制。熟记 `0xA=10` ... `0xF=15`。

### 补码 (Two's Complement)
计算机内部用**补码**来存储负数。这保证了加法运算对正负数是一致的，简化了硬件设计。

---

## 2. ⚡ 位运算：寄存器的手术刀

寄存器操作的核心就是**位运算**。我们需要精准地修改 32 位中的某一位，而不影响其他位。

| 符号 | 名称 | 功能 | 典型场景 |
| :---: | :--- | :--- | :--- |
| **`&`** | **按位与** | 有0则0 | **清零**: `x & (~MASK)` (将特定位清0) |
| **`\|`** | **按位或** | 有1则1 | **置位**: `x \| MASK` (将特定位置1) |
| **`^`** | **按位异或** | 不同则1 | **翻转**: `x ^ MASK` (特定位取反) |
| **`~`** | **按位取反** | 0变1 | 生成反掩码 |
| **`<<`** | **左移** | 乘2 | 生成掩码: `1 << n` (第n位置1) |
| **`>>`** | **右移** | 除2 | 提取数据 |

### 什么是位掩码 (Bitmask)?
位掩码是一个预定义的常量，用来“遮盖”不需要的位，只暴露我们关心的位。
通常用左移操作生成：
```c
#define GPIO_PIN_5  (1 << 5)  // 0000 ... 0010 0000
```
**常用操作**:
*   **置位 (Set)**: `REG |= GPIO_PIN_5;`
*   **清零 (Clear)**: `REG &= ~GPIO_PIN_5;`
*   **翻转 (Toggle)**: `REG ^= GPIO_PIN_5;`

---

## 3. 📍 指针与内存地址

### 核心理解
*   **指针 = 地址**: 指针变量存储的不是数值，而是内存中的一个**地址编号**。
*   **寄存器 = 地址**: 硬件寄存器本质上就是一段**特定地址**的内存空间。

### 访问寄存器
要操作硬件，必须通过指针访问绝对地址：
```c
// 假设 0x4001080C 是 GPIOA_ODR 的地址
*(volatile uint32_t *)(0x4001080C) = 0xFFFF; // 向该地址写入数据
```

---

## 4. 📦 结构体 (Struct) 的妙用

### 为什么用结构体映射寄存器？
一个外设（如 GPIOA）通常有一组连续排列的寄存器。使用结构体可以将它们“打包”，利用内存布局的规律来对齐地址。

**对比**:
*   **原始方式**: `#define GPIOA_ODR  *(volatile uint32_t *)(0x4001080C)` (难记，易错)
*   **结构体方式**: `GPIOA->ODR = 0xFFFF;` (清晰，面向对象风格)

```c
typedef struct {
    volatile uint32_t CRL;
    volatile uint32_t CRH;
    volatile uint32_t IDR;
    volatile uint32_t ODR;
    // ... 自动对齐内存地址
} GPIO_TypeDef;
```

---

## 5. 🛡️ 关键关键字：`volatile` & `const`

### `volatile` (易变的)
*   **含义**: 告诉编译器，“这个变量的值可能会被我（代码）以外的力量（如硬件状态、中断）改变，**千万不要优化**，每次都要老老实实去内存里读！”
*   **后果**: 如果不加 `volatile`，编译器可能会为了加速，把寄存器的值缓存到 CPU 内部，导致读取不到硬件最新的状态。
*   **铁律**: **所有硬件寄存器定义必须加 `volatile`。**

### `const` (只读)
*   **含义**: 变量只读，不可修改。
*   **场景**: 用于修饰只读寄存器（如 `IDR` 输入数据寄存器），防止代码意外写入导致错误。

---

## 6. 📏 数据类型宽度

STM32 是 **32位** MCU，严谨的数据类型定义至关重要。

| 标准类型 (stdint.h) | 宽度 (位) | 用途 |
| :--- | :---: | :--- |
| `uint8_t` | 8 | 字节数据，小数组 |
| `uint16_t` | 16 | 半字数据，某些外设配置 |
| `uint32_t` | 32 | **寄存器标准宽度**，地址指针 |

> **建议**: 放弃使用 `int`, `long` 等模糊类型，统统使用 `uintX_t` 系列，确保代码的可移植性和确定性。