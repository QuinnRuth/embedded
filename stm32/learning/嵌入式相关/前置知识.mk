而 4 位二进制恰好能用 1 位十六进制表示（例如 0b1011 就是 0xB），所以用十六进制（如 0xB2A5F0CE）来表示会非常简短清晰。
交叉知识：这是计算机科学的基础。你看手册或者在调试器里看到 0x 开头的数字，就是十六进制。
补码 (Two's Complement)
是什么：计算机中用来表示负数的一种二进制编码方式。
位运算 (Bitwise Operations) 与位掩码 (Bitmask)
是什么：这是直接对二进制位进行操作的运算符，是寄存器操作的核心！
& (按位与): 两个位都是 1，结果才是 1。用于清零特定位（x & 0）或提取特定位（x & 1）。
| (按位或): 只要有一个位是 1，结果就是 1。用于置位特定位（x | 1）。
^ (按位异或): 两个位不同，结果是 1。用于翻转特定位（x ^ 1）。
~ (按位取反): 0 变 1，1 变 0。
<< (左移): 1 << n 表示将 1 向左移动 n 位，常用于创建位掩码。例如，要操作第 5 位，我们就用 1 << 5 生成一个只有第 5 位是 1 的数 0b00100000。
>> (右移): 将位向右移动。
位掩码 (Bitmask)：就是一个预先定义好的、用来修改或查询特定位的常量，通常由位运算 << 生成。
为什么需要：一个 32 位的寄存器可能控制着十几个不同的功能开关（每个开关对应一或几位）。我们往往只想修改其中一个开关，而不想影响其他开关。位运算和位掩码就是实现这种“精确打击”的唯一手段。
指针 (Pointers)
是什么：指针变量存储的不是一个普通的值，而是一个内存地址。
为什么需要：寄存器的本质就是位于特定内存地址上的特殊存储单元。我们要操作寄存器，就必须先通过指针指向那个特定的内存地址，然后通过解引用的方式（*操作符）对这个地址上的内容进行读写。这是 C 语言访问任意内存地址的唯一方式。
结构体 (Structs)
是什么：将不同类型的变量打包成一个整体。
为什么需要：一个外设（比如 GPIOA）有多个功能不同的寄存器（如配置寄存器、数据寄存器、状态寄存器等），它们的内存地址是连续或有规律地排列的。我们可以用结构体将这个外设的所有寄存器“打包”起来，每个成员对应一个寄存器。这样我们就可以通过 GPIOA->ODR = 0xFFFF; 这种可读性极高的方式来访问，而不用去记 0x40020014 这种晦涩的地址。
volatile 与 const
volatile (易变的)：它告诉编译器，这个变量的值随时可能被程序之外的因素改变（比如硬件自己更新了状态），所以每次使用它时，都必须老老实实地从内存地址重新读取，而不能使用编译器为了优化速度而存放在 CPU 寄存器里的缓存值。所有硬件寄存器都必须用 volatile 修饰，否则可能导致程序行为异常。
const (常量)：表示这个变量是只读的。有些寄存器是“只读状态寄存器”（Read-only），比如用来查询外部引脚电平的 IDR 寄存器，程序只能读不能写，用 const 修饰可以防止我们意外地修改它。
整型宽度 (Integer Width)
是什么：uint32_t 是一种精确宽度的整数类型，表示“无符号的、32位的整数”（Unsigned Integer 32-bit）。
为什么需要：STM32 是 32 位微控制器，其寄存器绝大部分都是 32 位宽。使用 uint32_t 可以确保我们定义的变量正好是 32 位，与寄存器的宽度完美匹配，避免因编译器差异导致宽度不匹配的问题。
