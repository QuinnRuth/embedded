# 7.2_AD多通道_打卡gemini

## 1. 章节目标回顾
本次学习的目标是实现 STM32 的多通道 ADC 采集。通过配置 GPIOA 的多个引脚（PA0-PA3），在不使用 DMA 的情况下，通过软件切换通道的方式，实现对四个模拟信号源的准实时监控，并将结果显示在 OLED 屏幕上。

## 2. 核心知识点精华
### 2.1 ADC 多通道采集方案
在不引入 DMA 的初级阶段，多通道采集主要有以下难点与对策：
- **难点**：STM32 的 ADC 规则组虽然可以配置 16 个通道，但只有一个数据寄存器（DR），如果开启自动扫描，后续通道的数据会覆盖前面的数据。
- **对策（本次采用）**：使用 **单次转换、非扫描模式**。通过在采集函数中动态调用 `ADC_RegularChannelConfig` 来切换当前转换的通道，从而规避数据覆盖问题。

### 2.2 关键参数配置
- **ADC 时钟**：由 PCLK2 经分频产生，最大不超过 14MHz。本实验采用 `RCC_PCLK2_Div6` (72MHz / 6 = 12MHz)。
- **GPIO 模式**：必须配置为 `GPIO_Mode_AIN` (模拟输入)，此模式下引脚会断开数字输入回路，减少干扰并降低功耗。
- **采样时间**：`ADC_SampleTime_55Cycles5` 较长的采样时间可以提高输入阻抗较大时的转换精度。

## 3. 核心代码注释速查表
### 3.1 多通道初始化 (AD.c)
```c
void AD_Init(void)
{
    RCC_APB2PeriphClockCmd(RCC_APB2Periph_ADC1, ENABLE);
    RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOA, ENABLE);
    
    RCC_ADCCLKConfig(RCC_PCLK2_Div6); // 12MHz ADC时钟
    
    GPIO_InitTypeDef GPIO_InitStructure;
    GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AIN;
    GPIO_InitStructure.GPIO_Pin = GPIO_Pin_0 | GPIO_Pin_1 | GPIO_Pin_2 | GPIO_Pin_3;
    GPIO_Init(GPIOA, &GPIO_InitStructure);
    
    ADC_InitTypeDef ADC_InitStructure;
    ADC_InitStructure.ADC_Mode = ADC_Mode_Independent; // 独立模式
    ADC_InitStructure.ADC_DataAlign = ADC_DataAlign_Right; // 右对齐
    ADC_InitStructure.ADC_ExternalTrigConv = ADC_ExternalTrigConv_None; // 软件触发
    ADC_InitStructure.ADC_ContinuousConvMode = DISABLE; // 单次转换
    ADC_InitStructure.ADC_ScanConvMode = DISABLE; // 非扫描模式
    ADC_InitStructure.ADC_NbrOfChannel = 1; // 规则组通道数设为1（配合手动切换）
    ADC_Init(ADC1, &ADC_InitStructure);
    
    ADC_Cmd(ADC1, ENABLE); // 使能ADC
    
    // 校准
    ADC_ResetCalibration(ADC1);
    while (ADC_GetResetCalibrationStatus(ADC1) == SET);
    ADC_StartCalibration(ADC1);
    while (ADC_GetCalibrationStatus(ADC1) == SET);
}
```

### 3.2 动态切换通道采集 (AD.c)
```c
uint16_t AD_GetValue(uint8_t ADC_Channel)
{
    // 动态配置规则组第1个序列为目标通道
    ADC_RegularChannelConfig(ADC1, ADC_Channel, 1, ADC_SampleTime_55Cycles5);
    ADC_SoftwareStartConvCmd(ADC1, ENABLE); // 软件触发转换
    while (ADC_GetFlagStatus(ADC1, ADC_FLAG_EOC) == RESET); // 等待转换完成
    return ADC_GetConversionValue(ADC1); // 返回结果
}
```

## 4. 核心洞察
- **本质思考**：ADC 的核心是“时间换空间”。在单 ADC 硬件资源下，通过软件分时复用（时分多路复用）实现了多信号监测。虽然采样不是严格同步的，但对于大多数低频传感器（如电位器、光敏电阻）来说，100ms 级别的采样周期已足够。
- **架构权衡**：本次实验选取的“手动切换”方案虽然增加了 CPU 开销（需要等待 EOC 标志），但它极大地简化了配置逻辑，是理解 ADC 工作原理的最佳实践。后续升级到 DMA 模式将是“空间换效率”的进阶方向。
