# 5.1_EXTI外部中断_理论深度版_打卡gemini.md

## 1. 章节目标回顾
- **核心目标**: 深入理解STM32中断系统架构，掌握EXTI（外部中断控制）与NVIC（嵌套向量中断控制器）的硬件原理与软件配置流。
- **理论重点**: 掌握中断优先级（抢占与响应）、AFIO复用引脚映射原理、EXTI内部边沿检测逻辑。
- **实战目标**: 实现对射式红外传感器计数功能，验证中断的实时响应性。

## 2. 核心知识点精华

### 2.1 NVIC (Nested Vectored Interrupt Controller) 嵌套向量中断控制器
- **本质**: 内核外设，用于统一管理中断的分配和优先级。
- **优先级分组 (Priority Group)**:
    - STM32将优先级分为**抢占优先级 (Preemption Priority)** 和 **响应优先级 (Sub Priority)**。
    - **抢占优先级**: 高抢占优先级可以打断低抢占优先级的中断（中断嵌套）。
    - **响应优先级**: 抢占优先级相同时，高响应优先级的中断优先执行（排队机制）。
    - **分配规则**: 整个工程必须统一分组，常用 `Group 2`（2位抢占，2位响应，各4级）。

### 2.2 EXTI (External Interrupt/Event Controller) 外部中断控制
- **引脚选择 (AFIO)**: 
    - STM32F1的GPIO引脚众多，但EXTI线只有16根（Line 0-15）。
    - **AFIO数据选择器**: 同一Pin号的引脚（如PA0, PB0, PC0...）只能通过AFIO选择其中一个连接到EXTI Line 0。
- **内部架构**:
    - **边沿检测电路**: 比较当前引脚电平与上一时刻电平。
    - **软件触发/中断屏蔽**: 通过寄存器位控制是否触发中断或事件。
    - **挂起寄存器 (Pending Register)**: 记录中断是否发生，必须手动清除。

### 2.3 信号触发模式
- **上升沿 (Rising)**: 低电平变高电平瞬间触发（适合释放按键）。
- **下降沿 (Falling)**: 高电平变低电平瞬间触发（适合传感器触发、按下按键）。
- **双边沿 (Both)**: 只要有电平变化就触发。

## 3. 核心代码注释 速查表

| 函数/结构体 | 理论解释 | 备注 |
| :--- | :--- | :--- |
| `RCC_APB2PeriphClockCmd` | 必须开启GPIOB和AFIO时钟 | EXTI线选择属于AFIO功能 |
| `GPIO_EXTILineConfig` | 核心：通过AFIO选择特定的Port映射到EXTI线 | 底层操作AFIO_EXTICRx寄存器 |
| `EXTI_Init` | 配置EXTI线、模式（中断/事件）、触发方式 | 硬件层面的信号捕获配置 |
| `NVIC_PriorityGroupConfig` | 设定全局优先级分配方案 | 整个代码生命周期仅需调用一次 |
| `NVIC_Init` | 将特定的中断通道挂载到内核NVIC管理 | 控制CPU是否对硬件信号产生响应 |

## 4. 实战成果
- **功能描述**: 
    - 成功配置PB14为外部中断输入。
    - 传感器遮挡产生的下降沿信号准确触发 `EXTI15_10_IRQHandler`。
    - 全局变量 `CountSensor_Count` 实时反映触发次数。
    - OLED显示模块能够即时同步计数值，即使主循环存在其他耗时任务。

## 5. 测试验证记录

### 终端下载日志
```bash
$ cmake --build build && openocd -f boards/stm32f103c8t6/openocd.cfg -c "program build/firmware.elf verify reset exit"
...
Info : Flash write discontinued at 0x08003f40
** Programming Finished **
** Verify Started **
verified 16192 bytes in 0.158142s (100.0kbit/s)
** Verified OK **
** Resetting Target **
```

### 现象观察
1.  **静态检查**: 上电后OLED初始显示0。
2.  **动态捕捉**: 遮挡红外传感器，计数器精准+1，无误触发。
3.  **嵌套测试**: 故意将NVIC优先级设错，观察中断冲突情况（理论验证）。

## 6. 关键技术细节
1.  **中断函数名约定**: 函数名如 `EXTI15_10_IRQHandler` 必须严格遵循启动文件 `startup_stm32f10x_md.s` 中的弱定义（Weak）名称。
2.  **标志位处理逻辑**: 
    - `EXTI_GetITStatus`: 检查引脚是否触发。
    - `EXTI_ClearITPendingBit`: **必须清除**。原理是中断挂起寄存器位为1时，内核会持续请求中断。如果不清除，退出ISR后CPU会立即再次进入。
3.  **电平抖动抑制**: 在ISR中可以通过 `GPIO_ReadInputDataBit` 二次确认引脚电平，确保是真实的信号跳变而非杂波。

## 7. 实际应用场景
1.  **电机编码器 (Encoder)**: 实时捕获两路相位差90度的外部中断信号，计算电机位置与速度。
2.  **低功耗唤醒 (Wakeup)**: 在停止模式（Stop Mode）下，CPU时钟停止，只有EXTI等少数外设能通过外部信号唤醒内核，极大延长电池寿命。

## 8. 完成成就
- 🏆 **解锁技能**: [中断系统底层架构分析]
- 🏆 **解锁技能**: [AFIO引脚映射矩阵配置]
- 🏆 **解锁技能**: [中断优先级抢占机制实证]

## 9. 核心洞察
**“响应优于处理”**:
中断设计的初衷是为了保证系统的**实时性**。在嵌入式开发中，我们不需要CPU死等一个事件，而是将“感知”交给硬件（EXTI），将“决策”交给CPU。
这种**前后台（Foreground/Background）**架构，是单片机处理多任务复杂性的核心思想。中断处理函数（ISR）应当**短小精悍**，只做状态标记或简单计数，繁重的显示或计算应交给主循环执行。

## 10. 完整代码示例 (Hardware/CountSensor.c)

```c
#include "stm32f10x.h"

uint16_t CountSensor_Count;

void CountSensor_Init(void)
{
	/* 1. 时钟配置：开启GPIOB和AFIO */
	RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOB, ENABLE);
	RCC_APB2PeriphClockCmd(RCC_APB2Periph_AFIO, ENABLE);
	
	/* 2. GPIO配置：PB14配置为上拉输入 */
	GPIO_InitTypeDef GPIO_InitStructure;
	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IPU;
	GPIO_InitStructure.GPIO_Pin = GPIO_Pin_14;
	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
	GPIO_Init(GPIOB, &GPIO_InitStructure);
	
	/* 3. AFIO配置：选择PB14映射到EXTI Line 14 */
	GPIO_EXTILineConfig(GPIO_PortSourceGPIOB, GPIO_PinSource14);
	
	/* 4. EXTI配置：中断模式，下降沿触发 */
	EXTI_InitTypeDef EXTI_InitStructure;
	EXTI_InitStructure.EXTI_Line = EXTI_Line14;
	EXTI_InitStructure.EXTI_LineCmd = ENABLE;
	EXTI_InitStructure.EXTI_Mode = EXTI_Mode_Interrupt;
	EXTI_InitStructure.EXTI_Trigger = EXTI_Trigger_Falling;
	EXTI_Init(&EXTI_InitStructure);
	
	/* 5. NVIC配置：分组2，抢占优先级1，响应优先级1 */
	NVIC_PriorityGroupConfig(NVIC_PriorityGroup_2);
	NVIC_InitTypeDef NVIC_InitStructure;
	NVIC_InitStructure.NVIC_IRQChannel = EXTI15_10_IRQn;
	NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE;
	NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = 1;
	NVIC_InitStructure.NVIC_IRQChannelSubPriority = 1;
	NVIC_Init(&NVIC_InitStructure);
}

uint16_t CountSensor_Get(void)
{
	return CountSensor_Count;
}

// 中断服务程序
void EXTI15_10_IRQHandler(void)
{
	if (EXTI_GetITStatus(EXTI_Line14) == SET)
	{
		// 软件辅助消抖：读取引脚确认为低电平
		if (GPIO_ReadInputDataBit(GPIOB, GPIO_Pin_14) == 0)
		{
			CountSensor_Count++;
		}
		// 必须清除标志位
		EXTI_ClearITPendingBit(EXTI_Line14);
	}
}
```

## 11. 知识掌握度自评

| 评估维度 | 掌握情况 | 理论细节 |
| :--- | :---: | :--- |
| **中断嵌套原理** | ⭐⭐⭐⭐⭐ | 深刻理解抢占优先级的硬件打断机制 |
| **AFIO映射机制** | ⭐⭐⭐⭐ | 明白Pin 0-15如何分时复用EXTI线 |
| **NVIC优先级分组** | ⭐⭐⭐⭐⭐ | 掌握AIRCR寄存器在不同分组下的位分配 |
| **EXTI挂起寄存器** | ⭐⭐⭐⭐⭐ | 明确Pending位不清除导致死循环的风险 |
| **边沿检测电路** | ⭐⭐⭐⭐ | 理解高低电平跳变捕获的物理基础 |

---
**备注**: 本笔记结合江协科技STM32 5.1章节内容，侧重于STM32中断外设的底层逻辑与硬件联动分析。