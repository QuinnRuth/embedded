# 2.1-3.4_GPIO与基础外设_打卡gemini.md

## 章节目标回顾
*   掌握 STM32 GPIO 的工作模式（推挽、浮空、上拉等）与配置流程。
*   实现 LED 闪烁、流水灯、蜂鸣器控制。
*   掌握按键扫描逻辑（消抖、状态切换）。
*   初步使用 OLED 屏幕进行调试信息显示。

## 核心知识点精华
*   **GPIO 结构**：每个引脚都包含输入数据寄存器 (IDR) 和输出数据寄存器 (ODR)。
*   **常用模式**：
    *   `Out_PP` (推挽输出)：输出强 0/1，驱动 LED 的首选。
    *   `IPU` (上拉输入)：按键输入的常用模式，默认高电平，按下去接 GND。
*   **按键消抖**：由于机械弹性，按键闭合瞬间会有抖动（约 20ms），代码中通过 `Delay_ms(20)` 过滤波形干扰。
*   **OLED 调试**：它是嵌入式开发中的“显示器”，能极大降低调试难度。通过 I2C 协议通信，常用函数如 `OLED_ShowString`、`OLED_ShowNum`。

## 核心代码注释速查表

### GPIO 初始化标准流程
```c
RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOA, ENABLE); // 1. 开时钟
GPIO_InitTypeDef GPIO_InitStructure;
GPIO_InitStructure.GPIO_Mode = GPIO_Mode_Out_PP;      // 2. 选模式
GPIO_InitStructure.GPIO_Pin = GPIO_Pin_0;             // 3. 选引脚
GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
GPIO_Init(GPIOA, &GPIO_InitStructure);                // 4. 写配置
```

### 按键扫描逻辑
```c
uint8_t Key_GetNum(void) {
    uint8_t KeyNum = 0;
    if (GPIO_ReadInputDataBit(GPIOB, GPIO_Pin_1) == 0) {
        Delay_ms(20); // 消抖
        while (GPIO_ReadInputDataBit(GPIOB, GPIO_Pin_1) == 0); // 等待松手
        Delay_ms(20);
        KeyNum = 1;
    }
    return KeyNum;
}
```

## 核心洞察
*   **软硬结合**：GPIO 是数字世界（程序）与物理世界（电压）的边界。理解推挽与开漏的区别，不仅是写代码，更是理解电路。
*   **模块化思想**：从这一刻起，我们开始将硬件抽象为 `Driver`（LED.c, Key.c），让 `main.c` 保持清爽的业务逻辑，这是工程化的第一步。
