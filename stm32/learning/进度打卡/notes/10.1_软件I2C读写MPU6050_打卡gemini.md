# 10.1_软件I2C读写MPU6050_打卡gemini.md

## 章节目标回顾
*   掌握 I2C 通信协议的底层原理（时钟同步、半双工、应答机制）。
*   手写代码模拟 I2C 时序（Start, Stop, Send, Receive, Ack），不依赖硬件外设。
*   驱动 MPU6050 传感器，读取 6 轴原始数据。

## 核心知识点精华
*   **物理层：开漏输出 (OD)**：I2C 引脚必须配置为开漏模式 + 外部上拉电阻。这保证了总线可以实现“线与”逻辑，支持多主机且不短路。
*   **协议层：时序六步走**：
    1.  **起始 (Start)**：SCL 高，SDA 下降沿。
    2.  **终止 (Stop)**：SCL 高，SDA 上升沿。
    3.  **发送字节**：SCL 低电平放数据，高电平从机读。
    4.  **接收字节**：SCL 低电平从机放数据，高电平主机读。
    5.  **发送应答**：接收完 8 位后，主机给从机一个 0 (ACK) 或 1 (NACK)。
    6.  **接收应答**：发送完 8 位后，主机读 SDA 状态。
*   **MPU6050 拼接逻辑**：加速度/角速度数据由 H (高8位) 和 L (低8位) 组成，需通过 `(H << 8) | L` 拼合，并利用补码特性自动转为有符号整数。

## 核心代码注释速查表

### 软件 I2C 字节读写逻辑
```c
void MyI2C_SendByte(uint8_t Byte) {
    for (uint8_t i = 0; i < 8; i++) {
        MyI2C_W_SDA(!!(Byte & (0x80 >> i))); // 放数据
        MyI2C_W_SCL(1); // 采样
        MyI2C_W_SCL(0); // 准备下一位
    }
}
```

### MPU6050 读取 ID (WHO_AM_I)
```c
MyI2C_Start();
MyI2C_SendByte(0xD0); // 写地址
MyI2C_ReceiveAck();
MyI2C_SendByte(0x75); // 寄存器地址
MyI2C_ReceiveAck();
MyI2C_Start();        // Restart
MyI2C_SendByte(0xD1); // 读地址
MyI2C_ReceiveAck();
Data = MyI2C_ReceiveByte();
MyI2C_SendAck(1);     // 非应答 NACK
MyI2C_Stop();
```

## 核心洞察
*   **底层控制感**：软件模拟 I2C 虽然效率比硬件低，但其逻辑完全透明且不依赖特定芯片外设，是理解同步串行通信的最佳实践。
*   **分层架构**：项目采用了 `main -> MPU6050 -> MyI2C -> GPIO` 的清晰分层，每一层只对上一层负责，极大地提高了代码的可维护性和可移植性。
