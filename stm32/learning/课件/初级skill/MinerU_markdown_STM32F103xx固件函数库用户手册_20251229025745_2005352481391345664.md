# 32位基于ARM微控制器STM32F101xx与STM32F103xx

固件函数库

# 介绍

本手册介绍了32位基于ARM微控制器STM32F101xx与STM32F103xx的固件函数库。

该函数库是一个固件函数包，它由程序、数据结构和宏组成，包括了微控制器所有外设的性能特征。该函数库还包括每一个外设的驱动描述和应用实例。通过使用本固件函数库，无需深入掌握细节，用户也可以轻松应用每一个外设。因此，使用本固态函数库可以大大减少用户的程序编写时间，进而降低开发成本。

每个外设驱动都由一组函数组成，这组函数覆盖了该外设所有功能。每个器件的开发都由一个通用API(application programming interface 应用编程界面)驱动，API对该驱动程序的结构，函数和参数名称都进行了标准化。

所有的驱动源代码都符合“Strict ANSI-C”标准（项目于范例文件符合扩充ANSI-C标准）。我们已经把驱动源代码文档化，他们同时兼容MISRA-C2004标准（根据需要，我们可以提供兼容矩阵)。由于整个固态函数库按照“Strict ANSI-C"标准编写，它不受不同开发环境的影响。仅对话启动文件取决于开发环境。

该固态函数库通过校验所有库函数的输入值来实现实时错误检测。该动态校验提高了软件的鲁棒性。实时检测适合于用户应用程序的开发和调试。但这会增加了成本，可以在最终应用程序代码中移去，以优化代码大小和执行速度。想要了解更多细节，请参阅 Section 2.5。

因为该固件库是通用的，并且包括了所有外设的功能，所以应用程序代码的大小和执行速度可能不是最优的。对大多数应用程序来说，用户可以直接使用之，对于那些在代码大小和执行速度方面有严格要求的应用程序，该固件库驱动程序可以作为如何设置外设的一份参考资料，根据实际需求对其进行调整。

此份固件库用户手册的整体架构如下：

定义，文档约定和固态函数库规则。  
固态函数库概述（包的内容，库的架构），安装指南，库使用实例。  
固件库具体描述：设置架构和每个外设的函数。

STM32F101xx和STM32F103xx在整个文档中被写作STM32F101x。

# 目录

1.1 缩写 27  
1.2 命名规则 27  
1.3编码规则 28

1.3.1 变量 ..... 28  
1.3.2布尔型 28  
1.3.3 标志位状态类型 29  
1.3.4 功能状态类型 29  
1.3.5 错误状态类型 29  
1.3.6 外设 ..... 29

2.1 压缩包描述 32

2.1.1 文件夹Examples 32  
2.1.2 文件夹Library 32  
2.1.3 文件夹Project 33

2.2固件函数库文件描述 33  
2.3外设的初始化和设置 34

2.4 位段（Bit-Banding） 35

2.4.1 映射公式 35  
2.4.2 应用实例 35

2.5运行时间检测 36  
4.1 ADC寄存器结构 39

4.2 ADC库函数 40

4.2.1 函数ADC_DeInit 42  
4.2.2 函数ADC_Init 42  
4.2.3 函数ADC_StructInit 44  
4.2.4函数ADC_Cmd 44  
4.2.5 函数ADC_DMAcd 45  
4.2.6 函数ADC_ITConfig 45  
4.2.7 函数ADC_SetCalibration 46  
4.2.8函数ADC_GetResetCalibrationStatus 46  
4.2.9 函数ADC_StartCalibration 46  
4.2.10 函数ADC_GetCalibrationStatus 47  
4.2.11 函数ADC_SoftwareStartConvCmd 47  
4.2.12 函数ADC_GetSoftwareStartConvStatus 48  
4.2.13 函数ADC_DiscModeChannelCountConfig 48  
4.2.14 函数ADC_DiscModeCmd 49  
4.2.15 函数ADC_RegularChannelConfig 49  
4.2.16 函数ADC_ExternalTrigConvConfig 51  
4.2.17 函数ADC_GetConversionValue 51  
4.2.18 函数ADC_GetDuelModeConversionValue 52  
4.2.19 函数ADC_AutoInjectedConvCmd 52  
4.2.20 函数ADC_InjectedDiscModeCmd 53  
4.2.21 函数ADC_ExternalTrigInjectedConvConfig 53  
4.2.22 函数ADC_ExternalTrigInjectedConvCmd 54  
4.2.23 函数ADC_SoftwareStartinjectedConvCmd 54  
4.2.24 函数ADC_GetsoftwareStartinjectedConvStatus 55  
4.2.25 函数ADC_InjectedChannleConfig 55  
4.2.26 函数ADC_InjectedSequencerLengthConfig 56  
4.2.27 函数ADC_SetinjectedOffset 56  
4.2.28 函数ADC_GetInjectedConversionValue 57  
4.2.29 函数ADC_AnalogWatchdogCmd 57

4.2.30 函数ADC_AnalogWatchdongThresholdsConfig 58  
4.2.31 函数ADC_AnalogWatchdongSingleChannelConfig 58  
4.2.32 函数ADC_TampSensorVrefintCmd 59  
4.2.33 函数ADC_GetFlagStatus 59  
4.2.34 函数ADC_ClearFlag 60  
4.2.35 函数ADC_GetITStatus 60  
4.2.36 函数ADC_ClearITPendingBit 61

5.1 BKP寄存器结构 62  
5.2 BKP库函数 63

5.2.1 函数BKP_DeInit 64  
5.2.2 函数BKP_TamperPinLevelConfig 64  
5.2.3 函数BKP_TamperPinCmd 65  
5.2.4 函数BKP_ITConfig 65  
5.2.5 函数BKP_RTCOutputConfig 66  
5.2.6 函数BKP_SetRTCCalibrationValue 66  
5.2.7 函数BKP_WritesBackupRegister 67  
5.2.8 函数BKPREADINGBackupRegister 67  
5.2.9 函数BKP_GetFlagStatus 68  
5.2.10 函数BKP_ClearFlag 68  
5.2.11 函数BKP_GetITStatus 69  
5.2.12 函数BKP_ClearITPendingBit 69

6.1 CAN寄存器结构 70  
6.2 CAN库函数 72

6.2.1 函数CAN_DeInit 72  
6.2.2 函数CAN_Init 73  
6.2.3 函数CAN_FilterInit 75  
6.2.4 函数CAN_StructInit 76  
6.2.5 函数CAN_ITConfig 77  
6.2.6 函数CAN_Transmit 78  
6.2.7函数CAN_TransmitStatus 79  
6.2.8 函数CAN_CancelTransmit 79  
6.2.9 函数CAN_FIFORElease 80  
6.2.10 函数CAN_MessagePending 80  
6.2.11 函数CAN_Receive 81  
6.2.12 函数CAN_Sleep 82  
6.2.13 函数CAN_WakeUp 82  
6.2.14 函数CAN_GetFlagStatus 83  
6.2.15 函数CAN_ClearFlag 83  
6.2.16 函数CAN_GetITStatus 84  
6.2.17 函数CAN_ClearITPendingBit 85

7.1 DMA寄存器结构 86  
7.2 DMA库函数 88

7.2.1 函数DMA_DeInit 89  
7.2.2函数DMA_Init 89  
7.2.3 函数DMASTRUCTInit 92  
7.2.4函数DMA_Cmd 92  
7.2.5 函数DMA_ITConfig 93  
7.2.6 函数DMA_GetCurrDataCounte 93  
7.2.7函数DMA_GetFlagStatus 94  
7.2.8 函数DMA_ClearFlag 95  
7.2.9 函数DMA_GetITStatus 95  
7.2.10 函数DMA_ClearITPendingBit 96

8.1EXTI寄存器结构 97

8.2EXTI库函数 98

8.2.1 函数EXTI_DeInit 98  
8.2.2 函数EXTI_Init 99  
8.2.3 函数EXTISTRUCTInit 100  
8.2.4 函数EXTI_GenerateSWInterrupt 101  
8.2.5 函数EXTI_GetFlagStatus 101  
8.2.6 函数EXTI_ClearFlag 102  
8.2.7函数EXTI_GetITStatus 102  
8.2.8 函数EXTI_ClearITPendingBit 103

9.1 FLASH寄存器结构 104  
9.2 FLASH库函数 105

9.2.1 函数FLASH_SetLatency 106  
9.2.2 函数FLASH_HalfCycleAccessCmd 107  
9.2.3 函数FLASH_PrefetchBufferCmd 107  
9.2.4 函数FLASH_Unclock 108  
9.2.5 函数FLASH_Lock 108  
9.2.6 函数FLASH_ErasePage 109

9.2.7 函数FLASH_EraseAllPages 109  
9.2.8函数FLASH_EraseOptionBytes 110  
9.2.9 函数FLASH_ProgramWord 110  
9.2.10 函数FLASH_ProgramHalfWord 111  
9.2.11 函数FLASH_ProgramOptionByteData 111  
9.2.12 函数FLASH_EnableWriteProtection 112  
9.2.13 函数FLASH_ReadOutProtection 113  
9.2.14 函数FLASH_UserOptionByteConfig 114  
9.2.15 函数FLASH_GetUserOptionByte 115  
9.2.16 函数FLASH_GetWriteProtectionOptionByte 115  
9.2.17 函数FLASH_GetReadOutProtectionStatus 116  
9.2.18 函数FLASH_GetPrefetchBufferStatus 116  
9.2.19 函数FLASH_ITConfig 117  
9.2.20 函数FLASH_GetFlagStatus 117  
9.2.21 函数FLASH_ClearFlag 118  
9.2.22 函数FLASH_GetStatus 119  
9.2.23 函数FLASH_WaitForLastOperation 119

10.1 GPIO寄存器结构 120  
10.2 GPIO库函数 122

10.2.1 函数GPIO_DeInit 123  
10.2.2 函数GPIO_AFIODeInit 123  
10.2.3 函数GPIO_Init 124  
10.2.4函数GPIOStructInit 126  
10.2.5 函数GPIO_ReadInputDataBit 126  
10.2.6 函数GPIO_InputData 127  
10.2.7 函数GPIO_ReadOutputDataBit 127  
10.2.8 函数GPIO_ReadOutputData 128  
10.2.9 函数GPIO_SetBits 128  
10.2.10 函数GPIO_SetBits 129  
10.2.11函数GPIO_WritesBit 129  
10.2.12 函数GPIO_Writes 130  
10.2.13 函数GPIO_PinLockConfig 130  
10.2.14 函数GPIO_EventOutputConfig 131  
10.2.15 函数GPIO_EventOutputCmd 131  
10.2.16函数GPIO_PinRemapConfig 132  
10.2.17 函数GPIO_EXTILineConfig 133

11.1 I2C寄存器结构 134  
11.2 I2C库函数 135

11.2.1 函数I2C_DeInit 136  
11.2.2 函数I2C_Init 137  
11.2.3 函数I2C_StructInit 138  
11.2.4 函数I2C_Cmd. 139  
11.2.5 函数I2C_DMAcmd 139  
11.2.6 函数I2C_DMALastTransferCmd 140  
11.2.7 函数I2C_GenerateSTART 140  
11.2.8 函数I2C_GenerateSTOP 141  
11.2.9 函数I2C_AcknowledgeConfig. 141  
11.2.10 函数I2C_OwnAddress2Config 142  
11.2.11 函数I2C_DualAddressCmd 142  
11.2.12 函数I2C_GeneralCallCmd. 143  
11.2.13 函数I2C_ITConfig 143  
11.2.14 函数I2C_SendData 144  
11.2.15 函数I2C_ReceiveData 144  
11.2.16 函数I2C_Send7bitAddress 145  
11.2.17 函数I2C_ReadRegister 145  
11.2.18 函数I2C_SoftwareResetCmd 146  
11.2.19 函数I2C_SMBusAlertConfig 147  
11.2.20 函数I2C_TransmitPEC 147  
11.2.21 函数I2C_PECPositionConfig 148  
11.2.22 函数I2C_CalculatePEC 148  
11.2.23 函数I2C_GetPEC 149  
11.2.24 函数I2C_ARPCmd 149  
11.2.25 函数I2C_SqueezeClockCmd 150  
11.2.26 函数I2C_FastModeDutyCycleConfig 150  
11.2.27 函数I2C_GetLastEvent 151  
11.2.29 函数I2C_GetFlagStatus 152  
11.2.30 函数I2C_ClearFlag ..... 153  
11.2.31 函数I2C_GetITStatus 154  
11.2.32 函数I2C_ClearITPendingBit 155

12.1 IWDG寄存器结构 156  
12.2 IWDG库函数 157

12.2.1 函数IWDG_WritesCmd 157  
12.2.2 函数IWDG_SetPrescaler 158  
12.2.3 函数IWDG_SetReload 158  
12.2.4 函数IWDG_ReloadCounter 159  
12.2.5 函数IWDG_Enable 159  
12.2.6 函数IWDG_GetFlagStatus 159

13.1 NVIC寄存器结构 161  
13.2 NVIC库函数 163

13.2.1 函数NVIC_DeInit 164  
13.2.2 函数NVIC_SCBDInit 164  
13.2.3 函数NVIC_PriorityGroupConfig 165  
13.2.4 函数NVIC_Init 166  
13.2.5 函数NVICSTRUCTInit 168  
13.2.6 函数NVIC_SETPRIMASK 169  
13.2.7 函数NVIC_RESETPRIMASK 169  
13.2.8 函数NVIC_SETFAULTMASK 170  
13.2.9 函数NVIC_RESETFAULTMASK 170  
13.2.10 函数NVIC_BASEPRCONFIG 171

13.2.11 函数NVIC GetBASEPRI 171  
13.2.12 函数NVIC_GetCurrentPendingIRQChannel 172  
13.2.13 函数NVIC_GetIRQChannelPendingBitStatus 172  
13.2.14 函数NVIC_SetIRQChannelPendingBit 173  
13.2.15 函数NVIC_ClearIRQChannelPendingBit 173  
13.2.16 函数NVIC_GetCurrentActiveHandler 174  
13.2.17 函数NVIC_GetIRQChannelActiveBitStatus 174  
13.2.18 函数NVIC_GetCPUID 175  
13.2.19 函数NVIC_SetVectorTable 175  
13.2.20 函数NVIC_GenerateSystemReset 176  
13.2.21 函数NVIC_GenerateCoreReset 176  
13.2.22 函数NVIC_SystemLPCfg 177  
13.2.23 函数NVIC_SystemHandlerConfig 177  
13.2.24 函数NVIC_SystemHandlerPriorityConfig 182  
13.2.25 函数NVIC_GetSystemHandlerPendingBitStatus 183  
13.2.26 函数NVIC_SetSystemHandlerPendingBit 183  
13.2.27 函数NVIC_ClearSystemHandlerPendingBit 184  
13.2.28 函数NVIC_GetSystemHandlerActiveBitStatus 184  
13.2.29 函数NVIC_GetFaultHandlerSources 185  
13.2.30 函数NVIC_GetFaultAddress 186

14.1 PWR寄存器结构 187  
14.2 PWR库函数 188

14.2.1 函数PWR_DeInit 188  
14.2.2 函数PWR_BackupAccessCmd 189  
14.2.3 函数PWRPVDCmd 189  
14.2.4 函数PWR_PVDLevelConfig 190  
14.2.5 函数PWR_WakeUpPinCmd 190  
14.2.6 函数PWR_EnterSTOPMode 191  
14.2.7 函数PWR_EnterSTANDBYMode 191  
14.2.8 函数PWR_GetFlagStatus 192  
14.2.9 函数PWR_ClearFlag ..... 192

15.1 RCC寄存器结构 193  
15.2 RCC库函数 194

15.2.1 函数RCC_DeInit 195  
15.2.2 函数RCC_HSEConfig 195  
15.2.3 函数RCC_WaitForHSEStartUp 196  
15.2.4 函数RCC_AdjustHSICalibrationValue 196  
15.2.5 函数RCC_HSICmd 197  
15.2.6 函数RCC_PLLConfig 197  
15.2.7 函数RCC_PLLCmd 198  
15.2.8 函数RCC_SYSCLKConfig 199  
15.2.9 函数RCC_GetSYSCLKSource 199  
15.2.10 函数RCC_HCLKConfig 200  
15.2.11 函数RCC_PCLK1Config 200  
15.2.12 函数RCC_PCLK2Config 201  
15.2.13 函数RCC_ITConfig 202  
15.2.14 函数RCC_USBCLKConfig 202  
15.2.15 函数RCC_ADCCLKConfig 203  
15.2.16 函数RCC_LSEConfig 204  
15.2.17 函数RCC_LSICmd 204  
15.2.18 函数RCC_RTCCLKConfig 205  
15.2.19 函数RCC_RTCCLKCmd 205  
15.2.20 函数RCC_GetClocksFreq 206

15.2.21 函数RCC_AHBPeriphClockCmd 207  
15.2.22 函数RCC/APB2PeriphClockCmd 207  
15.2.23 函数RCC/APB1PeriphClockCmd 208  
15.2.24 函数RCC/APB2PeriphResetCmd 209  
15.2.25 函数RCC_APB1PeriphResetCmd 209  
15.2.26 函数RCC_BackupResetCmd 210  
15.2.27 函数RCC_ClockSecuritySystemCmd 210  
15.2.28 函数RCC_MCOConfig 210  
15.2.29 函数RCC_GetFlagStatus 211  
15.2.30 函数RCC_ClearFlag 212  
15.2.31 函数RCC_GetITStatus 212  
15.2.32 函数RCC_ClearITPendingBit 213

16.1 RTC寄存器结构 214  
16.2 RTC库函数 215

16.2.1 函数RTC_ITConfig 216  
16.2.2 函数RTC_EnterConfigMode 216  
16.2.3 函数RTC ExitingConfigMode 217  
16.2.4 函数RTC_GetCounter 217  
16.2.5 函数RTC_SetCounter 218  
16.2.6 函数RTC_SetPrescaler 218  
16.2.7 函数RTC_SetAlarm 219  
16.2.8 函数RTC_GetDivider 219  
16.2.9 函数RTC_WaitForLastTask 220  
16.2.10 函数RTC_WaitForSynchro 220  
16.2.11 函数RTC_GetFlagStatus 221  
16.2.12 函数RTC_ClearFlag 221  
16.2.13 函数RTC_GetITStatus 222  
16.2.14 函数RTC_ClearITPendingBit 222

17.1 SPI寄存器结构 223  
17.2 SPI库函数 224

17.2.1 函数SPI_DeInit 225  
17.2.2 函数SPI_Init 225  
17.2.3 函数SPI_StructInit 227  
17.2.4 函数SPI_Cmd 228  
17.2.5 函数SPI_ITConfig 228  
17.2.6 函数SPI_DMAcmd 229  
17.2.7 函数SPI_SendData 229  
17.2.8 函数SPI_ReceiveData 230  
17.2.9 函数SPI_NSSInternalSoftwareConfig 230  
17.2.10 函数SPI_SSOutputCmd 231  
17.2.11 函数SPI_DataSizeConfig 231  
17.2.12 函数SPI_TransmitCRC 232  
17.2.13 函数SPI_CalculateCRC 232  
17.2.14 函数SPI_GetCRC 233  
17.2.15 函数SPI_GetCRCPolynomial 233  
17.2.16 函数SPI_BiDirectionalLineConfig 234  
17.2.17 函数SPI_GetFlagStatus 234  
17.2.18 函数SPI_ClearFlag 235  
17.2.19 函数SPI_GetITStatus 235  
17.2.20 函数SPI_ClearITPendingBit 236

18.1 SysTick寄存器结构 237  
18.2 SysTick库函数 238  
18.2.1 函数SysTick_CLKSourceConfig 238

18.2.2 函数SysTick_SetReload 239  
18.2.3 函数SysTick_CounterCmd 239  
18.2.4 函数SysTick_ITConfig 240  
18.2.5 函数SysTick_GetCounter 240  
18.2.6 函数SysTick_GetFlagStatus 241

19.1 TIM寄存器结构 242  
19.2 TIM库函数 244

19.2.1 函数TIM_DeInit 246  
19.2.2 函数TIM_TimeBaseInit 246  
19.2.3 函数TIM_OCInit 247  
19.2.4 函数TIM_ICInit 249  
19.2.5 函数TIM_TimeBaseStructInit 251  
19.2.6 函数TIM_OCStructInit 251  
19.2.7 函数TIM_ICStructInit 252  
19.2.8 函数TIM_Cmd 252  
19.2.9 函数TIM_ITConfig 253  
19.2.10 函数TIM_DMAConfig 253  
19.2.11 函数TIM_DMAcmd 255  
19.2.12 函数TIM/InternalClockConfig 255  
19.2.13 函数TIM_ITRxExternalClockConfig 256  
19.2.14 函数TIM_TIxExternalClockConfig 256  
19.2.15 函数TIM_ETRClockModelConfig 257  
19.2.16 函数TIM_ETRClockMode2Config 258  
19.2.17 函数TIM_ETRConfig 258  
19.2.18 函数TIM_SelectInputTrigger 259  
19.2.19 函数TIM_PrescalerConfig 260  
19.2.20 函数TIM CounterModeConfig 260  
19.2.21 函数TIM_ForcedOC1Config 261  
19.2.22 函数TIM_ForcedOC2Config 261  
19.2.23 函数TIM_ForcedOC3Config 262  
19.2.24 函数TIM_ForcedOC4Config 262  
19.2.25 函数TIMARRPreloadConfig 263  
19.2.26 函数TIM_SelectCCDMA 263  
19.2.27 函数TIM_OC1PreloadConfig 264  
19.2.28 函数TIM_OC2PreloadConfig 264  
19.2.29 函数TIM_OC3PreloadConfig 265  
19.2.30 函数TIM_OC4PreloadConfig 265  
19.2.31 函数TIM_OC1FastConfig 266  
19.2.32 函数TIM_OC2FastConfig 266  
19.2.33 函数TIM_OC3FastConfig 267  
19.2.34 函数TIM_OC4FastConfig 267  
19.2.35 函数TIM_ClearOC1Ref 268  
19.2.36 函数TIM_ClearOC2Ref 268  
19.2.37 函数TIM_ClearOC3Ref 269  
19.2.38 函数TIM_ClearOC4Ref 269  
19.2.39 函数TIM_UpdateDisableConfig 270  
19.2.40 函数TIM EncoderInterfaceConfig 270  
19.2.41 函数TIM_GenerateEvent 271  
19.2.42 函数TIM_OC1PolarityConfig 271  
19.2.43 函数TIM_OC2PolarityConfig 272  
19.2.44 函数TIM_OC3PolarityConfig 272  
19.2.45 函数TIM_OC4PolarityConfig 273  
19.2.46 函数TIM_UpdateRequestConfig 273

19.2.47 函数TIM_SelectHallSensor 274  
19.2.48 函数TIM_SelectOnePulseMode 274  
19.2.49 函数TIM_SelectOutputTrigger 275  
19.2.50 函数TIM_SelectSlaveMode 276  
19.2.51 函数TIM_SelectMasterSlaveMode 277  
19.2.52 函数TIM_SetCounter 277  
19.2.53 函数TIM_SetAutoreload 278  
19.2.54 函数TIM_SetCompare1 278  
19.2.55 函数TIM_SetCompare2 279  
19.2.56 函数TIM_SetCompare3 279  
19.2.57 函数TIM_SetCompare4 280  
19.2.58 函数TIM_SetIC1Prescaler 280  
19.2.59 函数TIM_SetIC2Prescaler 281  
19.2.60 函数TIM_SetIC3Prescaler 281  
19.2.61 函数TIM_SetIC4Prescaler 282  
19.2.62 函数TIM_SetClockDivision 282  
19.2.63 函数TIM_GetCapture1 283  
19.2.64 函数TIM_GetCapture2 283  
19.2.65 函数TIM_GetCapture3 283  
19.2.66 函数TIM_GetCapture4 284  
19.2.67 函数TIM_GetCounter 284  
19.2.68 函数TIM_GetPrescaler 285  
19.2.69 函数TIM_GetFlagStatus 285  
19.2.70 函数TIM_ClearFlag 286  
19.2.71 函数TIM_GetITStatus 286  
19.2.72 函数TIM_ClearITPendingBit 287

20.1 TIM1 寄存器结构 ..... 288  
20.2 TIM1 库函数 ..... 290

20.2.1 函数TIM1_DeInit 292  
20.2.2 函数TIM1(TIM1BaseInit 292  
20.2.3 函数TIM1_OC1Init 294  
20.2.4 函数TIM1_OC2Init 296  
20.2.5 函数TIM1_OC3Init 296  
20.2.6 函数TIM1_OC4Init 297  
20.2.7 函数TIM1_BDTRConfig 297  
20.2.8 函数TIM1_ICInit 299  
20.2.9 函数TIM1_PWMConfig 300  
20.2.10 函数TIM1_TimeBaseStructInit 301  
20.2.11 函数TIM1_OCStructInit 301  
20.2.12 函数TIM1_ICStructInit 302  
20.2.13 函数TIM1_BDTRStructInit 303  
20.2.14 函数TIM1_Cmd 303  
20.2.15 函数TIM1_CtrlPWMOputs 304  
20.2.16 函数TIM1_ITConfig 304  
20.2.17 函数TIM1_DMAConfig 305  
20.2.18 函数TIM1_DMAcmd 306  
20.2.19 函数TIM1/InternalClockConfig 307  
20.2.20 函数TIM1_ETRClockModelConfig 307  
20.2.21 函数TIM1_ETRClockMode2Config 308  
20.2.22 函数TIM1_ETRConfig 309  
20.2.23 函数TIM1_ITRxExternalClockConfig 309  
20.2.24 函数TIM1_TXExternalClockConfig 310  
20.2.25 函数TIM1_SelectionTrigger 310

20.2.26 函数TIM1_UpdateDisableConfig 311  
20.2.27 函数TIM1_UpdateRequestConfig 311  
20.2.28 函数TIM1_SelectHallSensor 312  
20.2.29 函数TIM1_SelectOnePulseMode 312  
20.2.30 函数TIM1_SelectOutputTrigger 313  
20.2.31 函数TIM1_SelectSlaveMode 313  
20.2.32 函数TIM1_SelectMasterSlaveMode 314  
20.2.33 函数TIM1 EncoderInterfaceConfig 315  
20.2.34 函数TIM1_PrescalerConfig 315  
20.2.35 函数TIM1_ModeConfig 316  
20.2.36 函数TIM1_ForceDC1Config 316  
20.2.37 函数TIM1_ForceDC2Config 317  
20.2.38 函数TIM1_FocusedOC3Config 317  
20.2.39 函数TIM1_FocusedOC4Config 318  
20.2.40 函数TIM1_ARRPreloadConfig 318  
20.2.41 函数TIM1_SelectionCOM 319  
20.2.42 函数TIM1_SelectCCDMA 319  
20.2.43 函数TIM1_CCPreloadControl 320  
20.2.44 函数TIM1_OC1PreloadConfig 320  
20.2.45 函数TIM1_OC2PreloadConfig 321  
20.2.46 函数TIM1_OC3PreloadConfig 321  
20.2.47 函数TIM1_OC4PreloadConfig 322  
20.2.48 函数TIM1_OC1FastConfig 322  
20.2.49 函数TIM1_OC2FastConfig 323  
20.2.50 函数TIM1_OC3FastConfig 323  
20.2.51 函数TIM1_OC4FastConfig 324  
20.2.52 函数TIM1_ClearOC1Ref 324  
20.2.53 函数TIM1_ClearOC2Ref 325  
20.2.54 函数TIM1_ClearOC3Ref 325  
20.2.55 函数TIM1_ClearOC4Ref 326  
20.2.56 函数TIM1_GenerateEvent 326  
20.2.57 函数TIM1_OC1PolarityConfig 327  
20.2.58 函数TIM1_OC1NPolarityConfig 327  
20.2.59 函数TIM1_OC2PolarityConfig 328  
20.2.60 函数TIM1_OC2NPolarityConfig 328  
20.2.61 函数TIM1_OC3PolarityConfig 329  
20.2.62 函数TIM1_OC3NPolarityConfig 329  
20.2.63 函数TIM1_OC4PolarityConfig 330  
20.2.64 函数TIM1_CCxCmd 330  
20.2.65 函数TIM1_CCxCCmd 331  
20.2.66 函数TIM1_SelectOCxM 331  
20.2.67 函数TIM1_SetCounter 332  
20.2.68 函数TIM1_SetAutoreload 332  
20.2.69 函数TIM1_SetCompare1 333  
20.2.70 函数TIM1_SetCompare2 333  
20.2.71 函数TIM1_SetCompare3 334  
20.2.72 函数TIM1_SetCompare4 334  
20.2.73 函数TIM1_SetIC1Prescaler 335  
20.2.74 函数TIM1_SetIC2Prescaler 335  
20.2.75 函数TIM1_SetIC3Prescaler 336  
20.2.76 函数TIM1_SetIC4Prescaler 336  
20.2.77 函数TIM1_SetClockDivision 337  
20.2.78 函数TIM1_GetCapture1 337

20.2.79 函数TIM1_GetCapture2 338  
20.2.80 函数TIM1_GetCapture3 338  
20.2.81 函数TIM1_GetCapture4 338  
20.2.82 函数TIM1_GetCounter 339  
20.2.83 函数TIM1_GetPrescaler 339  
20.2.84 函数TIM1_GetFlagStatus 340  
20.2.85 函数TIM1_ClearFlag 341  
20.2.86 函数TIM1_GetITStatus 341  
20.2.87 函数TIM1_ClearITPendingBit 342

21.1USART寄存器结构 343  
21.2USART库函数 344

21.2.1 函数USART_DeInit 345  
21.2.2 函数USART_Init 346  
21.2.3 函数USART_StructInit 349  
21.2.4 函数USART_Cmd 349  
21.2.5 函数USART_ITConfig 350  
21.2.6 函数USART_DMACmd 351  
21.2.7 函数USART_SetAddress 351  
21.2.8 函数USART_WakeUpConfig 352  
21.2.9 函数USART_ReceiverWakeUpCmd 352  
21.2.10 函数USART_LINBreakDetectiLengthConfig 353  
21.2.11 函数USART_LINCmd 353  
21.2.12 函数USART_SendData 354  
21.2.13 函数USART_ReceiveData 354  
21.2.14 函数USART_SendBreak 355  
21.2.15 函数USART_SetGuardTime 355  
21.2.16 函数USART_SetPrescaler 356  
21.2.17 函数USART_SmartCardCmd 356  
21.2.18 函数USART_SmartCardNackCmd 357  
21.2.19 函数USART_HalfDuplexCmd 357  
21.2.20 函数USART_IrDACConfig 358  
21.2.21 函数USART_IrDACmd 358  
21.2.22 函数USART_GetFlagStatus 359  
21.2.23 函数USART_ClearFlag 360  
21.2.24 函数USART_GetITStatus 360  
21.2.25 函数USART_ClearITPendingBit 361

22.1WWDG寄存器结构 362  
22.2 WWDG库函数 363

22.1.1 函数WWDG_DeInit 363  
22.1.2 函数WWDG_SetPrescaler 363  
22.1.3 函数WWDG_SetWindowValue 364  
22.1.4 函数WWDG_EnableIT 364  
22.1.5 函数WWDG_SetCounter 365  
22.1.6 函数WWDG_Enable 365  
22.1.7 函数WWDG_GetFlagStatus 366  
22.1.8 函数WWDG_ClearFlag 366

# 表格目录

Table 1. 本文档所有缩写定义 27  
Table 2. 固件函数库文件描述 33  
Table 3. 函数描述格式 ..... 38  
Table 4. ADC 寄存器 39  
Table 5. ADC 固件库函数 ..... 40  
Table 6.函数 ADC_DeInit 42  
Table 7. 函数 ADC_Init 42  
Table 8. 函数 ADC_Mode 定义 ..... 43  
Table 9. ADC_ExternalTrigConv 定义表 ..... 43  
Table 10. ADC_DataAlign 定义表 ..... 43  
Table 11. 函数 ADC_StructInit 44  
Table 12. ADC_InitStruct 缺省值 ..... 44  
Table 13. 函数 ADC_Cmd 44  
Table 14. 函数 ADC_DMAcmd ..... 45  
Table 15. 函数 ADC_ITConfig ..... 45  
Table 16. ADC_IT 定义表 ..... 45  
Table 17. 函数 ADC Reset Calibration 46  
Table 18. 函数 ADC_GetResetCalibrationStatus  
Table 19. 函数 ADC_StartCalibration 46  
Table 20. 函数 ADC_GetCalibrationStatus ..... 47  
Table 21. 函数 ADC_SoftwareStartConvCmd. 47  
Table 22. 函数 ADC_GetSoftwareStartConvStatus 48  
Table 23. 函数 ADC_DiscModeChannelCountConfig ..... 48  
Table 24. 函数 ADC_DiscModeCmd  
Table 25. 函数 ADC_RegularChannelConfig ..... 49  
Table 26. ADC_Channel 值 ..... 49  
Table 27. ADC_SampleTime 值： 50  
Table 28. 函数 ADC_ExternalTrigConvConfig ..... 51  
Table 29. 函数 ADC_GetConversionValue ..... 51  
Table 30. 函数 ADC_GetDuelModeConversionValue 52  
Table 31. 函数 ADC_AutoInjectedConvCmd ..... 52  
Table 32. 函数 ADC_InjectedDiscModeCmd 53  
Table 33. 函数 ADC_ExternalTrigInjectedConvConfig ..... 53  
Table 34. ADC_ExternalTrigInjectedConv 值 ..... 53  
Table 35. 函数 ADC_ExternalTrigInjectedConvCmd ..... 54  
Table 36. 函数 ADC_SoftwareStartinjectedConvCmd ..... 54  
Table 37. 函数 ADC_GetsoftwareStartinjectedConvStatus 55  
Table 38. 函数 ADC_InjectedChannleConfig ..... 55  
Table 39. 函数 ADC_InjectedSequencerLengthConfig ..... 56  
Table 40. 函数 ADC_SetinjectedOffset ..... 56  
Table 41. ADC_InjectedChannel 值 ..... 56  
Table 42. 函数 ADC_GetInjectedConversionValue ..... 57  
Table 43. 函数 ADC_AnalogWatchdogCmd. 57  
Table 44. ADC_AnalogWatchdog 值 ..... 57  
Table 45. 函数 ADC_AnalogWatchdongThresholdsConfig. 58  
Table 46. 函数 ADC_AnalogWatchdongSingleChannelConfig ..... 58  
Table 47. 函数 ADC_TampSensorVrefintCmd  
Table 48. 函数 ADC_GetFlagStatus ..... 59  
Table 49. ADC_FLAG 的值 ..... 59  
Table 50. 函数 ADC_ClearFlag 60

Table 51. 函数 ADC_GetITStatus. 60  
Table 52. 函数 ADC_ClearITPendingBit. 61  
Table 53. BKP 寄存器 62  
Table 54. BKP 库函数 ..... 63  
Table 55. 函数 BKP_DeInit. 64  
Table 56. 函数 BKP_TamperPinLevelConfig 64  
Table 57. BKP_TamperPinLevel 值 64  
Table 58. 函数 BKP_TamperPinCmd. 65  
Table 59. 函数 BKP_ITConfig 65  
Table 60. 函数 BKPRTOSOutputConfig 66  
Table 61. BKP_RTCOutputSource 值 66  
Table 62. 函数 BKP_SetRTCCalibrationValue  
Table 63. 函数 BKP_WritesBackupRegister  
Table 64. BKP_DR 值 67  
Table 65. 函数 BKP_ReadBackupRegister  
Table 66. 函数 BKP_GetFlagStatus 68  
Table 67. 函数 BKP_ClearFlag ..... 68  
Table 68. 函数 BKP_GetITStatus  
Table 69. 函数 BKP_ClearITPendingBit  
Table 70. CAN 寄存器 ..... 71  
Table 71. CAN 库函数 ..... 72  
Table 72. 函数 CAN_DeInit. 72  
Table 73. 函数 CAN_Init  
Table 74. CAN_Mode 值 ..... 74  
Table 75. CAN_SJW 值 ..... 74  
Table 76. CAN_BS1 值 ..... 74  
Table 77. CAN_BS1 值 ..... 74  
Table 78. 函数 CAN_FilterInit. 75  
Table 79. CAN_FilterMode 值 ..... 75  
Table 80. CAN_FilterScale 值 ..... 75  
Table 81. CAN_FilterFIFO 值 ..... 76  
Table 82. 函数 CAN_StructInit. 76  
Table 83. CAN_InitStruct 结构缺省值 ..... 76  
Table 84. 函数 CAN_ITConfig ..... 77  
Table 85. CAN_IT 值 ..... 77  
Table 86. 函数 CAN_Transmit ..... 78  
Table 87. IDE 值 ..... 78  
Table 88. RTR 值 ..... 78  
Table 89. 函数 CAN_TransmitStatus ..... 79  
Table 90. 函数 CAN_CancelTransmit. 79  
Table 91. 函数 CAN_FIFORelease ..... 80  
Table 92. 函数 CAN_MessagePending ..... 80  
Table 93. 函数 CAN_Receive ..... 81  
Table 94. IDE 值 ..... 81  
Table 95. RTR 值 ..... 81  
Table 96. 函数 CAN_Sleep ..... 82  
Table 97. 函数 CAN_WakeUp ..... 82  
Table 98. 函数 CAN_GetFlagStatus ..... 83  
Table 99. CAN_FLAG 值 ..... 83  
Table 100. 函数 CAN_ClearFlag ..... 83  
Table 101. 函数 CAN_GetITStatus ..... 84  
Table 102. CAN_IT 值 ..... 84  
Table 103. 函数 CAN_ClearITPendingBit ..... 85

Table 104. DMA 寄存器 ..... 86  
Table 105. DMA 库函数 ..... 88  
Table 106. 函数 DMA_DeInit. 89  
Table 107. 函数 DMA_Init. 89  
Table 108. DMA_DIR 值 ..... 90  
Table 109. DMA_PeripheralInc 值 90  
Table 110. DMA_MemoryInc 值 ..... 90  
Table 111. DMA_PeripheralDataSize 值 ..... 90  
Table 112. DMA_MemoryDataSize 值 ..... 90  
Table 113. DMA_Mode 值 ..... 90  
Table 114. DMA_Priority 值 ..... 91  
Table 115. DMA_M2M 值 91  
Table 116. 函数 DMA_StructInit 92  
Table 117. DMA_InitStruct 缺省值 ..... 92  
Table 118. 函数 DMA_Cmd. 92  
Table 119. 函数 DMA_ITConfig. 93  
Table 120. DMA_IT 值 ..... 93  
Table 121. 函数 DMA_GetCurrDataCounte 93  
Table 122. 函数 DMA_GetFlagStatus. 94  
Table 123. DMA_FLAG 值 ..... 94  
Table 124. 函数 DMA_ClearFlag ..... 95  
Table 125. 函数 DMA_GetITStatus 95  
Table 126. DMA_IT 值 ..... 95  
Table 127. 函数 DMA_ClearITPendingBit ..... 96  
Table 128.EXTI 寄存器 97  
Table 129.EXTI库函数 98  
Table 130. 函数EXTI_DeInit 98  
Table 131. 函数EXTI_Init. 99  
Table 132.EXTI_Line值 99  
Table 133.EXTI_Mode值 100  
Table 134.EXTI_Trigger值 ..... 100  
Table 135. 函数EXTISTRUCTInit 100  
Table 136.EXTI_InitStruct 缺省值 ..... 100  
Table 137. 函数EXTI_GenerateSWInterrupt ..... 101  
Table 138. 函数EXTI_GetFlagStatus ..... 101  
Table 139. 函数EXTI_ClearFlag ..... 102  
Table 140. 函数EXTI_GetITStatus 102  
Table 141. 函数EXTI_ClearITPendingBit ..... 103  
Table 142. FLASH 寄存器 ..... 104  
Table 143. Option Byte (OB) 寄存器 ..... 104  
Table 144. FLASH 库函数 ..... 105  
Table 145. 函数 FLASH_SetLatency ..... 106  
Table 146. FLASH_Latency 值 ..... 106  
Table 147. 函数 FLASH_HalfCycleAccessCmd  
Table 148. FLASH_HalfCycleAccess 值 ..... 107  
Table 149. 函数 FLASH_PrefetchBufferCmd. 107  
Table 150. FLASH_PrefetchBuffer 值 ..... 107  
Table 151. 函数 FLASH_Unclock ..... 108  
Table 152. 函数 FLASH_Lock. 108  
Table 153. 函数 FLASH_ErasePage ..... 109  
Table 154. 函数 FLASH_EraseAllPages. 109  
Table 155. 函数 FLASH_EraseOptionBytes ..... 110  
Table 156. 函数 FLASH_ProgramWord ..... 110

Table 157. 函数 FLASH_ProgramHalfWord ..... 111  
Table 158. 函数 FLASH_ProgramOptionByteData  
Table 159. 函数 FLASH_EnableWriteProtection  
Table 160. FLASH_Page 值 ..... 112  
Table 161. 函数 FLASH_ReadOutProtection ..... 113  
Table 162. 函数 FLASH 用户OptionByteConfig  
Table 163. OB_IWDG 值 ..... 114  
Table 164. OB_STOP 值 ..... 114  
Table 165. OB_STDBY 值 ..... 114  
Table 166. 函数 FLASH_GetUserOptionByte ..... 115  
Table 167. 函数 FLASH_GetWriteProtectionOptionByte ..... 115  
Table 168. 函数 FLASH_GetReadOutProtectionStatus ..... 116  
Table 169. 函数 FLASH_GetPrefetchBufferStatus ..... 116  
Table 170. 函数 FLASH_ITConfig ..... 117  
Table 171. FLASH_IT 值 ..... 117  
Table 172. 函数 FLASH_GetFlagStatus ..... 117  
Table 173. FLASH_FLAG 值 ..... 117  
Table 174. 函数 FLASH_ClearFlag ..... 118  
Table 175. FLASH_FLAG 值 ..... 118  
Table 176. 函数 FLASH_GetStatus ..... 119  
Table 177. 函数 FLASH_WaitForLastOperation ..... 119  
Table 178. GPIO 寄存器 ..... 120  
Table 179. GPIO 库函数 ..... 122  
Table 180. 函数 GPIO_DeInit. 123  
Table 181. 函数 GPIO_AFIODeInit. 123  
Table 182. 函数 GPIO_Init. 124  
Table 183. GPIO_Pin 值 ..... 124  
Table 184. GPIO_Speed 值 ..... 125  
Table 185. GPIO_Mode 值 ..... 125  
Table 186. GPIO_Mode 的索引和编码 ..... 125  
Table 187. 函数 GPIOStructInit ..... 126  
Table 188. GPIO_InitStruct 缺省值 ..... 126  
Table 189. 函数 GPIO_ReadInputDataBit ..... 126  
Table 190. 函数 GPIO_ReadInputData ..... 127  
Table 191. 函数 GPIO_ReadOutputDataBit. 127  
Table 192. 函数 GPIO_ReadOutputData ..... 128  
Table 193. 函数 GPIO_SetBits ..... 128  
Table 194. 函数 GPIO_SetBits ..... 129  
Table 195. 函数 GPIO_Writes  
Table 196. 函数 GPIO_Write ..... 130  
Table 197. 函数 GPIO_PinLockConfig. 130  
Table 198. 函数 GPIO_EventOutputConfig. 131  
Table 199. GPIO_PortSource 值 ..... 131  
Table 200. 函数 GPIO_EventOutputCmd ..... 131  
Table 201. 函数 GPIO_PinRemapConfig. 132  
Table 202. GPIO_Remap 值 ..... 132  
Table 203. 函数 GPIO_EXTILineConfig ..... 133  
Table 204. I2C 寄存器 ..... 134  
Table 205. I2C 库函数 ..... 135  
Table 206. 函数 I2C_DeInit ..... 136  
Table 207. 函数 I2C_Init ..... 137  
Table 208. I2C_Mode 值 ..... 137  
Table 209. I2C_DutyCycle 值 ..... 137

Table 210. I2C Ack 值 ..... 138  
Table 211. I2C_AcknowledgedAddress 值 ..... 138  
Table 212. 函数 I2CSTRUCTInit 138  
Table 213. I2C_InitStruct 缺省值 ..... 138  
Table 214. 函数 I2C_Cmd. 139  
Table 215. 函数 I2C_DMACmd 139  
Table 216. 函数 I2C_DMALastTransferCmd ..... 140  
Table 217. 函数 I2C_GenerateSTART 140  
Table 218. 函数 I2C_GenerateSTOP ..... 141  
Table 219. 函数 I2C_AcknowledgeConfig. 141  
Table 220. 函数 I2C_OwnAddress2Config. 142  
Table 221. 函数 I2C_DualAddressCmd ..... 142  
Table 222. 函数 I2C_GeneralCallCmd ..... 143  
Table 223. 函数 I2C_ITConfig ..... 143  
Table 224. I2C_IT 值 ..... 143  
Table 225. 函数 I2C_SendData 144  
Table 226. 函数 I2C_ReceiveData 144  
Table 227. 函数 I2C_Send7bitAddress ..... 145  
Table 228. I2C_Direction 值 ..... 145  
Table 229. 函数 I2C_ReadRegister 145  
Table 230. I2CRegister 值 ..... 146  
Table 231. 函数 I2C_SoftwareResetCmd. 146  
Table 232. 函数 I2C_SMBusAlertConfig ..... 147  
Table 233. I2C_SMBusAlert 值 ..... 147  
Table 234. 函数 I2C_TransmitPEC ..... 147  
Table 235. 函数 I2C_PECPositionConfig ..... 148  
Table 236. I2C_PECPosition 值 ..... 148  
Table 237. 函数 I2C CalculatePEC 148  
Table 238. 函数 I2C_GetPEC ..... 149  
Table 239. 函数 I2C_ARPCmd ..... 149  
Table 240. 函数 I2C_SqueezeTime . 150  
Table 241. 函数 I2C_FastModeDutyCycleConfig ..... 150  
Table 242. I2C_DutyCycle 值 ..... 150  
Table 243. 函数 I2C_GetLastEvent ..... 151  
Table 244. 函数 I2C_CheckEvent ..... 151  
Table 245. I2C_Event 值 ..... 151  
Table 246. 函数 I2C_GetFlagStatus ..... 152  
Table 247. I2C_FLAG 值 ..... 152  
Table 248. 函数 I2C_ClearFlag ..... 153  
Table 249. I2C_FLAG 值 ..... 153  
Table 250. 函数 I2C_GetITStatus ..... 154  
Table 251. I2C_IT 值 ..... 154  
Table 252. 函数 I2C_ClearITPendingBit ..... 155  
Table 253. I2C_IT 值 ..... 155  
Table 254. IWDG 寄存器 ..... 156  
Table 255. IWDG 库函数 ..... 157  
Table 256. 函数 IWDG_WritesCmd  
Table 257. IWDG_Writes 值 ..... 157  
Table 258. 函数 IWDG_SetPrescaler ..... 158  
Table 259. IWDG_Prescaler 值 ..... 158  
Table 260. 函数 IWDG_SetReload 158  
Table 261. 函数 IWDG_ReloadCounter ..... 159  
Table 262. 函数 IWDG_Enable. 159

Table 263. 函数 IWDG_GetFlagStatus ..... 159  
Table 264. IWDG_FLAG 值 ..... 160  
Table 265. NVIC 寄存器 ..... 161  
Table 266. NVIC 库函数 ..... 163  
Table 267. 函数 NVIC_DeInit. 164  
Table 268. 函数 NVIC_SCBDeInit ..... 164  
Table 269. 函数 NVIC_PriorityGroupConfig ..... 165  
Table 270. NVIC_PriorityGroup 值 ..... 165  
Table 271. 函数 NVIC_Init ..... 166  
Table 272. NVIC_IRQChannel 值 ..... 166  
Table 273. 先占优先级和从优先级值 167  
Table 274. 函数 NVIC_StructInit 168  
Table 275. NVIC_InitStruct 缺省值 ..... 168  
Table 276. 函数 NVIC_SETPRIMASK ..... 169  
Table 277. 函数 NVIC_RESETPRIMASK ..... 169  
Table 278. 函数 NVIC_SETFAULTMASK ..... 170  
Table 279. 函数 NVIC_RESETFAULTMASK ..... 170  
Table 280. 函数 NVIC_BASEPRCONFIG 171  
Table 281. 函数 NVIC_GetBASEPRI. 171  
Table 282. 函数 NVIC_GetCurrentPendingIRQChannel ..... 172  
Table 283. 函数 NVIC_GetIRQChannelPendingBitStatus ..... 172  
Table 284. 函数 NVIC_SetIRQChannelPendingBit ..... 173  
Table 285. 函数 NVIC_ClearIRQChannelPendingBit ..... 173  
Table 286. 函数 NVIC_GetCurrentActiveHandler 174  
Table 287. 函数 NVIC_GetIRQChannelActiveBitStatus ..... 174  
Table 288. 函数 NVIC_GetCPUID 175  
Table 289. 函数 NVIC_SetVectorTable ..... 175  
Table 290. NVIC_VectTab 值 ..... 175  
Table 291. 函数 NVIC_GenerateSystemReset. 176  
Table 292. 函数 NVICGenerateCoreReset. 176  
Table 293. 函数 NVIC_SystemLPConfig ..... 177  
Table 294. LowPowerMode 值 ..... 177  
Table 295. 函数 NVIC_SystemHandlerConfig ..... 177  
Table 296. SystemHandler 值 ..... 178  
Table 297. SystemHandler 定义 ..... 178  
Table 298. SystemHandler_NMI 定义 ..... 179  
Table 299. SystemHandler_HardFault 定义 ..... 179  
Table 300. SystemHandler_MemoryManage 定义 ..... 179  
Table 301. SystemHandler_BusFault 定义 ..... 180  
Table 302. SystemHandler_UsageFault 定义 ..... 180  
Table 303. SystemHandler_SVCall 定义 ..... 180  
Table 304. SystemHandler_DisqMonitor 定义 ..... 181  
Table 305. SystemHandler_PSV 定义 ..... 181  
Table 306. SystemHandler_Systick 定义 ..... 181  
Table 307. 函数 NVIC_SystemHandlerPriorityConfig ..... 182  
Table 308. SystemHandler 类型 ..... 182  
Table 309. 函数 NVIC_GetSystemHandlerPendingBitStatus ..... 183  
Table 310. SystemHandler 类型 ..... 183  
Table 311. 函数 NVIC_SetSystemHandlerPendingBit ..... 183  
Table 312. SystemHandler 类型 ..... 184  
Table 313. 函数 NVIC_ClearSystemHandlerPendingBit ..... 184  
Table 314. SystemHandler 类型 ..... 184  
Table 315. 函数 NVIC_GetSystemHandlerActiveBitStatus ..... 184

Table 316. SystemHandler 类型 ..... 185  
Table 317. 函数 NVIC_GetFaultHandlerSources 185  
Table 318. SystemHandler 类型 ..... 185  
Table 319. 函数 NVIC_GetFaultAddress ..... 186  
Table 320. SystemHandler 类型 ..... 186  
Table 321. PWR 寄存器 ..... 187  
Table 322. PWR 库函数 ..... 188  
Table 323. 函数 PWR_DeInit. 188  
Table 324. 函数 PWR_BackupAccessCmd. 189  
Table 325. 函数 PWR_PVDCmd ..... 189  
Table 326. 函数 PWR_PVDLevelConfig ..... 190  
Table 327. PWR_PVDLevel 值 ..... 190  
Table 328. 函数 PWR_WakeUpPinCmd ..... 190  
Table 329. 函数 PWR_EnterSTOPMode ..... 191  
Table 330. PWR_Regulator 值 ..... 191  
Table 331. PWR_Regulator 值 ..... 191  
Table 332. 函数 PWR_EnterSTANDBYMode ..... 191  
Table 333. 函数 PWR_GetFlagStatus ..... 192  
Table 334. PWR_FLAG 值 ..... 192  
Table 335. 函数 PWR_ClearFlag ..... 192  
Table 336. RCC 寄存器 ..... 193  
Table 337. RCC 库函数 ..... 194  
Table 339. 函数 RCC_HSEConfig ..... 195  
Table 340. RCC_HSE 定义 ..... 195  
Table 341. 函数 RCC_WaitForHSEStartUp. 196  
Table 342. 函数 RCC_AdjustHSICalibrationValue. 196  
Table 343. 函数 RCC_HSICmd ..... 197  
Table 344. 函数 RCC_PLLConfig ..... 197  
Table 345. RCC_PLLSource 值 ..... 197  
Table 346. RCC_PLLMul 值 ..... 198  
Table 347. 函数 RCC_PLLCmd. 198  
Table 348. 函数 RCC_SYSCLKConfig ..... 199  
Table 349. RCC_SYSCLKSource 值 ..... 199  
Table 350. 函数 RCC_GetSYSCLKSource 199  
Table 351. 函数 RCC_HCLKConfig. 200  
Table 352. RCC_HCLK 值 ..... 200  
Table 353. 函数 RCC_PCLK1Config ..... 200  
Table 354. RCC_PCLK1 值 ..... 201  
Table 355. 函数 RCC_PCLK2Config ..... 201  
Table 356. RCC_PCLK1 值 ..... 201  
Table 357. 函数 RCC_ITConfig ..... 202  
Table 358. RCC_IT 值 ..... 202  
Table 359. 函数 RCC_USBCLKConfig ..... 202  
Table 360. RCC_USBCLKSource 值 ..... 203  
Table 361. 函数 RCC_ADCCLKConfig ..... 203  
Table 362. RCC_ADCCLKSource 值 ..... 203  
Table 363. 函数 RCC_LSEConfig ..... 204  
Table 364. RCC_LSE 定义 ..... 204  
Table 365. 函数 RCC_LSICmd. 204  
Table 366. 函数 RCC_RTCCLKConfig ..... 205  
Table 367.RCC_RTCCLKSource值 205  
Table 368. 函数 RCC_RTCCLKCmd ..... 205  
Table 369. 函数 RCC_GetClocksFreq ..... 206

Table 370. 函数 RCC_AHBPeriphClockCmd ..... 207  
Table 371. RCC_AHBPeriph 值 ..... 207  
Table 372. 函数 RCC_APB2PeriphClockCmd ..... 207  
Table 373. RCC_AHB2Periph 值 ..... 208  
Table 374. 函数 RCC_APB1PeriphClockCmd ..... 208  
Table 375. RCC_AHB1Periph 值 ..... 208  
Table 376. 函数 RCC_APB2PeriphResetCmd. 209  
Table 377. 函数 RCC_APB1PeriphResetCmd. 209  
Table 378. 函数 RCC_BackupResetCmd ..... 210  
Table 379. 函数 RCC_ClockSecuritySystemCmd ..... 210  
Table 380. 函数 RCC_MCOConfig ..... 210  
Table 381. RCC_MCO 值 ..... 211  
Table 382. 函数 RCC_GetFlagStatus ..... 211  
Table 383. RCC_FLAG 值 ..... 211  
Table 384. 函数 RCC_ClearFlag ..... 212  
Table 385. 函数 RCC_GetITStatus ..... 212  
Table 386. RCC_IT 值 ..... 212  
Table 387. 函数 RCC_ClearITPendingBit ..... 213  
Table 388. RCC_IT 值 ..... 213  
Table 389. RTC 寄存器 ..... 214  
Table 390. RTC 库函数 ..... 215  
Table 391. 函数 RTC_ITConfig ..... 216  
Table 392. RTC_IT 值 ..... 216  
Table 393. 函数 RTC_EnterConfigMode ..... 216  
Table 394. 函数 RTC_ExitConfigMode ..... 217  
Table 395. 函数 RTC_GetCounter ..... 217  
Table 396. 函数 RTC_SetCounter ..... 218  
Table 397. 函数 RTC_SetPrescaler ..... 218  
Table 398. 函数 RTC_SetAlarm ..... 219  
Table 399. 函数 RTC_GetDivider 219  
Table 400. 函数 RTC_WaitForLastTask 220  
Table 401. 函数 RTC_WaitForSynchro. 220  
Table 402. 函数 RTC_GetFlagStatus ..... 221  
Table 403. RTC_FLAG 值 ..... 221  
Table 404. 函数 RTC_ClearFlag ..... 221  
Table 405. 函数 RTC_GetITStatus ..... 222  
Table 406. 函数 RTC_ClearITPendingBit ..... 222  
Table 407. SPI 寄存器 ..... 223  
Table 408. SPI 库函数 ..... 224  
Table 409. 函数 SPI_DeInit ..... 225  
Table 410. 函数 SPI_Init ..... 225  
Table 411. SPI_Mode 值 ..... 226  
Table 412. SPI_Mode 值 ..... 226  
Table 413. SPI_DataSize 值 ..... 226  
Table 414. SPI_SPI_CPOL 值 ..... 226  
Table 415. SPI_SPI_CPHA 值 ..... 226  
Table 416. SPI_NSS 值 ..... 226  
Table 417. SPI_BaudRatePrescaler 值 ..... 226  
Table 418. SPI_FirstBit 值 ..... 227  
Table 419. 函数 SPI_SectInit ..... 227  
Table 420. SPI_InitStruct 缺省值 ..... 227  
Table 421. 函数 SPI_Cmd ..... 228  
Table 422. 函数 SPI_ITConfig ..... 228

Table 423. SPI_IT 值 ..... 228  
Table 424. 函数 SPI_DMAcmd. 229  
Table 425. SPI_DMAReq 值 ..... 229  
Table 426. 函数 SPI_SendData ..... 229  
Table 427. 函数 SPI_ReceiveData ..... 230  
Table 428. 函数 SPI_NSSInternalSoftwareConfig. 230  
Table 429. SPI_DMAReq 值 ..... 230  
Table 430. 函数 SPI_SSOutputCmd ..... 231  
Table 431. 函数 SPI_DataSizeConfig ..... 231  
Table 432. SPI_DMAReq 值 ..... 231  
Table 433. 函数 SPI_TransmitCRC ..... 232  
Table 434. 函数 SPI CalculateCRC ..... 232  
Table 435. 函数 SPI_GetCRC ..... 233  
Table 436. SPI_CRC 值 ..... 233  
Table 437. 函数 SPI_GetCRCPolynomial ..... 233  
Table 438. 函数 SPI_BiDirectionalLineConfig ..... 234  
Table 439. SPI_CRC 值 ..... 234  
Table 440. 函数 SPI_GetFlagStatus ..... 234  
Table 441. SPI_FLAG 值 ..... 235  
Table 442. 函数 SPI_ClearFlag ..... 235  
Table 443. 函数 SPI_GetITStatus. 235  
Table 444. SPI_IT 值 ..... 236  
Table 445. 函数 SPI_ClearITPendingBit ..... 236  
Table 446. SysTick 寄存器 ..... 237  
Table 447. SysTick 库函数 ..... 238  
Table 448. 函数 SysTick_CLKSourceConfig ..... 238  
Table 449. SysTick_CLKSource 值 ..... 238  
Table 450. 函数 SysTick_SetReload 239  
Table 451. 函数 SysTick CounterCmd ..... 239  
Table 452. SysTick Counter 值 ..... 239  
Table 453. 函数 SysTick_ITConfig. 240  
Table 454. 函数 SysTick_GetCounter ..... 240  
Table 455. 函数 SysTick _ GetFlagStatus ..... 241  
Table 456. SysTick_FLAG 值 ..... 241  
Table 457. TIM 寄存器 ..... 243  
Table 458. TIM 库函数 ..... 244  
Table 459. 函数 TIM_DeInit ..... 246  
Table 460. 函数TIM_TimeBaseInit ..... 246  
Table 461. TIM_ClockDivision 值 ..... 247  
Table 462. TIM CounterMode 值 ..... 247  
Table 463. 函数 TIM_OCInit ..... 247  
Table 464. TIM_OCMode 定义 ..... 248  
Table 465. TIM_Channel 值 ..... 248  
Table 466. TIM_OCPolarity 值 ..... 248  
Table 467. 函数 TIM_ICInit. 249  
Table 468. TIM_ICMode 定义 ..... 249  
Table 469. TIM_Channel 值 ..... 249  
Table 470. TIM_Channel 值 ..... 250  
Table 471. TIM_ICSelection 值 ..... 250  
Table 472. TIM_ICPrescaler 值 ..... 250  
Table 473. 函数TIM_TimeBaseStructInit ..... 251  
Table 474. TIM_TimeBaseInitStruct 缺省值 ..... 251  
Table 475. 函数 TIM_TimeBaseStructInit ..... 251

Table 476. TIM_OCInitStruct 缺省值 ..... 251  
Table 477. 函数 TIM_ICStructInit ..... 252  
Table 478. TIM_ICInitStruct 缺省值 ..... 252  
Table 479. 函数 TIM_Cmd ..... 252  
Table 480. 函数 TIM_ITConfig ..... 253  
Table 481. TIM_IT 值 ..... 253  
Table 482. 函数 TIM_DMAConfig ..... 253  
Table 483. TIM_DMABase 值 ..... 254  
Table 484. TIM_DMABurstLength 值 ..... 254  
Table 485. 函数 TIM_DMAcmd ..... 255  
Table 486. TIM_DMASource 值 ..... 255  
Table 487. 函数 TIM/InternalClockConfig ..... 255  
Table 488. 函数 TIM_ITRxExternalClockConfig ..... 256  
Table 489. TIM_InputTriggerSource 值 ..... 256  
Table 490. 函数 TIM_TIxExternalClockConfig ..... 256  
Table 491. TIM_TIxExternalCLKSource 值 ..... 257  
Table 492. 函数 TIM_ETRClockModelConfig ..... 257  
Table 493. TIM_ExtTRGPrescaler 值 ..... 257  
Table 494. TIM_ExtTRGPolarity 值 ..... 257  
Table 495. 函数 TIM_ETRClockMode2Config ..... 258  
Table 496. 函数 TIM_ETRConfig. 258  
Table 497. 函数 TIM_SelectInputTrigger ..... 259  
Table 498. TIM_InputTriggerSource 值 ..... 259  
Table 499. 函数 TIM_PrescalerConfig ..... 260  
Table 500. TIM_PSCReloadMode 值 ..... 260  
Table 501. 函数 TIM CounterModeConfig ..... 260  
Table 502. 函数 TIM_ForcedOC1Config. 261  
Table 503. TIM_ForcedAction 值 ..... 261  
Table 504. 函数 TIM_ForcedOC2Config. 261  
Table 505. 函数 TIM_ForcedOC3Config. 262  
Table 506. 函数 TIM_ForcedOC4Config. 262  
Table 507. 函数 TIMARRPreloadConfig ..... 263  
Table 508. 函数 TIM_SelectCCDMA ..... 263  
Table 509. 函数 TIM_OC1PreloadConfig ..... 264  
Table 510. TIM_OCPreload 值 ..... 264  
Table 511. 函数 TIM_OC2PreloadConfig ..... 264  
Table 512. 函数 TIM_OC3PreloadConfig ..... 265  
Table 513. 函数 TIM_OC4PreloadConfig ..... 265  
Table 514. 函数 TIM_OC1FastConfig ..... 266  
Table 515. TIM_OCPreload 值 ..... 266  
Table 516. 函数 TIM_OC2FastConfig ..... 266  
Table 517. 函数 TIM_OC3FastConfig ..... 267  
Table 518. 函数 TIM_OC4FastConfig ..... 267  
Table 519. 函数 TIM_ClearOC1Ref ..... 268  
Table 520. TIM_OCClear 值 ..... 268  
Table 521. 函数 TIM_ClearOC2Ref ..... 268  
Table 522. 函数 TIM_ClearOC3Ref ..... 269  
Table 523. 函数 TIM_ClearOC4Ref ..... 269  
Table 524. 函数 TIM_UpdateDisableConfig ..... 270  
Table 525. 函数 TIM EncoderInterfaceConfig ..... 270  
Table 526. TIM EncoderMode 值 ..... 270  
Table 527. 函数 TIM_GenerateEvent ..... 271  
Table 528. TIM_EventSource 值 ..... 271

Table 529. 函数 TIM_OC1PolarityConfig ..... 271  
Table 530. 函数 TIM_OC2PolarityConfig ..... 272  
Table 531. 函数 TIM_OC1PolarityConfig ..... 272  
Table 532. 函数 TIM_OC4PolarityConfig ..... 273  
Table 533. 函数 TIM_UpdateRequestConfig ..... 273  
Table 534. TIM_UpdateSource 值 ..... 273  
Table 535. 函数 TIM_SelectHallSensor ..... 274  
Table 536. 函数 TIM_SelectOnePulseMode ..... 274  
Table 537. TIM_OPMode 值 ..... 274  
Table 538. 函数 TIM_SelectOutputTrigger. 275  
Table 539. TIM_TRGOSource 值 ..... 275  
Table 540. 函数 TIM_SelectSlaveMode ..... 276  
Table 541. TIM_SlaveMode 值 ..... 276  
Table 542. 函数 TIM_SelectMasterSlaveMode ..... 277  
Table 543. TIM_MasterSlaveMode 值 ..... 277  
Table 544. 函数 TIM_SetCounter ..... 277  
Table 545. 函数 TIM_SetAutoreload ..... 278  
Table 546. 函数 TIM_SetCompare1 278  
Table 547. 函数 TIM_SetCompare2 ..... 279  
Table 548. 函数 TIM_SetCompare3 279  
Table 549. 函数 TIM_SetCompare4 ..... 280  
Table 550. 函数 TIM_SetIC1Prescaler 280  
Table 551. 函数 TIM_SetIC2Prescaler ..... 281  
Table 552. 函数 TIM_SetIC3Prescaler ..... 281  
Table 553. 函数 TIM_SetIC4Prescaler ..... 282  
Table 554. 函数 TIM_SetClockDivision ..... 282  
Table 555. 函数 TIM_GetCapture1 ..... 283  
Table 556. 函数 TIM_GetCapture2 ..... 283  
Table 557. 函数 TIM_GetCapture3 ..... 283  
Table 558. 函数 TIM_GetCapture4 ..... 284  
Table 559. 函数 TIM_GetCounter. 284  
Table 560. 函数 TIM_GetPrescaler ..... 285  
Table 561. 函数 TIM_GetFlagStatus ..... 285  
Table 562. TIM_FLAG 值 ..... 285  
Table 563. 函数 TIM_ClearFlag ..... 286  
Table 564. 函数 TIM_GetITStatus ..... 286  
Table 565. 函数 TIM_ClearITPendingBit ..... 287  
Table 566. TIM1 寄存器 ..... 289  
Table 567. TIM1 库函数 ..... 290  
Table 568. 函数 TIM1_DeInit ..... 292  
Table 569. 函数TIM1(TIM1BaseInit. 292  
Table 570. TIM1_ClockDivision 值 ..... 293  
Table 571. TIM1_Mode 值 ..... 293  
Table 572. 函数 TIM1_OC1Init ..... 294  
Table 573. TIM1_OCMode 定义 ..... 294  
Table 574. TIM1_OutputState 值 ..... 294  
Table 575. TIM1_OutputNState 值 ..... 295  
Table 576. TIM1_OCPolarity 值 ..... 295  
Table 577. TIM1_OCNPolarity 值 ..... 295  
Table 578. TIM1_OCIdleState 值 ..... 295  
Table 579. TIM1_OCIdleState 值 ..... 295  
Table 580. 函数 TIM1_OC2Init ..... 296  
Table 581. 函数 TIM1_OC3Init ..... 296

Table 582. 函数 TIM1_OC4Init ..... 297  
Table 583. 函数 TIM1_BDTRConfig ..... 297  
Table 584. TIM1_OSSRState 值 ..... 298  
Table 585. TIM1_OSSIState 值 ..... 298  
Table 586. TIM1_LOCKLevel 值 ..... 298  
Table 587. TIM1_OSSIState 值 ..... 298  
Table 588. TIM1_BreakPolarity 值 ..... 298  
Table 589. TIM1_AutomaticOutput 值 ..... 298  
Table 590. 函数TIM1_ICInit. 299  
Table 591. TIM1_Channel 值 ..... 299  
Table 592. TIM1_Channel 值 ..... 299  
Table 593. TIM1_ICSelection 值 ..... 300  
Table 594. TIM1_ICPrescaler 值 300  
Table 595. 函数 TIM1_PWMConfig ..... 300  
Table 596. 函数 TIM1_TimeBaseStructInit 301  
Table 597. TIM1_TimeBaseInitStruct 缺省值 ..... 301  
Table 598. 函数 TIM1_TimeBaseStructInit 301  
Table 599. TIM1_OCInitStruct 缺省值 302  
Table 600. 函数 TIM1_ICStructInit 302  
Table 601. TIM1_ICInitStruct 缺省值 ..... 302  
Table 602. 函数 TIM1_BDTRStructInit. 303  
Table 603. TIM1_TimeBaseInitStruct 缺省值 ..... 303  
Table 604. 函数 TIM1_Cmd 303  
Table 605. 函数 TIM1_CtrlPWMOutputs 304  
Table 606. 函数 TIM1_ITConfig ..... 304  
Table 607. TIM1_IT 值 ..... 304  
Table 608. 函数 TIM1_DMAConfig ..... 305  
Table 609. TIM1_DMABase 值 ..... 305  
Table 610. TIM1_DMABurstLength 值 ..... 305  
Table 611. 函数 TIM1_DMAcmd 306  
Table 612. TIM1_DMASource 值 306  
Table 613. 函数 TIM1/InternalClockConfig ..... 307  
Table 614. 函数 TIM1_ETRClockMode1Config ..... 307  
Table 615. TIM1_ExtTRGPrescaler 值 307  
Table 616. TIM1_ExtTRGPolarity 值 ..... 308  
Table 617. 函数 TIM1_ETRClockMode2Config ..... 308  
Table 618. 函数 TIM1_ETRConfig. 309  
Table 619. 函数 TIM1_ITRxExternalClockConfig 309  
Table 620. TIM1_InputTriggerSource 值 ..... 309  
Table 621. 函数 TIM1_TIxExternalClockConfig 310  
Table 622. TIM1_TIxExternalCLKSource 值 310  
Table 623. 函数 TIM1_SelectionTrigger 310  
Table 624. TIM1_InputTriggerSource 值 ..... 311  
Table 625. 函数 TIM1_UpdateDisableConfig ..... 311  
Table 626. 函数 TIM1_UpdateRequestConfig. 311  
Table 627. TIM1_UpdateSource 值 ..... 312  
Table 628. 函数 TIM1_SelectHallSensor 312  
Table 629. 函数 TIM1_SelectOnePulseMode 312  
Table 630. TIM1_OPMode 值 ..... 312  
Table 631. 函数 TIM1_SelectOutputTrigger 313  
Table 632. TIM1_TRGOSource 值 ..... 313  
Table 633. 函数 TIM1_SelectSlaveMode 313  
Table 634. TIM1_SlaveMode 值 ..... 314

Table 635. 函数 TIM1_SelectMasterSlaveMode 314  
Table 636. TIM1_MasterSlaveMode 值 ..... 314  
Table 637. 函数 TIM1 EncoderInterfaceConfig ..... 315  
Table 638. TIM1 EncoderMode 值 ..... 315  
Table 639. 函数 TIM1_PrescalerConfig 315  
Table 640. TIM1_PSCReloadMode 值 ..... 316  
Table 641. 函数 TIM1_ModeConfig ..... 316  
Table 642. 函数 TIM1_FocusedOC1Config. 316  
Table 643. TIM1_ForcedAction 值 ..... 316  
Table 644. 函数 TIM1_FocusedOC2Config. 317  
Table 645. 函数 TIM1_FocusedOC3Config. 317  
Table 646. 函数 TIM1_FocusedOC4Config. 318  
Table 647. 函数 TIM1_ARRPreloadConfig ..... 318  
Table 648. 函数 TIM1_SelectionCOM ..... 319  
Table 649. 函数 TIM1_SelectCCDMA 319  
Table 650. 函数 TIM1_CCPreloadControl. 320  
Table 651. 函数 TIM1_OC1PreloadConfig ..... 320  
Table 652. TIM1_OCPreload 值 ..... 320  
Table 653. 函数 TIM1_OC2PreloadConfig ..... 321  
Table 654. 函数 TIM1_OC3PreloadConfig ..... 321  
Table 655. 函数 TIM1_OC4PreloadConfig ..... 322  
Table 656. 函数 TIM1_OC1FastConfig ..... 322  
Table 657. TIM1_OCPreload 值 ..... 322  
Table 658. 函数 TIM1_OC2FastConfig ..... 323  
Table 659. 函数 TIM1_OC3FastConfig ..... 323  
Table 660. 函数 TIM1_OC4FastConfig 324  
Table 661. 函数 TIM1_ClearOC1Ref ..... 324  
Table 662. TIM1_OCClear 值 ..... 324  
Table 663. 函数 TIM1_ClearOC2Ref ..... 325  
Table 664. 函数 TIM1_ClearOC3Ref ..... 325  
Table 665. 函数 TIM1_ClearOC4Ref ..... 326  
Table 666. 函数 TIM1_GenerateEvent 326  
Table 667. TIM1_EventSource 值 ..... 326  
Table 668. 函数 TIM1_OC1PolarityConfig ..... 327  
Table 699. TIM1_OCPolarity 值 ..... 327  
Table 670. 函数TIM1_OC1NPolarityConfig ..... 327  
Table 671. 函数 TIM1_OC2PolarityConfig ..... 328  
Table 672. 函数 TIM1_OC2NPolarityConfig ..... 328  
Table 673. 函数 TIM1_OC3PolarityConfig ..... 329  
Table 674. 函数 TIM1_OC3NPolarityConfig ..... 329  
Table 675. 函数 TIM1_OC4PolarityConfig 330  
Table 676. 函数 TIM1_CCxCmd 330  
Table 677. 函数 TIM1_CCxCNcmd 331  
Table 678. 函数 TIM1_SelectOCxM 331  
Table 679. TIM1_OCMode 定义 ..... 331  
Table 680. 函数 TIM1_SetCounter 332  
Table 681. 函数 TIM1_SetAutoreload ..... 332  
Table 682. 函数 TIM1_SetCompare1 333  
Table 683. 函数 TIM1_SetCompare2 333  
Table 684. 函数 TIM1_SetCompare3 334  
Table 685. 函数 TIM1_SetCompare4 334  
Table 686. 函数 TIM1_SetIC1Prescaler 335  
Table 687. TIM1_ICPrescaler 值 ..... 335

Table 688. 函数TIM1_SetIC2Prescaler 335  
Table 689. 函数TIM1_SetIC3Prescaler 336  
Table 690. 函数 TIM1_SetIC4Prescaler 336  
Table 691. 函数 TIM1_SetClockDivision 337  
Table 692. TIM1_CKD 值 337  
Table 693. 函数 TIM1_GetCapture1 337  
Table 694. 函数 TIM1_GetCapture2 338  
Table 695. 函数 TIM1_GetCapture3 338  
Table 696. 函数 TIM1_GetCapture4 338  
Table 697. 函数 TIM1_GetCounter. 339  
Table 698. 函数 TIM1_GetPrescaler 339  
Table 699. 函数 TIM1_GetFlagStatus 340  
Table 700. TIM1_FLAG 值 ..... 340  
Table 701. 函数 TIM1_ClearFlag ..... 341  
Table 702. 函数 TIM1_GetITStatus 341  
Table 703. 函数 TIM1_ClearITPendingBit 342  
Table 704.USART 寄存器 343  
Table 705.USART库函数 344  
Table 706. 函数USART_DeInit 345  
Table 707. 函数USART_Init 346  
Table 708.USART_InitTypeDef 成员USART 模式对比 ..... 346  
Table 709.USART WORDLength 定义 347  
Table 710.USART_StopBits 定义 ..... 347  
Table 711.USART_Parity 定义 347  
Table 712.USART_HardwareFlowControl 定义 347  
Table 713.USART_Mode 定义 ..... 347  
Table 714.USART_CLOCK定义 347  
Table 715.USART_CPOL 定义 348  
Table 716.USART_CPHA定义 348  
Table 717.USART_LastBit定义 348  
Table 718. 函数USARTSTRUCTInit.. 349  
Table 719.USART_InitStruct 缺省值 349  
Table 720. 函数USART_Cmd. 349  
Table 721. 函数USART_ITConfig. 350  
Table 722.USART_IT值 350  
Table 723. 函数USART_DMAcmd 351  
Table 724.USART_LastBit值 351  
Table 725. 函数USART_SetAddress 351  
Table 726. 函数USART_WakeUpConfig 352  
Table 727.USART_WakeUp值 352  
Table 728. 函数USART_ReceiverWakeUpCmd 352  
Table 729. 函数USART_LINBreakDetectiLengthConfig 353  
Table 730.USART_LINBreakDetectLength值. 353  
Table 731. 函数USART_LINCmd 353  
Table 732. 函数USART_SendData 354  
Table 733. 函数USART_ReceiveData 354  
Table 734. 函数USART_SendBreak 355  
Table 735. 函数USART_SetGuardTime 355  
Table 736. 函数USART_SetPrescaler 356  
Table 737. 函数USART_SmartCardCmd. 356  
Table 738. 函数USART_SmartCardNackCmd 357  
Table 739. 函数USART_HalfDuplexCmd 357  
Table 740. 函数USART_IrDACConfig 358

Table 741.USART_IrDAMode 值 ..... 358  
Table 742. 函数USART_IrDACmd 358  
Table 743. 函数USART_GetFlagStatus 359  
Table 744.USART_FLAG值 359  
Table 745. 函数USART_ClearFlag 360  
Table 746. 函数USART_GetITStatus 360  
Table 747.USART_IT值 360  
Table 748. 函数USART_ClearITPendingBit 361  
Table 749. WWDG 寄存器 362  
Table 750. WWDG 库函数 ..... 363  
Table 751. 函数 WWDG_DeInit 363  
Table 752. 函数 WWDG_SetPrescaler 363  
Table 753. WWDG_Prescaler 值 ..... 364  
Table 754. 函数 WWDG_SetWindowValue 364  
Table 755. 函数 WWDG_EnableIT 364  
Table 756. 函数 WWDG_SetCounter 365  
Table 757. 函数 WWDG_Enable 365  
Table 758. 函数 WWDG_GetFlagStatus 366  
Table 759. 函数 WWDG_ClearFlag 366

# 1. 文档和库规范

本用户手册和固态函数库按照以下章节所描述的规范编写。

# 1.1 缩写

Table 1. 本文档所有缩写定义  

<table><tr><td>缩写</td><td>外设/单元</td></tr><tr><td>ADC</td><td>模数转换器</td></tr><tr><td>BKP</td><td>备份寄存器</td></tr><tr><td>CAN</td><td>控制器局域网模块</td></tr><tr><td>DMA</td><td>直接内存存取控制器</td></tr><tr><td>EXTI</td><td>外部中断事件控制器</td></tr><tr><td>FLASH</td><td>闪存存储器</td></tr><tr><td>GPIO</td><td>通用输入输出</td></tr><tr><td>I2C</td><td>内部集成电路</td></tr><tr><td>IWDG</td><td>独立看门狗</td></tr><tr><td>NVIC</td><td>嵌套中断向量列表控制器</td></tr><tr><td>PWR</td><td>电源/功耗控制</td></tr><tr><td>RCC</td><td>复位与时钟控制器</td></tr><tr><td>RTC</td><td>实时时钟</td></tr><tr><td>SPI</td><td>串行外设接口</td></tr><tr><td>SysTick</td><td>系统嘀嗒定时器</td></tr><tr><td>TIM</td><td>通用定时器</td></tr><tr><td>TIM1</td><td>高级控制定时器</td></tr><tr><td>USART</td><td>通用同步异步接收发射端</td></tr><tr><td>WWDG</td><td>窗口看门狗</td></tr></table>

# 1.2 命名规则

固态函数库遵从以下命名规则

PPP表示任一外设缩写，例如：ADC。更多缩写相关信息参阅章节1.1缩写

系统、源程序文件和头文件命名都以“stm32f10x_”作为开头，例如：stm32f10x_conf.h。

常量仅被应用于一个文件的，定义于该文件中；被应用于多个文件的，在对应头文件中定义。所有常量都由英文字母大写书写。

寄存器作为常量处理。他们的命名都由英文字母大写书写。在大多数情况下，他们采用与缩写规范与本用户手册一致。

外设函数的命名以该外设的缩写加下划线为开头。每个单词的第一个字母都由英文字母大写书写，例如：SPI_SendlData。在函数名中，只允许存在一个下划线，用以分隔外设缩写和函数名的其它部分。

名为PPP_Init的函数，其功能是根据PPP_InitTypeDef中指定的参数，初始化外设PPP，例如TIM_Init.

名为 PPP_DelInit 的函数，其功能为复位外设 PPP 的所有寄存器至缺省值，例如 TIM_DelInit.

名为PPPSTRUCTInit的函数，其功能为通过设置PPP_InitTypeDef结构中的各种参数来定义外设的功能，例如：USARTSTRUCTInit

名为PPP_Cmd的函数，其功能为使能或者失能外设PPP，例如：SPI_Cmd.

名为 PPP_ITConfig 的函数，其功能为使能或者失能来自外设 PPP 某中断源，例如：RCC_ITConfig.

名为PPP_DMAConfig的函数，其功能为使能或者失能外设PPP的DMA接口，例如：TIM1_DMAConfig.

用以配置外设功能的函数，总是以字符串“Config”结尾，例如 GPIO_PinRemapConfig.

名为PPP_GetFlagStatus的函数，其功能为检查外设PPP某标志位被设置与否，例如：I2C_GetFlagStatus.

名为 PPP_ClearFlag 的函数，其功能为清除外设 PPP 标志位，例如：12C_ClearFlag。

名为PPP_GetITStatus的函数，其功能为判断来自外设PPP的中断发生与否，例如：I2C_GetITStatus.

名为 PPP_ClearITPendingBit 的函数，其功能为清除外设 PPP 中断待处理标志位，例如：I2C_ClearITPendingBit.

# 1.3 编码规则

本章节描述了固态函书库的编码规则。

# 1.3.1 变量

固态函数库定义了24个变量类型，他们的类型和大小是固定的。在文件stm32f10x_type.h中我们定义了这些变量：

```c
typedef signed long s32;  
typedef signed short s16;  
typedef signed char s8;  
typedef signed long const sc32; /* Read Only */  
typedef signed short const sc16; /* Read Only */  
typedef signed char const sc8; /* Read Only */  
typedef volatile signed long vs32;  
typedef volatile signed short vs16;  
typedef volatile signed char vs8;  
typedef volatile signed long const vsc32; /* Read Only */  
typedef volatile signed short const vsc16; /* Read Only */  
typedef volatile signed char const vsc8; /* Read Only */  
typedef unsigned long u32;  
typedef unsigned short u16;  
typedef unsigned char u8;  
typedef unsigned long const uc32; /* Read Only */  
typedef unsigned short const uc16; /* Read Only */  
typedef unsigned char const uc8; /* Read Only */  
typedef volatile unsigned long vu32;  
typedef volatile unsigned short vu16;  
typedef volatile unsigned char vu8;  
typedef volatile unsigned long const vuc32; /* Read Only */  
typedef volatile unsigned short const vuc16; /* Read Only */  
typedef volatile unsigned char const vuc8; /* Read Only */
```

# 1.3.2布尔型

在文件stm32f10x_type.h中，布尔形变量被定义如下：

```txt
typedef enum {
```

```txt
FALSE  $= 0$  TRUE  $= !\mathrm{FALSE}$  } bool;
```

# 1.3.3 标志位状态类型

在文件 stm32f10x_type.h 中，我们定义标志位类型（FlagStatus type）的 2 个可能值为“设置”与“重置”（SET or RESET）。typedef enum { RESET = 0, SET = !RESET } FlagStatus;

# 1.3.4 功能状态类型

在文件 stm32f10x_type.h 中，我们定义功能状态类型（FunctionalState type）的 2 个可能值为“使能”与“失能”（ENABLE or DISABLE）。

```txt
typedef enum  
{  
DISABLE  $= 0$   
ENABLE  $= !DISABLE$   
} FunctionalState;
```

# 1.3.5 错误状态类型

在文件 stm32f10x_type.h 中，我们错误状态类型类型（ErrorStatus type）的 2 个可能值为“成功”与“出错”（SUCCEED or ERROR）。

```c
typedef enum  
{  
ERROR = 0,  
SUCCEED = !ERROR  
} ErrorStatus;
```

# 1.3.6 外设

用户可以通过指向各个外设的指针访问各外设的控制寄存器。这些指针所指向的数据结构与各个外设的控制寄存器布局一一对应。

# 外设控制寄存器结构

文件stm32f10x_map.h包含了所有外设控制寄存器的结构，下例为SPI寄存器结构的声明：

```txt
/* -- Serial Peripheral Interface --*/ typedef struct { vu16 CR1; u16 RESERVED0; vu16 CR2; u16 RESERVED1; vu16 SR; u16 RESERVED2; vu16 DR; u16 RESERVED3; vu16 CRCPR; u16 RESERVED4; vu16 RXCRCR; u16 RESERVED5; vu16 TXCRCR; u16 RESERVED6; } SPI_TYPEDef;
```

寄存器命名遵循上节的寄存器缩写命名规则。RESERVEDi（i为一个整数索引值）表示被保留区域。

# 外设声明

文件stm32f10x_map.h包含了所有外设的声明，下例为SPI外设的声明：

```c
ifndef EXT
	Define EXT extern
	endif
...
	#define PERIPH_BASE ((u32) 0x40000000)
	#define APB1PERIPH_BASE PERIPH_BASE
	#define APB2PERIPH_BASE (PERIPH_BASE + 0x10000)
...
/* SPI2 Base Address definition*/
	#define SPI2_BASE (APB1PERIPH_BASE + 0x3800)
...
/* SPI2 peripheral declaration*/
	#idfdef DEBUG
...
	#idfdef_SPI2
	#define SPI2 ((SPI_TYPEDef *) SPI2_BASE)
	#endif /*_SPI2 */
...
#else /* DEBUG */
...
	#idfdef_SPI2
	EXT_SPI_TYPEDef *SPI2;
	#endif /*_SPI2 */
...
	#endif /* DEBUG */
```

如果用户希望使用外设 SPI，那么必须在文件 stm32f10x_conf.h 中定义_SPI 标签

通过定义标签_SPIn，用户可以访问外设SPIn的寄存器。例如，用户必须在文件stm32f10x_conf.h中定义标签_SPI2，否则是不能访问SPI2的寄存器的。在文件stm32f10x_conf.h中，用户可以按照下例定义标签

```txt
SPI和SPIn #define SPI #define SPI1 #define SPI2
```

每个外设都有若干寄存器专门分配给标志位。我们按照相应的结构定义这些寄存器。标志位的命名，同样遵循上节的外设缩写规范，以‘PPP_FLAG_’开始。对于不同的外设，标志位都被定义在相应的文件stm32f10x_ppp.h中。

用户想要进入除错（DEBUG）模式的话，必须在文件 stm32f10x_conf.h 中定义标签 DEBUG。

这样会在SRAM的外设结构部分创建一个指针。因此我们可以简化除错过程，并且通过转储外设获得来获得所有寄存器的状态。在所有情况下，SPI2都是一个指向外设SPI2首地址的指针。

变量 DEBUG 可以仿照下例定义:

define DEBUG 1

可以初始化 DEBUG 模式与文件 stm32f10x_lib.c 中如下：

```c
#ifndef DEBUG
void debug(void)
{
...
#include <SPI2>
SPI2 = (SPI_TYPEDef *) SPI2_BASE;
#endif /*_SPI2*/
}
#endif /* DEBUG*/
```

Note: 1 当用户选择 DEBUG 模式, 宏 assert-param 被扩展, 同时运行时间检查功能也在固态函数库代码中被激活。

2 进入 DEBUG 模式会增大代码的尺寸，降低代码的运行效率。因此，我们强烈建议仅仅在除错的时候使用相应代码，在最终的应用程序中，删除它们。

# 2. 固件函数库

# 2.1 压缩包描述

STM32F10x固件函数库被压缩在一个zip文件中。解压该文件会产生一个文件夹：STM32F10xFWLib\FWLib，包含如下所示的子文件夹：

![](https://cdn-mineru.openxlab.org.cn/result/2025-12-29/fccb1e45-8eb9-450c-9cc7-887daf1cc365/862a65f818fd7f40342d96a150b3451a0da3838f4b612b6fc0e51004c23b36bb.jpg)  
Figure 1: 固件函数库文件夹结构

# 2.1.1 文件夹Examples

文件夹 Examples，对应每一个 STM32 外设，都包含一个子文件夹。这些子文件夹包含了整套文件，组成典型的例子，来示范如何使用对应外设。这些文件有：

readme.txt: 每个例子的简单描述和使用说明。

stm32f10x_conf.h: 该头文件设置了所有使用到的外设, 由不同的“DEFINE”语句组成。

stm32f10x_it.c：该源文件包含了所有的中断处理程序（如果未使用中断，则所有的函数体都为空）。

stm32f10x.it.h：该头文件包含了所有的中断处理程序的原形。

main.c: 例程代码

注：所有的例程的使用，都不受不同软件开发环境的影响。

# 2.1.2 文件夹Library

文件夹Library包含组成固件函数库核心的所有子文件夹和文件：

■子文件夹 inc 包含了固件函数库所需的头文件，用户无需修改该文件夹：

ST

译文英文原版为UM0427 Oct. 2007 Rev 2，译文仅供参考，与英文版冲突的，以英文版为准

- stm32f10x_type.h：所有其他文件使用的通用数据类型和枚举。  
- stm32f10x_map.h：外设存储器映像和寄存器数据结构。  
- stm32f10x_lib.h：主头文件夹，包含了其他头文件。  
- stm32f10x_ppp.h：每个外设对应一个头文件，包含了该外设使用的函数原形，数据结构和枚举。  
-cortexm3_macro.h：文件cortexm3_macro.s对应的头文件。

■子文件夹src包含了固件函数库所需的源文件，用户无需修改该文件夹：

- stm32f10x_ppp.c: 每个外设对应一个源文件, 包含了该外设使用的函数体  
- stm32f10x_lib.c：初始化所有外设的指针

注：所有代码都按照Strict ANSI-C标准书写，都不受不同软件开发环境的影响。

# 2.1.3 文件夹Project

文件夹 Project 包含了一个标准的程序项目模板，包括库文件的编译和所有用户可修改的文件，可用以建立新的工程。

- stm32f10x_conf.h：项目配置头文件，默认为设置了所有的外设。  
- stm32f10x_it.c：该源文件包含了所有的中断处理程序（所有的函数体默认为空）。

stm32f10x_it.h：该头文件包含了所有的中断处理程序的原形。

main.c: 主函数体

文件夹EWARM，RVMDK，RIDE：用于不同开发环境使用，详情查询各文件夹下的文件README.txt。

# 2.2 固件函数库文件描述

Table 2 列举和描述了固件函数库使用的所有文件。

固件函数库的体系和文件相互包括的联系表示在 Figure 2 中。每一个外设都有一个对应的源文件：stm32f10x_ppp.c 和一个对应的头文件：stm32f10x_ppp.h。

文件 stm32f10x_ppp.c 包含了使用外设 PPP 所需的所有固件函数。提供所有外设一个存储器映像文件 stm32f10x_map.h。它包含了所有寄存器的声明，既可以用于 Debug 模式也可以用于 release 模式。

头文件 stm32f10x_lib.h 包含了所有外设头文件的头文件。它是唯一一个用户需要包括在自己应用中的文件，起到应用和库之间界面的作用。

文件 stm32f10x_conf.h 是唯一一个需要由用户修改的文件。它作为应用和库之间的界面，指定了一系列参数。

Table 2. 固件函数库文件描述  

<table><tr><td>文件名</td><td>描述</td></tr><tr><td>stm32f10x_conf.h</td><td>参数设置文件，起到应用和库之间界面的作用。用户必须在运行自己的程序前修改该文件。用户可以利用模板使能或者失能外设。也可以修改外部晶振的参数。也可以是用该文件在编译前使能 Debug 或者 release 模式。</td></tr><tr><td>main.c</td><td>主函数体示例。</td></tr><tr><td>stm32f10x_it.h</td><td>头文件，包含所有中断处理函数原形。</td></tr><tr><td>stm32f10x_it.c</td><td>外设中断函数文件。用户可以加入自己的中断程序代码。对于指向同一个中断向量的多个不同中断请求，可以利用函数通过判断外设的中断标志位来确定准确的中断源。固件函数库提供了这些函数的名称。</td></tr><tr><td>stm32f10x_lib.h</td><td>包含了所有外设的头文件的头文件。它是唯一一个用户需要包括在自己应用中的文件，起到应用和库之间界面的作用。</td></tr><tr><td>stm32f10x_lib.c</td><td>Debug模式初始化文件。</td></tr></table>

固件函数库  

<table><tr><td></td><td>它包括多个指针的定义,每个指针指向特定外设的首地址,以及在Debug模式被使
能时,被调用的函数的定义。</td></tr><tr><td>stm32f10x_map.h</td><td>该文件包含了存储器映像和所有寄存器物理地址的声明,既可以用于Debug模式也
可以用于release模式。所有外设都使用该文件。</td></tr><tr><td>stm32f10x_type.h</td><td>通用声明文件。
包含所有外设驱动使用的通用类型和常数。</td></tr><tr><td>stm32f10x_ppp.c</td><td>由C语言编写的外设PPP的驱动源程序文件。</td></tr><tr><td>stm32f10x_ppp.h</td><td>外设PPP的头文件。包含外设PPP函数的定义,和这些函数使用的变量。</td></tr><tr><td>cortexm3_macro.h</td><td>文件cortexm3_macro.s的头文件</td></tr><tr><td>cortexm3_macro.s</td><td>Cortex-M3内核特殊指令的指令包装。</td></tr></table>

![](https://cdn-mineru.openxlab.org.cn/result/2025-12-29/fccb1e45-8eb9-450c-9cc7-887daf1cc365/8d2c1414d7cc2c1a639ee2e4f1a5c807beea5285cc18f07bfea56d3b9ebc91af.jpg)  
Figure 2. 固件函数库文件体系结构

# 2.3 外设的初始化和设置

本节按步骤描述了如何初始化和设置任意外设。这里 PPP 代表任意外设。

1. 在主应用文件中，声明一个结构 PPP_InitTypeDef，例如：

PPP_InitTypeDef PPP_InitStructure;

这里 PPP_InitStructure 是一个位于内存中的工作变量，用来初始化一个或者多个外设 PPP。

2. 为变量 PPP_InitStructure 的各个结构成员填入允许的值。可以采用以下 2 种方式：

a）按照如下程序设置整个结构体

PPP_InitStructure(member1 = val1;  
PPP_InitStructure(member2 = val2;  
PPP_InitStructure(memberN = valN;  
/* where N is the number of the structure members */

以上步骤可以合并在同一行里，用以优化代码大小：

PPP_InitTypeDef PPP_InitStructure = { val1, val2, ..., valN}

b）仅设置结构体中的部分成员：这种情况下，用户应当首先调用函数 PPP_SturcInit(..) 来初始化变量 PPP_InitStructure，然后再修改其中需要修改的成员。这样可以保证其他成员的值（多为缺省值）被正确填入。

PPPSTRUCTInit(&PPP_InitStructure); PP_InitStructure(memberX  $=$  valX; PPP_InitStructure(memberY  $=$  valY;

ST

译文英文原版为UM0427 Oct. 2007 Rev 2, 译文仅供参考，与英文版冲突的，以英文版为准

/*where X and Y are the members the user wants to configure*/

3. 调用函数 PPP_Init(.) 来初始化外设 PPP。  
4. 在这一步，外设 PPP 已被初始化。可以调用函数 PPP_Cmd(..) 来使能之。

PPP Cmd (PPP, ENABLE);

可以通过调用一系列函数来使用外设。每个外设都拥有各自的功能函数。更多细节参阅 Section3 外设固件概述。

注：1. 在设置一个外设前，必须调用以下一个函数来使能它的时钟：

```txt
RCC_AHBPeriphClockCmd(RCC_AHBPeriph_PPPx, ENABLE);  
RCC_APB2PeriphClockCmd(RCC_APB2Periph_PPPx, ENABLE);  
RCC_APB1PeriphClockCmd(RCC_APB1Periph_PPPx, ENABLE);
```

2. 可以调用函数 PPP_Deinit(..) 来把外设 PPP 的所有寄存器复位为缺省值：

```cmake
PPP_DeInit(PPP)
```

3. 在外设设置完成以后，继续修改它的一些参数，可以参照如下步骤：

```c
PPP_InitStucture(memberX = valX;  
PPP_InitStructure(memberY = valY; /* where X and Y are the only members that user wants to modify*/  
PPP_Init(PPP, &PPP_InitStructure);
```

# 2.4 位段（Bit-Banding）

Cortex™-M3 存储器映像包括两个位段(bit-band)区。这两个位段区将别名存储器区中的每个字映射到位段存储器区的一个位，在别名存储区写入一个字具有对位段区的目标位执行读-改-写操作的相同效果。

所有STM32F10x外设寄存器都被映射到一个位段(bit-band)区。这个特性在各个函数中对单个比特进行置1/置0操作时被大量使用，用以减小和优化代码尺寸。

Section 2.4.1 和 Section 2.4.2 给出了外设固件函数库中如何实现位段访问的描述。

# 2.4.1 映射公式

映射公式给出了别名区中的每个字是如何对应位带区的相应位的，公式如下：

```txt
bit_word_offset = (byte_offset x 32) + (bit_number  $\times 4$
```

```python
bit_word_addr = bit_band_base + bit_word_offset
```

其中：

bit_word_offset 是目标位在存取器位段区中的位置

bit_word_addr 是别名存储器区中字的地址，它映射到某个目标位。

bit-band_base 是别名区的起始地址。

byte_offset 是包含目标位的字节在位段里的序号

bit_number 是目标位所在位置（0-31）

# 2.4.2 应用实例

下例展现了如何把寄存器RCC_CR的PLLON[24]位，映射到别名区：

```lisp
/\* Peripheral base address in the bit-band region \*/   
#define PERIPH_BASE ((u32)0x40000000)   
/\* Peripheral address in the alias region \*/   
#define PERIPH_BB_BASE ((u32)0x42000000)   
/\* ---- RCC registers bit address in the alias region ---- \*/   
#define RCC_OFFSET (RCC_BASE - PERIPH_BASE)   
\*/ --- CRRegister --\*/   
\*/ Alias word address of PLLON bit \*/   
#define CR_OFFSET (RCC_OFFSET + 0x00)   
#define PLLON_BitNumber 0x18   
#define CR_PLLON_BB (PERIPH_BB_BASE + (CR_OFFSET \* 32 (PLLON_BitNumber\* 4))
```

编写一个使能/失能PLL的函数，步骤如下：

…

译文英文原版为UM0427 Oct. 2007 Rev 2，译文仅供参考，与英文版冲突的，以英文版为准

固件函数库  
```c
define CR_PLLON_Set ((u32)0x01000000)
#define CR_PLLONRESET((u32)0xFEFFFFFF)
...
void RCC_PLLCmd(FunctionalState NewState)
{
if (NewState != DISABLE)
{
/* Enable PLL */
RCC->CR |= CR_PLLON_Set;
}
else
{
/* Disable PLL */
RCC->CR &= CR_PLLON_Set;
}
Using bit-band access this function will be coded as follows:
void RCC_PLLCmd(FunctionalState NewState)
{
*(vu32*) CR_PLLON_BB = (u32)NewState;
}
```

# 2.5 运行时间检测

固件函数库通过检查库函书的输入来实现运行时间错误侦测。通过使用宏 assert-param 来实现运行时间检测。所有要求输入参数的函数都使用这个宏。它可以检查输入参数是否在允许的范围之内。

例：函数PWR_ClearFlag  
ifdef DEBUG  
ST  
```c
stm32f10x_pwr.c:
void PWR_ClearFlag(u32 PWR_FLAG)
{
/* Check the parameters */
assert(param(IS_PWR_CLEAR_FLAG(PWR_FLAG));
PWR->CR |= PWR_FLAG << 2;
}
stm32f10x_pwr.h:
/* PWR Flag */
#define PWR_FLAG_WU((u32)0x00000001)
#define PWR_FLAG_SB((u32)0x00000002)
#define PWR_FLAG_PVDO((u32)0x00000004)
#define IS_PWR_CLEAR_FLAG(FLAG)((FLAG == PWR_FLAG_WU) || (FLAG == PWR_FLAG_SB))
如果传给宏 assert param 的参数为 false，则调用函数 assertFailed 并返回被错误调用的函数所在的文件名和行数。如果传给宏 assert param 的参数为 true，则无返回值。
宏 assert param 编写于文件 stm32f10x_conf.h中：
/* Exported macro */
#ifndef DEBUG
/*********** */
* Macro Name : assertparam
* Description : The assertparam macro is used for function's parameters check.
* It is used only if the library is compiled in DEBUG mode.
* Input : - expr: If expr is false, it calls assert_FAILED function
* which reports the name of the source file and the source
* line number of the call that failed.
* If expr is true, it returns no value.
* Return : None
*********** */
#define assert param(expr) ((expr) ? (void)0 : assert_FAILED((u8*)_FILELine))
/* Exported functions */
void assert_failed(u8* file, u32 line);
#else
#define assert param(expr) ((void)0)
#include /* DEBUG */
```

函数 assert_failed 编写于文件 main.c 或者其他用户 C 文件：

译文英文原版为UM0427 Oct. 2007 Rev 2, 译文仅供参考，与英文版冲突的，以英文版为准

固件函数库  
```c
/\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*   
\* Function name: assert_failed   
\* Description: Reports the name of the source file and the source line number   
\* where the assert param error has occurred.   
\* Input: - file: pointer to the source file name   
\* - line: assert param error line source number   
\* Output : None   
\* Return : None   
\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\* /\*   
void assert Failed(u8\* file, u32 line)   
{ \*/\* User can add his own implementation to report the file name and line number, ex: printf("Wrong parameters value: file %s on line %d\r\n", file, line) /\*/ /\* Infinite loop \*/   
while (1) { 1 } 1   
#endif
```

注：

运行时间检查，即宏 assert-param 应当只在库在 Debug 模式下编译时使用。建议在用户应用代码的开发和调试阶段使用运行时间检查，在最终的代码中去掉它们以改进代码尺寸和速度。

如果用户仍然希望在最终的代码中保留这项功能，可以在调用库函数前，重新使用宏 assert-param 来测试输入参数。

# 3. 外设固件概述

本节系统描述了每一个外设固件函数库。完整地描述所有相关函数并提供如何使用他们的例子。

函数的描述按如下格式进行：

Table 3. 函数描述格式  

<table><tr><td>函数名</td><td>外设函数的名称</td></tr><tr><td>函数原形</td><td>原形声明</td></tr><tr><td>功能描述</td><td>简要解释函数是如何执行的</td></tr><tr><td>输入参数{x}</td><td>输入参数描述</td></tr><tr><td>输出参数{x}</td><td>输出参数描述</td></tr><tr><td>返回值</td><td>函数的返回值</td></tr><tr><td>先决条件</td><td>调用函数前应满足的要求</td></tr><tr><td>被调用函数</td><td>其他被该函数调用的库函数</td></tr></table>

# 4. 模拟/数字转换器

模拟/数字转换器（ADC）是一种提供可选择多通道输入，逐次逼近型的模数转换器。分辨率为12位。

Section 4.1 ADC 寄存器结构描述了固件函数库所使用的数据结构，Section 4.2 固件库函数介绍了函数库里的所有函数。

# 4.1 ADC寄存器结构

ADC 寄存器结构，ADC_TYPEDef，定义于文件“stm32f10x_map.h”如下：

```c
typedef struct  
{  
vu32 SR;  
vu32 CR1;  
vu32 CR2;  
vu32 SMPR1;  
vu32 SMPR2;  
vu32 JOFR1;  
vu32 JOFR2;  
vu32 JOFR3;  
vu32 JOFR4;  
vu32 HTR;  
vu32 LTR;  
vu32 SQR1;  
vu32 SQR2;  
vu32 SQR3;  
vu32 JSQR;  
vu32 JDR1;  
vu32 JDR2;  
vu32 JDR3;  
vu32 JDR4;  
vu32 DR;  
} ADC_TYPEDef;
```

Table 4 给出了 ADC 寄存器列表:  
Table 4. ADC 寄存器  

<table><tr><td>寄存器</td><td>描述</td></tr><tr><td>SR</td><td>ADC状态寄存器</td></tr><tr><td>CR1</td><td>ADC控制寄存器1</td></tr><tr><td>CR2</td><td>ADC控制寄存器2</td></tr><tr><td>SMPR1</td><td>ADC采样时间寄存器1</td></tr><tr><td>SMPR2</td><td>ADC采样时间寄存器2</td></tr><tr><td>JOFR1</td><td>ADC注入通道偏移寄存器1</td></tr><tr><td>JOFR2</td><td>ADC注入通道偏移寄存器2</td></tr><tr><td>JOFR3</td><td>ADC注入通道偏移寄存器3</td></tr><tr><td>JOFR4</td><td>ADC注入通道偏移寄存器4</td></tr><tr><td>HTR</td><td>ADC看门狗高阈值寄存器</td></tr><tr><td>LTR</td><td>ADC看门狗低阈值寄存器</td></tr><tr><td>SQR1</td><td>ADC规则序列寄存器1</td></tr><tr><td>SQR2</td><td>ADC规则序列寄存器2</td></tr><tr><td>SQR3</td><td>ADC规则序列寄存器3</td></tr><tr><td>JSQR1</td><td>ADC注入序列寄存器</td></tr><tr><td>DR1</td><td>ADC规则数据寄存器1</td></tr><tr><td>DR2</td><td>ADC 规则数据寄存器 2</td></tr><tr><td>DR3</td><td>ADC 规则数据寄存器 3</td></tr><tr><td>DR4</td><td>ADC 规则数据寄存器 4</td></tr></table>

2个ADC外设声明于文件“stm32f10x_map.h”：

ADC  
```c
define PERIPH_BASE((u32)0x40000000)
#define APB1PERIPH_BASE PERIPH_BASE
#define APB2PERIPH_BASE (PERIPH_BASE + 0x10000)
#define AHBPERIPH_BASE (PERIPH_BASE + 0x20000)
...
#define ADC1_BASE (APB2PERIPH_BASE + 0x2400)
#define ADC2_BASE (APB2PERIPH_BASE + 0x2800)
...
ifndef DEBUG
...
ifdef_ADC1
#define ADC1 ((ADC_TYPEDef *) ADC1_BASE)
endif /* ADC1 */
ifdef_ADC2
#define ADC2 ((ADC_TYPEDef *) ADC2_BASE)
endif /* ADC2 */
...
else /* DEBUG */
...
ifdef_ADC1
EXT_ADC_TYPEDef *ADC1;
endif /* ADC1 */
ifdef_ADC2
EXT_ADC_TYPEDef *ADC2;
endif /* ADC2 */
...
endif
```

当使用Debug模式时，初始化指针ADC1和ADC2与文件“stm32f10x_lib.c”：

```c
...   
#ifdef ADC1   
ADC1  $=$  (ADCTypeDef \*) ADC1_BASE; #endif /\*ADC1\*/   
#ifdef ADC2   
ADC2  $=$  (ADCTypeDef \*) ADC2_BASE; #endif /\*ADC2\*/
```

为了访问ADC寄存器，,ADC,_ADC1和ADC2必须在文件“stm32f10x_conf.h”中定义如下：

```txt
define ADC
#define ADC1
#define ADC2
```

# 4.2 ADC库函数

Table 5. 为 ADC 固件库函数列表  
Table 5. ADC 固件库函数  

<table><tr><td>函数名</td><td>描述</td></tr><tr><td>ADC_DeInit</td><td>将外设ADCx的全部寄存器重设为缺省值</td></tr><tr><td>ADC_Init</td><td>根据ADC_InitStruct中指定的参数初始化外设ADCx的寄存器</td></tr><tr><td>ADCSTRUCTInit</td><td>把ADC_InitStruct中的每一个参数按缺省值填入</td></tr><tr><td>ADC_Cmd</td><td>使能或者失能指定的ADC</td></tr><tr><td>ADC_DMAcmd</td><td>使能或者失能指定的ADC的DMA请求</td></tr><tr><td>ADC_ITConfig</td><td>使能或者失能指定的ADC的中断</td></tr></table>

```txt
ST
```

```txt
40/368
```

译文英文原版为UM0427 Oct. 2007 Rev 2, 译文仅供参考，与英文版冲突的，以英文版为准

ADC  

<table><tr><td>ADC_ResetCalibration</td><td>重置指定的 ADC 的校准寄存器</td></tr><tr><td>ADC_GetResetCalibrationStatus</td><td>获取 ADC 重置校准寄存器的状态</td></tr><tr><td>ADC_StartCalibration</td><td>开始指定 ADC 的校准程序</td></tr><tr><td>ADC_GetCalibrationStatus</td><td>获取指定 ADC 的校准状态</td></tr><tr><td>ADC_SoftwareStartConvCmd</td><td>使能或者失能指定的 ADC 的软件转换启动功能</td></tr><tr><td>ADC_GetSoftwareStartConvStatus</td><td>获取 ADC 软件转换启动状态</td></tr><tr><td>ADC_DiscModeChannelCountConfig</td><td>对 ADC 规则组通道配置间断模式</td></tr><tr><td>ADC_DiscModeCmd</td><td>使能或者失能指定的 ADC 规则组通道的间断模式</td></tr><tr><td>ADC_RegularChannelConfig</td><td>设置指定 ADC 的规则组通道, 设置它们的转化顺序和采样时间</td></tr><tr><td>ADC_ExternalTrigConvConfig</td><td>使能或者失能 ADCx 的经外部触发启动转换功能</td></tr><tr><td>ADC_GetConversionValue</td><td>返回最近一次 ADCx 规则组的转换结果</td></tr><tr><td>ADC_GetDuelModeConversionValue</td><td>返回最近一次双 ADC 模式下的转换结果</td></tr><tr><td>ADC_AutoInjectedConvCmd</td><td>使能或者失能指定 ADC 在规则组转化后自动开始注入组转换</td></tr><tr><td>ADC_InjectedDiscModeCmd</td><td>使能或者失能指定 ADC 的注入组间断模式</td></tr><tr><td>ADC_ExternalTrigInjectedConvConfig</td><td>配置 ADCx 的外部触发启动注入组转换功能</td></tr><tr><td>ADC_ExternalTrigInjectedConvCmd</td><td>使能或者失能 ADCx 的经外部触发启动注入组转换功能</td></tr><tr><td>ADC_SoftwareStartinjectedConvCmd</td><td>使能或者失能 ADCx 软件启动注入组转换功能</td></tr><tr><td>ADC_GetsoftwareStartinjectedConvStatus</td><td>获取指定 ADC 的软件启动注入组转换状态</td></tr><tr><td>ADC_InjectedChannleConfig</td><td>设置指定 ADC 的注入组通道, 设置它们的转化顺序和采样时间</td></tr><tr><td>ADC_InjectedSequencerLengthConfig</td><td>设置注入组通道的转换序列长度</td></tr><tr><td>ADC_SetinjectedOffset</td><td>设置注入组通道的转换偏移值</td></tr><tr><td>ADC_GetInjectedConversionValue</td><td>返回 ADC 指定注入通道的转换结果</td></tr><tr><td>ADC_AnalogWatchdogCmd</td><td>使能或者失能指定单个/全体, 规则/注入组通道上的模拟看门狗</td></tr><tr><td>ADC_AnalogWatchdongThresholdsConfig</td><td>设置模拟看门狗的高/低阈值</td></tr><tr><td>ADC_AnalogWatchdongSingleChannelConfig</td><td>对单个 ADC 通道设置模拟看门狗</td></tr><tr><td>ADC_TampSensorVrefintCmd</td><td>使能或者失能温度传感器和内部参考电压通道</td></tr><tr><td>ADC_GetFlagStatus</td><td>检查制定 ADC 标志位置 1 与否</td></tr><tr><td>ADC_ClearFlag</td><td>清除 ADCx 的待处理标志位</td></tr><tr><td>ADC_GetITStatus</td><td>检查指定的 ADC 中断是否发生</td></tr><tr><td>ADC_ClearITPendingBit</td><td>清除 ADCx 的中断待处理位</td></tr></table>

# 4.2.1 函数ADC_DeInit

Table 6. 描述了函数 ADC_DeInit  
Table 6.函数 ADC_DeInit  

<table><tr><td>函数名</td><td>ADC_DeInit</td></tr><tr><td>函数原形</td><td>void ADC_DeInit(ADCTypeDef* ADCx)</td></tr><tr><td>功能描述</td><td>将外设ADCx的全部寄存器重设为缺省值</td></tr><tr><td>输入参数1</td><td>ADCx: x可以是1或者2来选择ADC外设ADC1或ADC2</td></tr><tr><td>输出参数2</td><td>无</td></tr><tr><td>返回值</td><td>无</td></tr><tr><td>先决条件</td><td>无</td></tr><tr><td>被调用函数</td><td>RCC_APB2PeriphClockCmd()</td></tr></table>

例：

```javascript
/\* Resets ADC2 \*/ ADC_DeInit(ADC2);
```

# 4.2.2 函数ADC_Init

Table 7. 描述了函数 ADC_Init  
Table 7. 函数 ADC_Init  

<table><tr><td>函数名</td><td>ADC_Init</td></tr><tr><td>函数原形</td><td>void ADC_Init(ADC_TYPEDef* ADCx, ADC_InitTypeDef* ADC_InitStruct)</td></tr><tr><td>功能描述</td><td>根据 ADC_InitStruct 中指定的参数初始化外设 ADCx 的寄存器</td></tr><tr><td>输入参数 1</td><td>ADCx: x 可以是 1 或者 2 来选择 ADC 外设 ADC1 或 ADC2</td></tr><tr><td>输入参数 2</td><td>ADC_InitStruct: 指向结构 ADC_InitTypeDef 的指针, 包含了指定外设 ADC 的配置信息参阅: 4.2.3 ADCSTRUCTInit 获得 ADC_InitStruct 值的完整描述</td></tr><tr><td>输出参数</td><td>无</td></tr><tr><td>返回值</td><td>无</td></tr><tr><td>先决条件</td><td>无</td></tr><tr><td>被调用函数</td><td>无</td></tr></table>

# ADC_InitTypeDef structure

ADC_InitTypeDef 定义于文件“stm32f10x adc.h”：

```c
typedef struct   
{   
u32 ADC_Mode;   
FunctionalState ADC_ScanConvMode;   
FunctionalState ADC_ConsecutiveConvMode;   
u32 ADC_ExternalTrigConv;   
u32 ADC_DataAlign;   
u8 ADC_NbrOfChannel;   
} ADC_InitTypeDef
```

# ADC_Mode

ADC_Mode设置ADC工作在独立或者双ADC模式。参阅Table8.获得这个参数的所有成员。

Table 8. 函数 ADC_Mode 定义  

<table><tr><td>ADC_Mode</td><td>描述</td></tr><tr><td>ADC_Mode_Independent</td><td>ADC1和ADC2工作在独立模式</td></tr><tr><td>ADC_Mode_RegInjecSimult</td><td>ADC1和ADC2工作在同步规则和同步注入模式</td></tr><tr><td>ADC_Mode_RegSimult_AlterTrig</td><td>ADC1和ADC2工作在同步规则模式和交替触发模式</td></tr><tr><td>ADC_Mode_InjecSimult_FastInterl</td><td>ADC1和ADC2工作在同步规则模式和快速交替模式</td></tr><tr><td>ADC_Mode_InjecSimult_SlowInterl</td><td>ADC1和ADC2工作在同步注入模式和慢速交替模式</td></tr><tr><td>ADC_Mode_InjecSimult</td><td>ADC1和ADC2工作在同步注入模式</td></tr><tr><td>ADC_Mode_RegSimult</td><td>ADC1和ADC2工作在同步规则模式</td></tr><tr><td>ADC_Mode_FastInterl</td><td>ADC1和ADC2工作在快速交替模式</td></tr><tr><td>ADC_Mode_SlowInterl</td><td>ADC1和ADC2工作在慢速交替模式</td></tr><tr><td>ADC_Mode_AlterTrig</td><td>ADC1和ADC2工作在交替触发模式</td></tr></table>

# ADC_ScanConvMode

ADC_ScanConvMode 规定了模数转换工作在扫描模式（多通道）还是单次（单通道）模式。可以设置这个参数为 ENABLE 或者 DISABLE。

# ADC_ConsecutiveConvMode

ADC_ConsecutiveConvMode 规定了模数转换工作在连续还是单次模式。可以设置这个参数为 ENABLE 或者 DISABLE。

# ADC_ExternalTrigConv

ADC_ExternalTrigConv 定义了使用外部触发来启动规则通道的模数转换，这个参数可以取的值见 Table 9.

Table 9. ADC_ExternalTrigConv 定义表  

<table><tr><td>ADC_ExternalTrigConv</td><td>描述</td></tr><tr><td>ADC_ExternalTrigConv_T1_CC1</td><td>选择定时器1的捕获比较1作为转换外部触发</td></tr><tr><td>ADC_ExternalTrigConv_T1_CC2</td><td>选择定时器1的捕获比较2作为转换外部触发</td></tr><tr><td>ADC_ExternalTrigConv_T1_CC3</td><td>选择定时器1的捕获比较3作为转换外部触发</td></tr><tr><td>ADC_ExternalTrigConv_T2_CC2</td><td>选择定时器2的捕获比较2作为转换外部触发</td></tr><tr><td>ADC_ExternalTrigConv_T3_TRGO</td><td>选择定时器3的TRGO作为转换外部触发</td></tr><tr><td>ADC_ExternalTrigConv_T4_CC4</td><td>选择定时器4的捕获比较4作为转换外部触发</td></tr><tr><td>ADC_ExternalTrigConv_Ext_IT11</td><td>选择外部中断线11事件作为转换外部触发</td></tr><tr><td>ADC_ExternalTrigConv_None</td><td>转换由软件而不是外部触发启动</td></tr></table>

# ADC_DataAlign

ADC_DataAlign 规定了 ADC 数据向左边对齐还是向右边对齐。这个参数可以取的值见 Table 10.

Table 10. ADC_DataAlign 定义表  

<table><tr><td>ADC_DataAlign</td><td>描述</td></tr><tr><td>ADC_DataAlignRight</td><td>ADC数据右对齐</td></tr><tr><td>ADC_DataAlign_Left</td><td>ADC数据左对齐</td></tr></table>

# ADC_NbrOfChannel

ADC_NbreOfChannel 规定了顺序进行规则转换的 ADC 通道的数目。这个数目的取值范围是 1 到 16。例：

```c
/\* Initialize the ADC1 according to the ADC_InitStructure members \*/ ADC_InitTypeDef ADC_InitStructure;   
ADC_InitStructure.ADC_Mode  $=$  ADC_Mode_Independent;   
ADC_InitStructure.ADC_ScanConvMode  $=$  ENABLE;   
ADC_InitStructure.ADC_ContruousConvMode  $=$  DISABLE;   
ADC_InitStructure.ADC_ExternalTrigConv  $=$    
ADC_ExternalTrigConv_Ext_IT11;   
ADC_InitStructure.ADC_DataAlign  $=$  ADC_DataAlign_Right;   
ADC_InitStructure.ADC_NbrOfChannel  $= 16$  ADC_Init(ADC1，&ADC_InitStructure);
```

注意：为了能够正确地配置每一个ADC通道，用户在调用ADC_Init()之后，必须调用ADC_ChannelConfig()来配置每个所使用通道的转换次序和采样时间。

# 4.2.3 函数ADCSTRUCTInit

Table 11. 描述了函数 ADCSTRUCTInit  
Table 11. 函数 ADCSTRUCTInit  

<table><tr><td>函数名</td><td>ADC_StructInit</td></tr><tr><td>函数原形</td><td>void ADC_StructInit(ADC_InitTypeDef* ADC_InitStruct)</td></tr><tr><td>功能描述</td><td>把 ADC_InitStruct 中的每一个参数按缺省值填入</td></tr><tr><td>输入参数</td><td>ADC_InitStruct: 指向结构 ADC_InitTypeDef 的指针, 待初始化</td></tr><tr><td>输出参数</td><td>无</td></tr><tr><td>返回值</td><td>无</td></tr><tr><td>先决条件</td><td>无</td></tr><tr><td>被调用函数</td><td>无</td></tr></table>

ADC_InitStruct的成员缺省值如下：

Table 12. ADC_InitStruct 缺省值  

<table><tr><td>成员</td><td>缺省值</td></tr><tr><td>ADC_Mode</td><td>ADC_Mode_Independent</td></tr><tr><td>ADC_ScanConvMode</td><td>DISABLE</td></tr><tr><td>ADC_ContinuousConvMode</td><td>DISABLE</td></tr><tr><td>ADC_ExternalTrigConv</td><td>ADC_ExternalTrigConv_T1_CC1</td></tr><tr><td>ADC_DataAlign</td><td>ADC_DataAlignRight</td></tr><tr><td>ADC_NbrOfChannel</td><td>1</td></tr></table>

例：

/* Initialize a ADC_InitTypeDef structure. */

ADC_InitTypeDef ADC_InitStructure;

ADC_StmtInit(&ADC_StmtStructure);

# 4.2.4 函数ADC_Cmd

Table 13. 描述了函数 ADC_Cmd  
Table 13. 函数 ADC_Cmd  

<table><tr><td>函数名</td><td>ADC_Cmd</td></tr><tr><td>函数原形</td><td>void ADC_Cmd(ADCTypeDef* ADCx, FunctionalState NewState)</td></tr><tr><td>功能描述</td><td>使能或者失能指定的 ADC</td></tr><tr><td>输入参数1</td><td>ADCx: x 可以是 1 或者 2 来选择 ADC 外设 ADC1 或 ADC2</td></tr><tr><td>输入参数2</td><td>NewState: 外设 ADCx 的新状态
这个参数可以取: ENABLE 或者 DISABLE</td></tr><tr><td>输出参数</td><td>无</td></tr><tr><td>返回值</td><td>无</td></tr><tr><td>先决条件</td><td>无</td></tr><tr><td>被调用函数</td><td>无</td></tr></table>

例：

/* Enable ADC1 */

ADC Cmd (ADC1, ENABLE);

注意：函数ADC_Cmd只能在其他ADC设置函数之后被调用。

# 4.2.5 函数ADC_DMAcmd

Table 14. 描述了函数 ADC_DMACmd  
Table 14. 函数 ADC_DMACmd  

<table><tr><td>函数名</td><td>ADC_DMAcd</td></tr><tr><td>函数原形</td><td>ADC_DMAcd(ADC_TYPEDef* ADCx, FunctionalState NewState)</td></tr><tr><td>功能描述</td><td>使能或者失能指定的 ADC 的 DMA 请求</td></tr><tr><td>输入参数 1</td><td>ADCx: x 可以是 1 或者 2 来选择 ADC 外设 ADC1 或 ADC2</td></tr><tr><td>输入参数 2</td><td>NewState: ADC DMA 传输的新状态
这个参数可以取: ENABLE 或者 DISABLE</td></tr><tr><td>输出参数</td><td>无</td></tr><tr><td>返回值</td><td>无</td></tr><tr><td>先决条件</td><td>无</td></tr><tr><td>被调用函数</td><td>无</td></tr></table>

例：

/* Enable ADC2 DMA transfer */

ADC_DMAcd(ADC2, ENABLE);

# 4.2.6 函数ADC_ITConfig

Table 15. 描述了函数 ADC_ITConfig  
Table 15. 函数 ADC_ITConfig  

<table><tr><td>函数名</td><td>ADC_ITConfig</td></tr><tr><td>函数原形</td><td>void ADC_ITConfig(ADC_TYPEDef* ADCx, u16 ADC_IT, FunctionalState NewState)</td></tr><tr><td>功能描述</td><td>使能或者失能指定的 ADC 的中断</td></tr><tr><td>输入参数 1</td><td>ADCx: x 可以是 1 或者 2 来选择 ADC 外设 ADC1 或 ADC2</td></tr><tr><td>输入参数 2</td><td>ADC_IT: 将要被使能或者失能的指定 ADC 中断源
参阅章节 ADC_IT 获得该参数可取值的更多细节</td></tr><tr><td>输入参数 3</td><td>NewState: 指定 ADC 中断的新状态
这个参数可以取：ENABLE 或者 DISABLE</td></tr><tr><td>输出参数</td><td>无</td></tr><tr><td>返回值</td><td>无</td></tr><tr><td>先决条件</td><td>无</td></tr><tr><td>被调用函数</td><td>无</td></tr></table>

# ADC_IT

ADC_IT 可以用来使能或者失能 ADC 中断。可以使用下表中的一个参数，或者他们的组合。

Table 16. ADC_IT 定义表  

<table><tr><td>ADC_IT</td><td>描述</td></tr><tr><td>ADC_IT_EOC</td><td>EOC中断屏蔽</td></tr><tr><td>ADC_IT_AWD</td><td>AWDOG中断屏蔽</td></tr><tr><td>ADC_IT_JEOC</td><td>JEOC中断屏蔽</td></tr></table>

例：

/* Enable ADC2 EOC and AWDOG interrupts */

ADC_ITConfig(ADC2, ADC_IT_EOC | ADC_IT_AWD, ENABLE);

# 4.2.7 函数ADC_SetCalibration

Table 17. 描述了函数 ADC_SetResetCalibration  
Table 17. 函数 ADC Reset Calibration  

<table><tr><td>函数名</td><td>ADC_ResetCalibration</td></tr><tr><td>函数原形</td><td>void ADC_ResetCalibration(ADCTypeDef* ADCx)</td></tr><tr><td>功能描述</td><td>重置指定的 ADC 的校准寄存器</td></tr><tr><td>输入参数</td><td>ADCx: x 可以是 1 或者 2 来选择 ADC 外设 ADC1 或 ADC2</td></tr><tr><td>输出参数</td><td>无</td></tr><tr><td>返回值</td><td>无</td></tr><tr><td>先决条件</td><td>无</td></tr><tr><td>被调用函数</td><td>无</td></tr></table>

例：  
/* Reset the ADC1 Calibration registers */  
ADC_SetCalibration(ADC1);

# 4.2.8 函数ADC_GetResetCalibrationStatus

Table 18. 描述了函数 ADC_GetResetCalibrationStatus  
Table 18. 函数 ADC_GetResetCalibrationStatus  

<table><tr><td>函数名</td><td>ADC_GetResetCalibrationStatus</td></tr><tr><td>函数原形</td><td>FlagStatus ADC_GetResetCalibrationStatus(ADC_TYPEDef* ADCx)</td></tr><tr><td>功能描述</td><td>获取 ADC 重置校准寄存器的状态</td></tr><tr><td>输入参数</td><td>ADCx: x 可以是 1 或者 2 来选择 ADC 外设 ADC1 或 ADC2</td></tr><tr><td>输出参数</td><td>无</td></tr><tr><td>返回值</td><td>ADC 重置校准寄存器的新状态 (SET 或者 RESET)</td></tr><tr><td>先决条件</td><td>无</td></tr><tr><td>被调用函数</td><td>无</td></tr></table>

例：  
/* Get the ADC2 reset calibration registers status */  
FlagStatus Status;  
Status = ADC_GetResetCalibrationStatus(ADC2);

# 4.2.9 函数ADC_StartCalibration

Table 19. 描述了函数 ADC_StartCalibration  
Table 19. 函数 ADC_StartCalibration  

<table><tr><td>函数名</td><td>ADC_StartCalibration</td></tr><tr><td>函数原形</td><td>void ADC_StartCalibration(ADC_TYPEDef* ADCx)</td></tr><tr><td>功能描述</td><td>开始指定 ADC 的校准状态</td></tr><tr><td>输入参数</td><td>ADCx: x 可以是 1 或者 2 来选择 ADC 外设 ADC1 或 ADC2</td></tr><tr><td>输出参数</td><td>无</td></tr><tr><td>返回值</td><td>无</td></tr><tr><td>先决条件</td><td>无</td></tr><tr><td>被调用函数</td><td>无</td></tr></table>

例：  
/* Start the ADC2 Calibration */  
ADC_StartCalibration(ADC2);

# 4.2.10 函数ADC_GetCalibrationStatus

Table 20. 描述了函数 ADC_GetCalibrationStatus  
Table 20. 函数 ADC_GetCalibrationStatus  

<table><tr><td>函数名</td><td>ADC_GetCalibrationStatus</td></tr><tr><td>函数原形</td><td>FlagStatus ADC_GetCalibrationStatus(ADC_TYPEDef* ADCx)</td></tr><tr><td>功能描述</td><td>获取指定 ADC 的校准程序</td></tr><tr><td>输入参数</td><td>ADCx: x 可以是 1 或者 2 来选择 ADC 外设 ADC1 或 ADC2</td></tr><tr><td>输出参数</td><td>无</td></tr><tr><td>返回值</td><td>ADC 校准的新状态 (SET 或者 RESET)</td></tr><tr><td>先决条件</td><td>无</td></tr><tr><td>被调用函数</td><td>无</td></tr></table>

例：  
/* Get the ADC2 calibration status */  
FlagStatus Status;  
Status = ADC_GetCalibrationStatus(ADC2);

# 4.2.11 函数ADC_SoftwareStartConvCmd

Table 21. 描述了函数 ADC_SoftwareStartConvCmd  
Table 21. 函数 ADC_SoftwareStartConvCmd  

<table><tr><td>函数名</td><td>ADC_SoftwareStartConvCmd</td></tr><tr><td>函数原形</td><td>void ADC_SoftwareStartConvCmd(ADC_TYPEDef* ADCx, FunctionalState NewState)</td></tr><tr><td>功能描述</td><td>使能或者失能指定的 ADC 的软件转换启动功能</td></tr><tr><td>输入参数 1</td><td>ADCx: x 可以是 1 或者 2 来选择 ADC 外设 ADC1 或 ADC2</td></tr><tr><td>输入参数 2</td><td>NewState: 指定 ADC 的软件转换启动新状态
这个参数可以取: ENABLE 或者 DISABLE</td></tr><tr><td>输出参数</td><td>无</td></tr><tr><td>返回值</td><td>无</td></tr><tr><td>先决条件</td><td>无</td></tr><tr><td>被调用函数</td><td>无</td></tr></table>

例：  
/* Start by software the ADC1 Conversion */  
ADC_SoftwareStartConvCmd(ADC1, ENABLE);

# 4.2.12 函数ADC_GetSoftwareStartConvStatus

Table 22. 描述了函数 ADC_GetSoftwareStartConvStatus  
Table 22. 函数 ADC_GetSoftwareStartConvStatus  

<table><tr><td>函数名</td><td>ADC_GetSoftwareStartConvStatus</td></tr><tr><td>函数原形</td><td>FlagStatus ADC_GetCalibrationStatus(ADC_TYPEDef* ADCx)</td></tr><tr><td>功能描述</td><td>获取 ADC 软件转换启动状态</td></tr><tr><td>输入参数</td><td>ADCx: x 可以是 1 或者 2 来选择 ADC 外设 ADC1 或 ADC2</td></tr><tr><td>输出参数</td><td>无</td></tr><tr><td>返回值</td><td>ADC 软件转换启动的新状态 (SET 或者 RESET)</td></tr><tr><td>先决条件</td><td>无</td></tr><tr><td>被调用函数</td><td>无</td></tr></table>

例：  
/\*Get the ADC1 conversion start bit \*/ FlagStatus Status; Status  $=$  ADC_GetSoftwareStartConvStatus(ADC1);

# 4.2.13 函数ADC_DiscModeChannelCountConfig

Table 23. 描述了函数 ADC_DiscModeChannelCountConfig  
Table 23. 函数 ADC_DiscModeChannelCountConfig  

<table><tr><td>函数名</td><td>ADC_DiscModeChannelCountConfig</td></tr><tr><td>函数原形</td><td>void ADC_DiscModeChannelCountConfig(ADC_TYPEDef* ADCx, u8 Number)</td></tr><tr><td>功能描述</td><td>对 ADC 规则组通道配置间断模式</td></tr><tr><td>输入参数1</td><td>ADCx: x 可以是 1 或者 2 来选择 ADC 外设 ADC1 或 ADC2</td></tr><tr><td>输入参数2</td><td>Number: 间断模式规则组通道计数器的值。这个值得范围为 1 到 8。</td></tr><tr><td>输出参数</td><td>无</td></tr><tr><td>返回值</td><td>无</td></tr><tr><td>先决条件</td><td>无</td></tr><tr><td>被调用函数</td><td>无</td></tr></table>

例：  
/\* Set the discontinuous mode channel count to 2 for ADC1 \*/ ADC_DiscModeChannelCountConfig(ADC1,2);

# 4.2.14 函数ADC_DiscModeCmd

Table 24. 描述了函数 ADC_DiscModeCmd  
Table 24. 函数 ADC_DiscModeCmd  

<table><tr><td>函数名</td><td>ADC_DiscModeCmd</td></tr><tr><td>函数原形</td><td>void ADC_DiscModeCmd(ADC_TYPEDef* ADCx, FunctionalState NewState)</td></tr><tr><td>功能描述</td><td>使能或者失能指定的 ADC 规则组通道的间断模式</td></tr><tr><td>输入参数 1</td><td>ADCx: x 可以是 1 或者 2 来选择 ADC 外设 ADC1 或 ADC2</td></tr><tr><td>输入参数 2</td><td>NewState: ADC 规则组通道上间断模式的新状态这个参数可以取: ENABLE 或者 DISABLE</td></tr><tr><td>输出参数</td><td>无</td></tr><tr><td>返回值</td><td>无</td></tr><tr><td>先决条件</td><td>无</td></tr><tr><td>被调用函数</td><td>无</td></tr></table>

例：
/* Disable the discontinuous mode for ADC1 regular group channel */
ADC_DiscModeCmd(ADC1, ENABLE);

# 4.2.15 函数ADC-RegularChannelConfig

Table 25. 描述了函数 ADC_RegularChannelConfig  
Table 25. 函数 ADC_RegularChannelConfig  

<table><tr><td>函数名</td><td>ADC-RegularChannelConfig</td></tr><tr><td>函数原形</td><td>void ADC-RegularChannelConfig(ADCTypeDef* ADCx, u8 ADC_Channel, u8 Rank, u8 ADC_SampleTime)</td></tr><tr><td>功能描述</td><td>设置指定 ADC 的规则组通道，设置它们的转化顺序和采样时间</td></tr><tr><td>输入参数1</td><td>ADCx: x 可以是 1 或者 2 来选择 ADC 外设 ADC1 或 ADC2</td></tr><tr><td>输入参数2</td><td>ADC_Channel: 被设置的 ADC 通道
参阅章节 ADC_Channel 查阅更多该参数允许取值范围</td></tr><tr><td>输入参数3</td><td>Rank: 规则组采样顺序。取值范围 1 到 16。</td></tr><tr><td>输入参数4</td><td>ADC_SampleTime: 指定 ADC 通道的采样时间值
参阅章节 ADC_SampleTime 查阅更多该参数允许取值范围</td></tr><tr><td>输出参数</td><td>无</td></tr><tr><td>返回值</td><td>无</td></tr><tr><td>先决条件</td><td>无</td></tr><tr><td>被调用函数</td><td>无</td></tr></table>

# ADC_Channel

参数ADC_Channel指定了通过调用函数ADC-RegularChannelConfig来设置的ADC通道。Table26.列举了ADC_Channel可取的值：

Table 26. ADC_Channel 值  

<table><tr><td>ADC_Channel</td><td>描述</td></tr><tr><td>ADC_Channel_0</td><td>选择 ADC 通道 0</td></tr><tr><td>ADC_Channel_1</td><td>选择 ADC 通道 1</td></tr><tr><td>ADC_Channel_2</td><td>选择 ADC 通道 2</td></tr><tr><td>ADC_Channel_3</td><td>选择 ADC 通道 3</td></tr><tr><td>ADC_Channel_4</td><td>选择 ADC 通道 4</td></tr><tr><td>ADC_Channel_5</td><td>选择 ADC 通道 5</td></tr></table>

# ST

译文英文原版为UM0427 Oct. 2007 Rev 2, 译文仅供参考，与英文版冲突的，以英文版为准

ADC  

<table><tr><td>ADC_Channel_6</td><td>选择 ADC 通道 6</td></tr><tr><td>ADC_Channel_7</td><td>选择 ADC 通道 7</td></tr><tr><td>ADC_Channel_8</td><td>选择 ADC 通道 8</td></tr><tr><td>ADC_Channel_9</td><td>选择 ADC 通道 9</td></tr><tr><td>ADC_Channel_10</td><td>选择 ADC 通道 10</td></tr><tr><td>ADC_Channel_11</td><td>选择 ADC 通道 11</td></tr><tr><td>ADC_Channel_12</td><td>选择 ADC 通道 12</td></tr><tr><td>ADC_Channel_13</td><td>选择 ADC 通道 13</td></tr><tr><td>ADC_Channel_14</td><td>选择 ADC 通道 14</td></tr><tr><td>ADC_Channel_15</td><td>选择 ADC 通道 15</td></tr><tr><td>ADC_Channel_16</td><td>选择 ADC 通道 16</td></tr><tr><td>ADC_Channel_17</td><td>选择 ADC 通道 17</td></tr></table>

# ADC_SampleTime

ADC_SampleTime 设定了选中通道的 ADC 采样时间。Table 27. 列举了 ADC_SampleTime 可取的值：

Table 27. ADC_SampleTime 值:  

<table><tr><td>ADC_SampleTime</td><td>描述</td></tr><tr><td>ADC_SampleTime_1Cycles5</td><td>采样时间为1.5周期</td></tr><tr><td>ADC_SampleTime_7Cycles5</td><td>采样时间为7.5周期</td></tr><tr><td>ADC_SampleTime_13Cycles5</td><td>采样时间为13.5周期</td></tr><tr><td>ADC_SampleTime_28Cycles5</td><td>采样时间为28.5周期</td></tr><tr><td>ADC_SampleTime_41Cycles5</td><td>采样时间为41.5周期</td></tr><tr><td>ADC_SampleTime_55Cycles5</td><td>采样时间为55.5周期</td></tr><tr><td>ADC_SampleTime_71Cycles5</td><td>采样时间为71.5周期</td></tr><tr><td>ADC_SampleTime_239Cycles5</td><td>采样时间为239.5周期</td></tr></table>

例：  
/* Configures ADC1 Channel2 as: first converted channel with an 7.5 cycles sample time */  
ADC_RegularChannelConfig(ADC1, ADC_Channel_2, 1, ADC SampleTime 7Cycles5);  
/\* Configures ADC1 Channel8 as: second converted channel with an 1.5 cycles sample time \*/  
ADC_RegularChannelConfig(ADC1, ADC_Channel_8, 2, ADC_SampleTime_1Cycles5);

# 4.2.16 函数ADC_ExternalTrigConvConfig

Table 28. 描述了函数 ADC_ExternalTrigConvConfig  
Table 28. 函数 ADC_ExternalTrigConvConfig  

<table><tr><td>函数名</td><td>ADC_ExternalTrigConvConfig</td></tr><tr><td>函数原形</td><td>void ADC_ExternalTrigConvCmd(ADCTypeDef* ADCx, FunctionalState NewState)</td></tr><tr><td>功能描述</td><td>使能或者失能 ADCx 的经外部触发启动转换功能</td></tr><tr><td>输入参数1</td><td>ADCx: x 可以是 1 或者 2 来选择 ADC 外设 ADC1 或 ADC2</td></tr><tr><td>输入参数2</td><td>NewState: 指定 ADC 外部触发转换启动的新状态
这个参数可以取: ENABLE 或者 DISABLE</td></tr><tr><td>输出参数</td><td>无</td></tr><tr><td>返回值</td><td>无</td></tr><tr><td>先决条件</td><td>无</td></tr><tr><td>被调用函数</td><td>无</td></tr></table>

例：
/*Enable the start of conversion for ADC1 through external trigger */
ADC_ExternalTrigConvCmd(ADC1, ENABLE);

# 4.2.17 函数ADC_GetConversionValue

Table 29. 描述了函数 ADC_GetConversionValue  
Table 29. 函数 ADC_GetConversionValue  

<table><tr><td>函数名</td><td>ADC_GetConversionValue</td></tr><tr><td>函数原形</td><td>u16 ADC_GetConversionValue(ADCTypeDef* ADCx)</td></tr><tr><td>功能描述</td><td>返回最近一次 ADCx 规则组的转换结果</td></tr><tr><td>输入参数</td><td>ADCx: x 可以是 1 或者 2 来选择 ADC 外设 ADC1 或 ADC2</td></tr><tr><td>输出参数</td><td>无</td></tr><tr><td>返回值</td><td>转换结果</td></tr><tr><td>先决条件</td><td>无</td></tr><tr><td>被调用函数</td><td>无</td></tr></table>

例：
/*Returns the ADC1 Master data value of the last converted channel*/
u16 DataValue;
DataValue = ADC_GetConversionValue(ADC1);

# 4.2.18 函数ADC_GetDuelModeConversionValue

Table 30. 描述了函数 ADC_GetDuelModeConversionValue

Table 30. 函数 ADC_GetDuelModeConversionValue  

<table><tr><td>函数名</td><td>ADC_GetDuelModeConversionValue</td></tr><tr><td>函数原形</td><td>u32 ADC_GetDuelModeConversionValue()</td></tr><tr><td>功能描述</td><td>返回最近一次双 ADC 模式下的转换结果</td></tr><tr><td>输入参数</td><td>ADCx: x 可以是 1 或者 2 来选择 ADC 外设 ADC1 或 ADC2</td></tr><tr><td>输出参数</td><td>无</td></tr><tr><td>返回值</td><td>转换结果</td></tr><tr><td>先决条件</td><td>无</td></tr><tr><td>被调用函数</td><td>无</td></tr></table>

例：  
/* Returns the ADC1 and ADC2 last converted values*/  
u32 DataValue;  
DataValue = ADC_GetDualModeConversionValue();

# 4.2.19 函数ADC_AutoInjectedConvCmd

Table 31. 描述了函数 ADC_AutoInjectedConvCmd

Table 31. 函数 ADC_AutoInjectedConvCmd  

<table><tr><td>函数名</td><td>ADC_AutoInjectedConvCmd</td></tr><tr><td>函数原形</td><td>void ADC_AutoInjectedConvCmd(ADCTypeDef* ADCx, FunctionalState NewState)</td></tr><tr><td>功能描述</td><td>使能或者失能指定 ADC 在规则组转化后自动开始注入组转换</td></tr><tr><td>输入参数1</td><td>ADCx: x 可以是 1 或者 2 来选择 ADC 外设 ADC1 或 ADC2</td></tr><tr><td>输入参数2</td><td>NewState: 指定 ADC 自动注入转化的新状态
这个参数可以取: ENABLE 或者 DISABLE</td></tr><tr><td>输出参数</td><td>无</td></tr><tr><td>返回值</td><td>无</td></tr><tr><td>先决条件</td><td>无</td></tr><tr><td>被调用函数</td><td>无</td></tr></table>

例：  
/\* Enable the auto injected conversion for ADC2 \*/  
ADC_AutoInjectedConvCmd(ADC2, ENABLE);

# 4.2.20 函数ADC_InjectedDiscModeCmd

Table 32. 描述了函数 ADC_InjectedDiscModeCmd  
Table 32. 函数 ADC_InjectedDiscModeCmd  

<table><tr><td>函数名</td><td>ADC_InjectedDiscModeCmd</td></tr><tr><td>函数原形</td><td>void ADC_InjectedDiscModeCmd(ADC_TYPEDef* ADCx, FunctionalState NewState)</td></tr><tr><td>功能描述</td><td>使能或者失能指定 ADC 的注入组间断模式</td></tr><tr><td>输入参数1</td><td>ADCx: x 可以是 1 或者 2 来选择 ADC 外设 ADC1 或 ADC2</td></tr><tr><td>输入参数2</td><td>NewState: ADC 注入组通道上间断模式的新状态
这个参数可以取: ENABLE 或者 DISABLE</td></tr><tr><td>输出参数</td><td>无</td></tr><tr><td>返回值</td><td>无</td></tr><tr><td>先决条件</td><td>无</td></tr><tr><td>被调用函数</td><td>无</td></tr></table>

例：
/* Enable the injected discontinuous mode for ADC2 */
ADC_InjectedDiscModeCmd(ADC2, ENABLE);

# 4.2.21 函数ADC_ExternalTrigInjectedConvConfig

Table 33. 描述了函数 ADC_ExternalTrigInjectedConvConfig  
Table 33. 函数 ADC_ExternalTrigInjectedConvConfig  

<table><tr><td>函数名</td><td>ADC_ExternalTrigInjectedConvConfig</td></tr><tr><td>函数原形</td><td>void ADC_ExternalTrigInjectedConvConfig(ADCTypeDef* ADCx, u32 ADC_ExternalTrigConv)</td></tr><tr><td>功能描述</td><td>配置 ADCx 的外部触发启动注入组转换功能</td></tr><tr><td>输入参数 1</td><td>ADCx: x 可以是 1 或者 2 来选择 ADC 外设 ADC1 或 ADC2</td></tr><tr><td>输入参数 2</td><td>ADC_ExternalTrigConv: 启动注入转换的 ADC 触发参阅章节 ADC_ExternalTrigInjectedConv 查阅更多该参数允许取值范围</td></tr><tr><td>输出参数</td><td>无</td></tr><tr><td>返回值</td><td>无</td></tr><tr><td>先决条件</td><td>无</td></tr><tr><td>被调用函数</td><td>无</td></tr></table>

# ADC_ExternalTrigInjectedConv

ADC_ExternalTrigInjectedConv 指定了所使用的注入转换启动触发。Table 34. 列举了 ADC_ExternalTrigInjectedConv 可取的值:

Table 34. ADC_ExternalTrigInjectedConv 值  

<table><tr><td>ADC_ExternalTrigInjectedConv</td><td>描述</td></tr><tr><td>ADC_ExternalTrigInjecConv_T1_TRGO</td><td>选择定时器1的TRGO作为注入转换外部触发</td></tr><tr><td>ADC_ExternalTrigInjecConv_T1_CC4</td><td>选择定时器1的捕获比较4作为注入转换外部触发</td></tr><tr><td>ADC_ExternalTrigInjecConv_T2_TRGO</td><td>选择定时器2的TRGO作为注入转换外部触发</td></tr><tr><td>ADC_ExternalTrigInjecConv_T2_CC1</td><td>选择定时器2的捕获比较1作为注入转换外部触发</td></tr><tr><td>ADC_ExternalTrigInjecConv_T3_CC4</td><td>选择定时器3的捕获比较4作为注入转换外部触发</td></tr><tr><td>ADC_ExternalTrigInjecConv_T4_TRGO</td><td>选择定时器4的TRGO作为注入转换外部触发</td></tr><tr><td>ADC_ExternalTrigInjecConv_Ext_IT15</td><td>选择外部中断线15事件作为注入转换外部触发</td></tr><tr><td>ADC_ExternalTrigInjecConv_None</td><td>注入转换由软件而不是外部触发启动</td></tr></table>

```txt
ADC
```

例：

```c
/\* Set ADC1 injected external trigger conversion start to Timer1 capture compare4 \*/ ADC_ExternalTrigInjectedConvConfig(ADC1, ADC_ExternalTrigConv_T1_CC4);
```

# 4.2.22 函数ADC_ExternalTrigInjectedConvCmd

Table 35. 描述了函数 ADC_ExternalTrigInjectedConvCmd  
Table 35. 函数 ADC_ExternalTrigInjectedConvCmd  

<table><tr><td>函数名</td><td>ADC_ExternalTrigInjectedConvCmd</td></tr><tr><td>函数原形</td><td>void ADC_ExternalTrigInjectedConvCmd(ADCTypeDef* ADCx, FunctionalState NewState)</td></tr><tr><td>功能描述</td><td>使能或者失能 ADCx 的经外部触发启动注入组转换功能</td></tr><tr><td>输入参数1</td><td>ADCx: x 可以是 1 或者 2 来选择 ADC 外设 ADC1 或 ADC2</td></tr><tr><td>输入参数2</td><td>NewState: 指定 ADC 外部触发启动注入转换的新状态这个参数可以取: ENABLE 或者 DISABLE</td></tr><tr><td>输出参数</td><td>无</td></tr><tr><td>返回值</td><td>无</td></tr><tr><td>先决条件</td><td>无</td></tr><tr><td>被调用函数</td><td>无</td></tr></table>

例：

```txt
/\* Enable the start of injected conversion for ADC1 through external trigger \*/ ADC_ExternalTrigInjectedConvCmd(ADC1, ENABLE);
```

# 4.2.23 函数ADC_SoftwareStartingConvCmd

Table 36. 描述了函数 ADC_SoftwareStartinjectedConvCmd  
Table 36. 函数 ADC_SoftwareStartinjectedConvCmd  

<table><tr><td>函数名</td><td>ADC_SoftwareStartinjectedConvCmd</td></tr><tr><td>函数原形</td><td>void ADC_SoftwareStartInjectedConvCmd(ADC_TYPEDef* ADCx, FunctionalState NewState)</td></tr><tr><td>功能描述</td><td>使能或者失能 ADCx 软件启动注入组转换功能</td></tr><tr><td>输入参数 1</td><td>ADCx: x 可以是 1 或者 2 来选择 ADC 外设 ADC1 或 ADC2</td></tr><tr><td>输入参数 2</td><td>NewState: 指定 ADC 软件触发启动注入转换的新状态这个参数可以取: ENABLE 或者 DISABLE</td></tr><tr><td>输出参数</td><td>无</td></tr><tr><td>返回值</td><td>无</td></tr><tr><td>先决条件</td><td>无</td></tr><tr><td>被调用函数</td><td>无</td></tr></table>

例：

```javascript
/\*Startby software the ADC2 Conversion \*/ ADC_SoftwareStartInjectedConvCmd(ADC2，ENABLE);
```

# 4.2.24 函数ADC_GetsoftwareStartinjectedConvStatus

Table 37. 描述了函数 ADC_GetsoftwareStartinjectedConvStatus  
Table 37. 函数 ADC_GetsoftwareStartinjectedConvStatus  

<table><tr><td>函数名</td><td>ADC_GetsoftwareStartinjectedConvStatus</td></tr><tr><td>函数原形</td><td>FlagStatus ADC_GetSoftwareStartInjectedConvStatus(ADC_TYPEDef* ADCx)</td></tr><tr><td>功能描述</td><td>获取指定 ADC 的软件启动注入组转换状态</td></tr><tr><td>输入参数</td><td>ADCx: x 可以是 1 或者 2 来选择 ADC 外设 ADC1 或 ADC2</td></tr><tr><td>输出参数</td><td>无</td></tr><tr><td>返回值</td><td>ADC 软件触发启动注入转换的新状态</td></tr><tr><td>先决条件</td><td>无</td></tr><tr><td>被调用函数</td><td>无</td></tr></table>

例：
/* Get the ADC1 injected conversion start bit */
FlagStatus Status;
Status = ADC_GetSoftwareStartInjectedConvStatus(ADC1);

# 4.2.25 函数ADC_InjectedChannleConfig

Table 38. 描述了函数 ADC_InjectedChannleConfig  
Table 38. 函数 ADC_InjectedChannleConfig  

<table><tr><td>函数名</td><td>ADC_InjectedChannleConfig</td></tr><tr><td>函数原形</td><td>void ADC_InjectedChannelConfig(ADC_TYPEDef* ADCx, u8 ADC_Channel, u8 Rank, u8 ADC_SampalTime)</td></tr><tr><td>功能描述</td><td>设置指定 ADC 的注入组通道，设置它们的转化顺序和采样时间</td></tr><tr><td>输入参数1</td><td>ADCx: x 可以是 1 或者 2 来选择 ADC 外设 ADC1 或 ADC2</td></tr><tr><td>输入参数2</td><td>ADC_Channel: 被设置的 ADC 通道
参阅章节 ADC_Channel 查阅更多该参数允许取值范围</td></tr><tr><td>输入参数3</td><td>Rank: 规则组采样顺序。取值范围 1 到 4。</td></tr><tr><td>输入参数4</td><td>ADC_SampalTime: 指定 ADC 通道的采样时间值
参阅章节 ADC_SampalTime 查阅更多该参数允许取值范围</td></tr><tr><td>输出参数</td><td>无</td></tr><tr><td>返回值</td><td>无</td></tr><tr><td>先决条件</td><td>之前必须调用函数 ADC_InjectedSequencerLengthConfig 来确定注入转换通道的数目。特别是在通道数目小于 4 的情况下，来正确配置每个注入通道的转化顺序。</td></tr><tr><td>被调用函数</td><td>无</td></tr></table>

# ADC_Channel

参数ADC_Channel指定了需设置的ADC通道。Table26.列举了ADC_Channel可取的值。

# ADC_SampleTime

ADC_SampleTime 设定了选中通道的 ADC 采样时间。Table 27. 列举了 ADC_SampleTime 可取的值。

例：

```c
/\* Configures ADC1 Channel12 as: second converted channel with a 28.5 cycles sample time \*/   
ADC_InjectedChannelConfig(ADC1, ADC_Channel_12, 2, ADC_SampalTime 28Cycles5);   
/\* Configures ADC2 Channel4 as: eleven converted channel with an 71.5 cycles sample time \*/   
ADC_InjectedChannelConfig(ADC2, ADC_Channel_4, 11,
```

ST

译文英文原版为UM0427 Oct. 2007 Rev 2, 译文仅供参考，与英文版冲突的，以英文版为准

ADC SampleTime_71Cycles5);

# 4.2.26 函数ADC_InjectedSequencerLengthConfig

Table 39. 描述了函数 ADC_InjectedSequencerLengthConfig

Table 39. 函数 ADC_InjectedSequencerLengthConfig  

<table><tr><td>函数名</td><td>ADC_InjectedSequencerLengthConfig</td></tr><tr><td>函数原形</td><td>void ADC_InjectedSequencerLengthConfig(ADC_TYPEDef* ADCx, u8 Length)</td></tr><tr><td>功能描述</td><td>设置注入组通道的转换序列长度</td></tr><tr><td>输入参数1</td><td>ADCx: x 可以是 1 或者 2 来选择 ADC 外设 ADC1 或 ADC2</td></tr><tr><td>输入参数2</td><td>Length: 序列长度
这个参数取值范围 1 到 4。</td></tr><tr><td>输出参数</td><td>无</td></tr><tr><td>返回值</td><td>无</td></tr><tr><td>先决条件</td><td>无</td></tr><tr><td>被调用函数</td><td>无</td></tr></table>

例：  
/\* Set the ADC1 Sequencer length to 4 channels \*/  
ADC_InjectedSequencerLengthConfig(ADC1, 4);

# 4.2.27 函数ADC_SetinjectedOffset

Table 40. 描述了函数 ADC_SetinjectedOffset

Table 40. 函数 ADC_SetinjectedOffset  

<table><tr><td>函数名</td><td>ADC_SetinjectedOffset</td></tr><tr><td>函数原形</td><td>void ADC_SetInjectedOffset(ADC_TYPEDef* ADCx, u8 ADC_InjectedChannel, u16 Offset)</td></tr><tr><td>功能描述</td><td>设置注入组通道的转换偏移值</td></tr><tr><td>输入参数1</td><td>ADCx: x 可以是 1 或者 2 来选择 ADC 外设 ADC1 或 ADC2</td></tr><tr><td>输入参数2</td><td>ADC_InjectedChannel: 被设置转换偏移值的 ADC 注入通道参阅章节 ADC_InjectedChannel 查阅更多该参数允许取值范围</td></tr><tr><td>输入参数3</td><td>Offset: ADC 注入通道的转换偏移值这个值是一个 12 位值。</td></tr><tr><td>输出参数</td><td>无</td></tr><tr><td>返回值</td><td>无</td></tr><tr><td>先决条件</td><td>无</td></tr><tr><td>被调用函数</td><td>无</td></tr></table>

# ADC_InjectedChannel

参数ADC_InjectedChannel指定了必须设置转换偏移值的ADC通道。Table41.列举了ADC_InjectedChannel可取的值。Table41.ADC_InjectedChannel值

<table><tr><td>ADC_InjectedChannel</td><td>描述</td></tr><tr><td>ADC_InjectedChannel_1</td><td>选择注入通道1</td></tr><tr><td>ADC_InjectedChannel_2</td><td>选择注入通道2</td></tr><tr><td>ADC_InjectedChannel_3</td><td>选择注入通道3</td></tr><tr><td>ADC_InjectedChannel_4</td><td>选择注入通道4</td></tr></table>

例：  
/* Set the offset 0x100 for the 3rd injected Channel of ADC1 */  
ADC_SetInjectedOffset(ADC1, ADC_InjectedChannel_3, 0x100);

# 4.2.28 函数ADC_GetInjectedConversionValue

Table 42. 描述了函数 ADC_GetInjectedConversionValue  
Table 42. 函数 ADC_GetInjectedConversionValue  

<table><tr><td>函数名</td><td>ADC_GetInjectedConversionValue</td></tr><tr><td>函数原形</td><td>u16 ADC_GetInjectedConversionValue(ADC_TYPEDef* ADCx, u8 ADC_InjectedChannel)</td></tr><tr><td>功能描述</td><td>返回 ADC 指定注入通道的转换结果</td></tr><tr><td>输入参数 1</td><td>ADCx: x 可以是 1 或者 2 来选择 ADC 外设 ADC1 或 ADC2</td></tr><tr><td>输入参数 2</td><td>ADC_InjectedChannel: 被转换的 ADC 注入通道
参阅章节 ADC_InjectedChannel 查阅更多该参数允许取值范围</td></tr><tr><td>输出参数</td><td>无</td></tr><tr><td>返回值</td><td>转换结果</td></tr><tr><td>先决条件</td><td>无</td></tr><tr><td>被调用函数</td><td>无</td></tr></table>

例：  
/* Return the ADC1 injected channel1 converted data value */  
ul6 InjectedDataValue;  
InjectedDataValue = ADC GetInjectedConversionValue(ADC1,  
ADC_InjectedChannel_1);

# 4.2.29 函数ADC_AnalogWatchdogCmd

Table 43. 描述了函数 ADC_AnalogWatchdogCmd  
Table 43. 函数 ADC_AnalogWatchdogCmd  

<table><tr><td>函数名</td><td>ADC_AncalogWatchdogCmd</td></tr><tr><td>函数原形</td><td>void ADC_AncalogWatchdogCmd(ADC_TYPEDef* ADCx, u32 ADC_AncalogWatchdog)</td></tr><tr><td>功能描述</td><td>使能或者失能指定单个/全体，规则/注入组通道上的模拟看门狗</td></tr><tr><td>输入参数1</td><td>ADCx: x 可以是 1 或者 2 来选择 ADC 外设 ADC1 或 ADC2</td></tr><tr><td>输入参数2</td><td>ADC_AncalogWatchdog: ADC 模拟看门狗设置
参阅章节 ADC_AncalogWatchdog 查阅更多该参数允许取值范围</td></tr><tr><td>输出参数</td><td>无</td></tr><tr><td>返回值</td><td>无</td></tr><tr><td>先决条件</td><td>无</td></tr><tr><td>被调用函数</td><td>无</td></tr></table>

# ADC_AnalogWatchdog

ADC_AnalogWatchdog 规定了 ADC 模拟看门狗的设置。Table 44.列举了 ADC_AnalogWatchdog 可取的值:

Table 44. ADC_AnalogWatchdog 值  

<table><tr><td>ADC_AncalogWatchdog</td><td>描述</td></tr><tr><td>ADC_AncalogWatchdog_SingleRegEnable</td><td>单个规则通道上设置模拟看门狗</td></tr><tr><td>ADC_AncalogWatchdog_SingleInjecEnable</td><td>单个注入通道上设置模拟看门狗</td></tr><tr><td>ADC_AncalogWatchdog_SingleRegorInjecEnable</td><td>单个规则通道或者注入通道上设置模拟看门狗</td></tr><tr><td>ADC_AncalogWatchdog_AllRegEnable</td><td>所有规则通道上设置模拟看门狗</td></tr><tr><td>ADC_AncalogWatchdog_AllInjecEnable</td><td>所有注入通道上设置模拟看门狗</td></tr><tr><td>ADC_AncalogWatchdog_AllRegAllInjecEnable</td><td>所有规则通道和所有注入通道上上设置模拟看门狗</td></tr><tr><td>ADC_AncalogWatchdog_None</td><td>不设置模拟看门狗</td></tr></table>

例：  
/* Configure the Analog watchdog on all regular and injected channels

# ST

译文英文原版为UM0427 Oct. 2007 Rev 2, 译文仅供参考，与英文版冲突的，以英文版为准

# 4.2.30 函数ADC_AnalogWatchdongThresholdsConfig

Table 45. 描述了函数 ADC_AnalogWatchdongThresholdsConfig  
Table 45. 函数 ADC_AnalogWatchdongThresholdsConfig  

<table><tr><td>函数名</td><td>ADC_AncalogWatchdongThresholdsConfig</td></tr><tr><td>函数原形</td><td>void ADC_AncalogWatchdogThresholdsConfig(ADC_TYPEDef* ADCx, u16 HighThreshold, u16 LowThreshold)</td></tr><tr><td>功能描述</td><td>设置模拟看门狗的高/低阈值</td></tr><tr><td>输入参数1</td><td>ADCx: x可以是1或者2来选择ADC外设ADC1或ADC2</td></tr><tr><td>输入参数2</td><td>HignThreshold: 模拟看门狗的高阈值这个参数是一个12位值。</td></tr><tr><td>输入参数3</td><td>LowThreshold: 模拟看门狗的低阈值这个参数是一个12位值。</td></tr><tr><td>输出参数</td><td>无</td></tr><tr><td>返回值</td><td>无</td></tr><tr><td>先决条件</td><td>无</td></tr><tr><td>被调用函数</td><td>无</td></tr></table>

例：
/* Configure the Analog watchdog High and Low thresholds for ADC1 */
ADC_AnalogWatchdogThresholdsConfig(ADC1, 0x400, 0x100);

# 4.2.31 函数ADC_AnalogWatchdongSingleChannelConfig

Table 46. 描述了函数 ADC_AnalogWatchdongSingleChannelConfig  
Table 46. 函数 ADC_AnalogWatchdongSingleChannelConfig  

<table><tr><td>函数名</td><td>ADC_AncalogWatchdongSingleChannelConfig</td></tr><tr><td>函数原形</td><td>void ADC_AncalogWatchdogSingleChannelConfig(ADC_TYPEDef* ADCx, u8 ADC_Channel)</td></tr><tr><td>功能描述</td><td>对单个ADC通道设置模拟看门狗</td></tr><tr><td>输入参数1</td><td>ADCx: x可以是1或者2来选择ADC外设ADC1或ADC2</td></tr><tr><td>输入参数2</td><td>ADC_Channel: 被设置模拟看门狗的ADC通道
参阅章节ADC_Channel 查阅更多该参数允许取值范围</td></tr><tr><td>输出参数</td><td>无</td></tr><tr><td>返回值</td><td>无</td></tr><tr><td>先决条件</td><td>无</td></tr><tr><td>被调用函数</td><td>无</td></tr></table>

例：
/* Configure the Analog watchdog on Channel1 of ADC1 */
ADC_AnalogWatchdogSingleChannelConfig(ADC1, ADC_Channel_1);

# 4.2.32 函数ADC_TampSensorVrefintCmd

Table 47. 描述了函数 ADC_TampSensorVrefintCmd  
Table 47. 函数 ADC_TampSensorVrefintCmd  

<table><tr><td>函数名</td><td>ADC_TampSensorVrefintCmd</td></tr><tr><td>函数原形</td><td>void ADC_TampSensorVrefintCmd(FunctionalState NewState)</td></tr><tr><td>功能描述</td><td>使能或者失能温度传感器和内部参考电压通道</td></tr><tr><td>输入参数</td><td>NewState: 温度传感器和内部参考电压通道的新状态
这个参数可以取: ENABLE 或者 DISABLE</td></tr><tr><td>输出参数</td><td>无</td></tr><tr><td>返回值</td><td>无</td></tr><tr><td>先决条件</td><td>无</td></tr><tr><td>被调用函数</td><td>无</td></tr></table>

例：

/* Enable the temperature sensor and vref internal channel */ ADC_TempSensorVrefintCmd(ENABLE);

# 4.2.33 函数ADC_GetFlagStatus

Table 48. 描述了函数 ADC_GetFlagStatus  
Table 48. 函数 ADC_GetFlagStatus  

<table><tr><td>函数名</td><td>ADC_GetFlagStatus</td></tr><tr><td>函数原形</td><td>FlagStatus ADC_GetFlagStatus(ADC_TypeDef* ADCx, u8 ADC_FLAG)</td></tr><tr><td>功能描述</td><td>检查制定 ADC 标志位置 1 与否</td></tr><tr><td>输入参数 1</td><td>ADCx: x 可以是 1 或者 2 来选择 ADC 外设 ADC1 或 ADC2</td></tr><tr><td>输入参数 2</td><td>ADC_FLAG: 指定需检查的标志位
参阅章节 ADC_FLAG 查阅更多该参数允许取值范围</td></tr><tr><td>输出参数</td><td>无</td></tr><tr><td>返回值</td><td>无</td></tr><tr><td>先决条件</td><td>无</td></tr><tr><td>被调用函数</td><td>无</td></tr></table>

# ADC_FLAG

Table 49. 给出了 ADC_FLAG 的值  
Table 49. ADC_FLAG 的值  

<table><tr><td>ADC_AncalogWatchdog</td><td>描述</td></tr><tr><td>ADC_FLAG_AWD</td><td>模拟看门狗标志位</td></tr><tr><td>ADC_FLAG_EOC</td><td>转换结束标志位</td></tr><tr><td>ADC_FLAG_JEOC</td><td>注入组转换结束标志位</td></tr><tr><td>ADC_FLAG_JSTRT</td><td>注入组转换开始标志位</td></tr><tr><td>ADC_FLAG_STRT</td><td>规则组转换开始标志位</td></tr></table>

例：

/\*TestiftheADC1EOCflagissetornot\*/ FlagStatusStatus; Status  $=$  ADC_GetFlagStatus(ADC1，ADC_FLAG_EOC);

# 4.2.34 函数ADC_ClearFlag

Table 50. 描述了函数 ADC_ClearFlag  
Table 50. 函数 ADC_ClearFlag  

<table><tr><td>函数名</td><td>ADC_ClearFlag</td></tr><tr><td>函数原形</td><td>void ADC_ClearFlag(ADC_TYPEDef* ADCx, u8 ADC_FLAG)</td></tr><tr><td>功能描述</td><td>清除 ADCx 的待处理标志位</td></tr><tr><td>输入参数1</td><td>ADCx: x 可以是 1 或者 2 来选择 ADC 外设 ADC1 或 ADC2</td></tr><tr><td>输入参数2</td><td>ADC_FLAG: 待处理的标志位, 使用操作符“|”可以同时清除 1 个以上的标志位
参阅章节 ADC_FLAG 查阅更多该参数允许取值范围</td></tr><tr><td>输出参数</td><td>无</td></tr><tr><td>返回值</td><td>无</td></tr><tr><td>先决条件</td><td>无</td></tr><tr><td>被调用函数</td><td>无</td></tr></table>

例：

```txt
/\* Clear the ADC2 STRT pending flag \*/ ADC_ClearFlag(ADC2，ADC_FLAG_STRT);
```

# 4.2.35 函数ADC_GetITStatus

Table 51. 描述了函数 ADC_GetITStatus  
Table 51. 函数 ADC_GetITStatus  

<table><tr><td>函数名</td><td>ADC_GetITStatus</td></tr><tr><td>函数原形</td><td>ITStatus ADC_GetITStatus(ADCTypeDef* ADCx, u16 ADC_IT)</td></tr><tr><td>功能描述</td><td>检查指定的 ADC 中断是否发生</td></tr><tr><td>输入参数 1</td><td>ADCx: x 可以是 1 或者 2 来选择 ADC 外设 ADC1 或 ADC2</td></tr><tr><td>输入参数 2</td><td>ADC_IT: 将要被检查指定 ADC 中断源
参阅章节 ADC_IT 获得该参数可取值得更多细节</td></tr><tr><td>输出参数</td><td>无</td></tr><tr><td>返回值</td><td>无</td></tr><tr><td>先决条件</td><td>无</td></tr><tr><td>被调用函数</td><td>无</td></tr></table>

例：

```c
/\*Testif the ADC1AWD interrupt has occurred or not \*/ ITStatus Status; Status  $=$  ADC_GetITStatus(ADC1，ADC_IT_AWD);
```

# 4.2.36 函数ADC_ClearITPendingBit

Table 52. 描述了函数 ADC_ClearITPendingBit  
Table 52. 函数 ADC_ClearITPendingBit  

<table><tr><td>函数名</td><td>ADC_ClearITPendingBit</td></tr><tr><td>函数原形</td><td>void ADC_ClearITPendingBit(ADC_TYPEDef* ADCx, u16 ADC_IT)</td></tr><tr><td>功能描述</td><td>清除 ADCx 的中断待处理位</td></tr><tr><td>输入参数 1</td><td>ADCx: x 可以是 1 或者 2 来选择 ADC 外设 ADC1 或 ADC2</td></tr><tr><td>输入参数 2</td><td>ADC_IT: 带清除的 ADC 中断待处理位
参阅章节 ADC_IT 获得该参数可取值得更多细节</td></tr><tr><td>输出参数</td><td>无</td></tr><tr><td>返回值</td><td>无</td></tr><tr><td>先决条件</td><td>无</td></tr><tr><td>被调用函数</td><td>无</td></tr></table>

例：  
/* Clear the ADC2 JEOC interrupt pending bit */  
ADC_ClearITPendingBit(ADC2, ADC_IT_JEOC);

# 5. 备份寄存器（BKP）

备份寄存器由10个16位寄存器组成，可用来存储20个字节的用户应用程序数据。他们处在备份域里，当VDD电源被切断，他们仍然由VBAT维持供电。当系统在待机模式下被唤醒，或系统复位或电源复位时，他们也不会被复位。

此外，BKP控制寄存器用来管理侵入检测和RTC校准功能。

Section 5.1 BKP 寄存器结构描述了 BKP 固件函数库所使用的数据结构, Section 5.2 固件库函数介绍了函数库里的所有函数。

# 5.1 BKP寄存器结构

BKP 寄存器结构，BKPTypeDef，在文件“stm32f10x_map.h”中定义如下：

```txt
typedef struct   
{ u32 RESERVED0; vu16 DR1; u16 RESERVED1; vu16 DR2; u16 RESERVED2; vu16 DR3; u16 RESERVED3; vu16 DR4; u16 RESERVED4; vu16 DR5; u16 RESERVED5; vu16 DR6; u16 RESERVED6; vu16 DR7; u16 RESERVED7; vu16 DR8; u16 RESERVED8; vu16 DR9; u16 RESERVED9; vu16 DR10; u16 RESERVED10; vu16 RTCCR; u16 RESERVED11; vu16 CR; u16 RESERVED12; vu16 CSR; u16 RESERVED13; } BKPTypeDef;
```

Table 53. 给出了 BKP 的寄存器列表:  
Table 53. BKP 寄存器  

<table><tr><td>寄存器</td><td>描述</td></tr><tr><td>DR 1-10</td><td>数据后备寄存器1到10</td></tr><tr><td>RTCCR</td><td>RTC时钟校准寄存器</td></tr><tr><td>CR</td><td>后备控制寄存器</td></tr><tr><td>CSR</td><td>后备控制状态寄存器</td></tr></table>

BKP外设同时在文件“stm32f10x_map.h”中声明如下：

```c
define PERIPH_BASE((u32)0x40000000)  
#define APB1PERIPH_BASE PERIPH_BASE  
#define APB2PERIPH_BASE (PERIPH_BASE + 0x10000)
```

# ST

译文英文原版为UM0427 Oct. 2007 Rev 2, 译文仅供参考，与英文版冲突的，以英文版为准

BKP  
```c
define AHBPERIPH_BASE (PERIPH_BASE + 0x20000)  
#define BKP_BASE (APB1PERIPH_BASE + 0x6C00)  
#	define DEBUG  
...  
#	define_BKP  
#	define_BKP((BKP_TYPEDef *) BKP_BASE)  
#endif /*_BKP */  
...  
#else /* DEBUG */  
...  
#	define_BKP  
EXT_BKP_TYPEDef *BKP;  
#endif /*_BKP */  
...  
#endif
```

```c
使用Debug模式时，初始化BKP指针与文件“stm32f10x_lib.c”：  
#ifdef_BKP  
BKP = (BKPTypeDef *) BKP_BASE;  
#endif /*_BKP */  
为了访问BKP寄存器，,_BKP必须在文件“stm32f10x_conf.h”中定义如下：  
#define_BKP
```

# 5.2 BKP库函数

Table 54. 例举了 BKP 的库函数  
Table 54. BKP 库函数  

<table><tr><td>函数名</td><td>描述</td></tr><tr><td>BKP_DeInit</td><td>将外设BKP的全部寄存器重设为缺省值</td></tr><tr><td>BKP_TamperPinLevelConfig</td><td>设置侵入检测管脚的有效电平</td></tr><tr><td>BKP_TamperPinCmd</td><td>使能或者失能管脚的侵入检测功能</td></tr><tr><td>BKP_ITConfig</td><td>使能或者失能侵入检测中断</td></tr><tr><td>BKP_RTCOutputConfig</td><td>选择在侵入检测管脚上输出的RTC时钟源</td></tr><tr><td>BKP_SetRTCCalibrationValue</td><td>设置RTC时钟校准值</td></tr><tr><td>BKP_WritesBackupRegister</td><td>向指定的后备寄存器中写入用户程序数据</td></tr><tr><td>BKP_ReadBackupRegister</td><td>从指定的后备寄存器中读出数据</td></tr><tr><td>BKP_GetFlagStatus</td><td>检查侵入检测管脚事件的标志位被设置与否</td></tr><tr><td>BKP_ClearFlag</td><td>清除侵入检测管脚事件的待处理标志位</td></tr><tr><td>BKP_GetITStatus</td><td>检查侵入检测中断发生与否</td></tr><tr><td>BKP_ClearITPendingBit</td><td>清除侵侵入检测中断的待处理位</td></tr></table>

# 5.2.1 函数BKP_DeInit

Table 55. 描述了函数 BKP_DeInit  
Table 55. 函数 BKP_DeInit  

<table><tr><td>函数名</td><td>BKP_DeInit</td></tr><tr><td>函数原形</td><td>void BKP_DeInit(void)</td></tr><tr><td>功能描述</td><td>将外设BKP的全部寄存器重设为缺省值</td></tr><tr><td>输入参数</td><td>无</td></tr><tr><td>输出参数</td><td>无</td></tr><tr><td>返回值</td><td>无</td></tr><tr><td>先决条件</td><td>无</td></tr><tr><td>被调用函数</td><td>RCC_BackupResetCmd</td></tr></table>

例：  
/\*Reset the BKP registers \*/ BKP_DeInit();

# 5.2.2 函数BKP_TamperPinLevelConfig

Table 56. 描述了函数 BKP_TamperPinLevelConfig  
Table 56. 函数 BKP_TamperPinLevelConfig  

<table><tr><td>函数名</td><td>BKP_TamperPinLevelConfig</td></tr><tr><td>函数原形</td><td>void BKP_TamperPinLevelConfig(u16 BKP_TamperPinLevel)</td></tr><tr><td>功能描述</td><td>设置侵入检测管脚的有效电平</td></tr><tr><td>输入参数</td><td>BKP_TamperPinLevel: 侵入检测管脚的有效电平
参阅 Section: BKP_TamperPinLevel 查阅更多该参数允许取值范围</td></tr><tr><td>输出参数</td><td>无</td></tr><tr><td>返回值</td><td>无</td></tr><tr><td>先决条件</td><td>无</td></tr><tr><td>被调用函数</td><td>无</td></tr></table>

# BKP_TamperPinLevel

参数BKP_TamperPinLevel指定了侵入检测管脚的有效电平。它可以取下表中值：

Table 57. BKP_TamperPinLevel 值  

<table><tr><td>BKP_TamperPinLevel</td><td>描述</td></tr><tr><td>BKP_TamperPinLevel_High</td><td>侵入检测管脚高电平有效</td></tr><tr><td>BKP_TamperPinLevel_Low</td><td>侵入检测管脚低电平有效</td></tr></table>

例：  
/\* Configure Tamper pin to be active on high level\*/ BKP_TamperPinLevelConfig(BKP_TamperPinLevel_High);

# 5.2.3 函数BKP_TamperPinCmd

Table 58. 描述了函数 BKP_TamperPinCmd  
Table 58. 函数 BKP_TamperPinCmd  

<table><tr><td>函数名</td><td>BKP_TamperPinCmd</td></tr><tr><td>函数原形</td><td>void BKP_TamperPinCmd(FunctionalState NewState)</td></tr><tr><td>功能描述</td><td>使能或者失能管脚的侵入检测功能</td></tr><tr><td>输入参数</td><td>NewState: 侵入检测功能的新状态
这个参数可以取: ENABLE 或者 DISABLE</td></tr><tr><td>输出参数</td><td>无</td></tr><tr><td>返回值</td><td>无</td></tr><tr><td>先决条件</td><td>无</td></tr><tr><td>被调用函数</td><td>无</td></tr></table>

例：
/* Enable Tamper Pin functionality */
BKP_TamperPinCmd(ENABLE);

# 5.2.4 函数BKP_ITConfig

Table 59. 描述了函数 BKP_ITConfig  
Table 59. 函数 BKP_ITConfig  

<table><tr><td>函数名</td><td>BKP_ITConfig</td></tr><tr><td>函数原形</td><td>void BKP_ITConfig(FunctionalState NewState)</td></tr><tr><td>功能描述</td><td>使能或者失能侵入检测中断</td></tr><tr><td>输入参数</td><td>NewState: 侵入检测中断的新状态
这个参数可以取: ENABLE 或者 DISABLE</td></tr><tr><td>输出参数</td><td>无</td></tr><tr><td>返回值</td><td>无</td></tr><tr><td>先决条件</td><td>无</td></tr><tr><td>被调用函数</td><td>无</td></tr></table>

例：
/* Enable Tamper Pin interrupt */
BKP_ITConfig(ENABLE);

# 5.2.5 函数BKP_RTCOutputConfig

Table 60. 描述了函数 BKPRTOSOutputConfig

Table 60. 函数 BKP_RTCOutputConfig  

<table><tr><td>函数名</td><td>BKP_RTCOutputConfig</td></tr><tr><td>函数原形</td><td>void BKP_RTCOutputConfig(u16 BKP_RTCOutputSource)</td></tr><tr><td>功能描述</td><td>选择在侵入检测管脚上输出的RTC时钟源</td></tr><tr><td>输入参数</td><td>BKP_RTCOutputSource: 指定的RTC输出源
参阅 Section: BKP_RTCOutputSource 查阅更多该参数允许取值范围</td></tr><tr><td>输出参数</td><td>无</td></tr><tr><td>返回值</td><td>无</td></tr><tr><td>先决条件</td><td>调用该函数前必须失能管脚的侵入检测功能</td></tr><tr><td>被调用函数</td><td>无</td></tr></table>

# BKP_RTCOutputSource

参数BKP_RTCOutputSource用来选择RTC输出时钟源，它可以取下表中值：

Table 61. BKP_RTCOutputSource 值  

<table><tr><td>BKP_RTCOutputSource</td><td>描述</td></tr><tr><td>BKP_RTCOutputSource_None</td><td>侵入检测管脚上无RTC输出</td></tr><tr><td>BKP_RTCOutputSource_CalibClock</td><td>侵入检测管脚上输出,其时钟频率为RTC时钟除以64</td></tr><tr><td>BKP_RTCOutputSource_Alarm</td><td>侵入检测管脚上输出RTC闹钟脉冲</td></tr><tr><td>BKP_RTCOutputSource_Seond</td><td>侵入检测管脚上输出RTC秒脉冲</td></tr></table>

例：

/\* Output the RTC clock source with frequency divided by 64 on the Tamper pad(if the Tamper Pin functionality is disabled) \*/ BKP_RTCOutputConfig(BKP_RTCOutputSource_CalibClock);

# 5.2.6 函数BKP_SetRTCCalibrationValue

Table 62. 描述了函数 BKP_SetRTCCalibrationValue

Table 62. 函数 BKP_SetRTCCalibrationValue  

<table><tr><td>函数名</td><td>BKP_SetRTCCalibrationValue</td></tr><tr><td>函数原形</td><td>void BKP_SetRTCCalibrationValue(u8 CalibrationValue)</td></tr><tr><td>功能描述</td><td>设置RTC时钟校准值</td></tr><tr><td>输入参数</td><td>CalibrationValue: RTC时钟校准值
该参数允许取值范围为0到0x7F</td></tr><tr><td>输出参数</td><td>无</td></tr><tr><td>返回值</td><td>无</td></tr><tr><td>先决条件</td><td>无</td></tr><tr><td>被调用函数</td><td>无</td></tr></table>

例：

/\* Set RTC clock calibration value to 0x7F (maximum) \*/ BKP_SetRTCCalibrationValue(0x7F);

# 5.2.7 函数BKP_WritesBackupRegister

Table 63. 描述了函数 BKP_WritesBackupRegister  
Table 63. 函数 BKP_WritesBackupRegister  

<table><tr><td>函数名</td><td>BKP_WriteBackupRegister</td></tr><tr><td>函数原形</td><td>void BKP_WriteBackupRegister(u16 BKP_DR, u16 Data)</td></tr><tr><td>功能描述</td><td>向指定的后备寄存器中写入用户程序数据</td></tr><tr><td>输入参数1</td><td>BKP_DR: 数据后备寄存器
参阅 Section:BKP_DR 查阅更多该参数允许取值范围</td></tr><tr><td>输入参数2</td><td>Data: 待写入的数据</td></tr><tr><td>输出参数</td><td>无</td></tr><tr><td>返回值</td><td>无</td></tr><tr><td>先决条件</td><td>无</td></tr><tr><td>被调用函数</td><td>无</td></tr></table>

# BKP DR

参数BKP_DR用来选择数据后备寄存器，Table64.例举了该参数可取的值：

Table 64. BKP_DR 值  

<table><tr><td>BKP_DR</td><td>描述</td></tr><tr><td>BKP_DR1</td><td>选中数据寄存器1</td></tr><tr><td>BKP_DR2</td><td>选中数据寄存器2</td></tr><tr><td>BKP_DR3</td><td>选中数据寄存器3</td></tr><tr><td>BKP_DR4</td><td>选中数据寄存器4</td></tr><tr><td>BKP_DR5</td><td>选中数据寄存器5</td></tr><tr><td>BKP_DR6</td><td>选中数据寄存器6</td></tr><tr><td>BKP_DR7</td><td>选中数据寄存器7</td></tr><tr><td>BKP_DR8</td><td>选中数据寄存器8</td></tr><tr><td>BKP_DR9</td><td>选中数据寄存器9</td></tr><tr><td>BKP_DR10</td><td>选中数据寄存器10</td></tr></table>

例：

/* Write 0xA587 to Data Backup Register1 */

BKP_WritesBackupRegister(BKP_DR1, 0xA587);

# 5.2.8 函数BKPREADINGBackupRegister

Table 65. 描述了函数 BKPREADINGBackupRegister  
Table 65. 函数 BKPREADINGBackupRegister  

<table><tr><td>函数名</td><td>BKP_ReadBackupRegister</td></tr><tr><td>函数原形</td><td>u16 BKP_ReadBackupRegister(u16 BKP_DR)</td></tr><tr><td>功能描述</td><td>从指定的后备寄存器中读出数据</td></tr><tr><td>输入参数</td><td>BKP_DR: 数据后备寄存器
参阅 Section:BKP_DR 查阅更多该参数允许取值范围</td></tr><tr><td>输出参数</td><td>无</td></tr><tr><td>返回值</td><td>指定的后备寄存器中的数据</td></tr><tr><td>先决条件</td><td>无</td></tr><tr><td>被调用函数</td><td>无</td></tr></table>

例：

/* Read Data Backup Register1 */

# ST

译文英文原版为UM0427 Oct. 2007 Rev 2, 译文仅供参考，与英文版冲突的，以英文版为准

```txt
u16 Data;  
Data = BKPREADINGBackupRegister(BKP_DR1);
```

# 5.2.9 函数BKP_GetFlagStatus

Table 66. 描述了函数 BKP_GetFlagStatus  
Table 66. 函数 BKP_GetFlagStatus  

<table><tr><td>函数名</td><td>BKP_GetFlagStatus</td></tr><tr><td>函数原形</td><td>FlagStatus BKP_GetFlagStatus(void)</td></tr><tr><td>功能描述</td><td>检查侵入检测管脚事件的标志位被设置与否</td></tr><tr><td>输入参数</td><td>无</td></tr><tr><td>输出参数</td><td>无</td></tr><tr><td>返回值</td><td>检查侵入检测管脚事件的标志位的新状态（SET或者RESET）</td></tr><tr><td>先决条件</td><td>无</td></tr><tr><td>被调用函数</td><td>无</td></tr></table>

```txt
例：
/* Test if the Tamper Pin Event flag is set or not */
FlagStatus Status;
Status = BKP_GetFlagStatus();
if (Status == RESET)
{
...
} else
{
...
}
```

# 5.2.10 函数BKP_ClearFlag

Table 67. 描述了函数 BKP_ClearFlag  
Table 67. 函数 BKP_ClearFlag  

<table><tr><td>函数名</td><td>BKP_ClearFlag</td></tr><tr><td>函数原形</td><td>void BKP_ClearFlag(void)</td></tr><tr><td>功能描述</td><td>清除侵入检测管脚事件的待处理标志位</td></tr><tr><td>输入参数</td><td>无</td></tr><tr><td>输出参数</td><td>无</td></tr><tr><td>返回值</td><td>无</td></tr><tr><td>先决条件</td><td>无</td></tr><tr><td>被调用函数</td><td>无</td></tr></table>

例：

```txt
/\* Clear Tamper Pin Event pending flag \*/ BKP_ClearFlag();
```

# 5.2.11 函数BKP_GetITStatus

Table 68. 描述了函数 BKP_GetITStatus  
Table 68. 函数 BKP_GetITStatus  

<table><tr><td>函数名</td><td>BKP_GetITStatus</td></tr><tr><td>函数原形</td><td>ITStatus BKP_GetITStatus(void)</td></tr><tr><td>功能描述</td><td>检查侵入检测中断发生与否</td></tr><tr><td>输入参数</td><td>无</td></tr><tr><td>输出参数</td><td>无</td></tr><tr><td>返回值</td><td>检查检查侵入检测中断标志位的新状态（SET或者RESET）</td></tr><tr><td>先决条件</td><td>无</td></tr><tr><td>被调用函数</td><td>无</td></tr></table>

```lua
例：
/* Test if the Tamper Pin interrupt has occurred or not */
ITStatus Status;
Status = BKP_GetITStatus();
if (Status == RESET)
{
...
} else
{
...
}
```

# 5.2.12 函数BKP_ClearITPendingBit

Table 69. 描述了函数 BKP_ClearITPendingBit  
Table 69. 函数 BKP_ClearITPendingBit  

<table><tr><td>函数名</td><td>BKP_ClearITPendingBit</td></tr><tr><td>函数原形</td><td>void BKP_ClearITPendingBit(void)</td></tr><tr><td>功能描述</td><td>清除侵侵入检测中断的待处理位</td></tr><tr><td>输入参数</td><td>无</td></tr><tr><td>输出参数</td><td>无</td></tr><tr><td>返回值</td><td>无</td></tr><tr><td>先决条件</td><td>无</td></tr><tr><td>被调用函数</td><td>无</td></tr></table>

例：

```txt
/\* Clear Tamper Pin interrupt pending bit \*/ BKP_ClearITPendingBit();
```

# 6 控制器局域网（CAN）

本外设作为CAN网络的界面，支持CAN协议2.0A和2.0B。它的设计目标是，以最小的CPU负荷来高效处理大量收到的报文。它也支持报文发送的优先级要求（优先级特性可软件配置）。

Section 6.1 描述了 CAN 固件函数库所使用的数据结构，Section 6.2 固件库函数介绍了函数库里的所有函数。

# 6.1 CAN寄存器结构

CAN 寄存器结构，CAN_TYPEDef，在文件“stm32f10x_map.h”中定义如下：

```c
typedef struct   
{ vu32 MCR; vu32 MSR; vu32 TSR; vu32 RF0R; vu32 RF1R; vu32 IER; vu32 ESR; vu32 BTR; u32 RESERVED0 [88]; CAN_TxMailBox_TYPEDef sTxMailBox[3]; CAN_FIFOMailBox_TYPEDef sFIFOMailBox[2]; u32 RESERVED1 [12]; vu32 FMR; vu32 FMOR; u32 RESERVED2 [1]; vu32 FS0R; u32 RESERVED3 [1]; vu32 FFA0R; u32 RESERVED4 [1]; vu32 FA0R; u32 RESERVED5 [8]; CAN_FilterRegister_TYPEDef sFilterRegister[14]; }CAN_TYPEDef; typedef struct { vu32 TIR; vu32 TDTR; vu32 TDLR; vu32 TDHR; } CAN_TxMailBox_TYPEDef; typedef struct { vu32 RIR; vu32 RDTR; vu32 RDLR; vu32 RDHR; } CAN_FIFOMailBox_TYPEDef; typedef struct { vu32 FR0; vu32 FR1; } CAN_FilterRegister_TYPEDef;
```

Table 70. 给出了 CAN 的寄存器列表:  
Table 70. CAN 寄存器  

<table><tr><td>寄存器</td><td>描述</td></tr><tr><td>CAN_MCR</td><td>CAN主控制寄存器</td></tr><tr><td>CAN_MSB</td><td>CAN主状态寄存器</td></tr><tr><td>CAN_TSR</td><td>CAN发送状态寄存器</td></tr><tr><td>CAN_RF0R</td><td>CAN接收FIFO0寄存器</td></tr><tr><td>CAN_RF1R</td><td>CAN接收FIFO1寄存器</td></tr><tr><td>CAN_IER</td><td>CAN中断允许寄存器</td></tr><tr><td>CAN_ESR</td><td>CAN错误状态寄存器</td></tr><tr><td>CAN_BTR</td><td>CAN位时间特性寄存器</td></tr><tr><td>TIR</td><td>发送邮箱标识符寄存器</td></tr><tr><td>TDTR</td><td>发送邮箱数据长度和时间戳寄存器</td></tr><tr><td>TDLR</td><td>发送邮箱低字节数据寄存器</td></tr><tr><td>TDHR</td><td>发送邮箱高字节数据寄存器</td></tr><tr><td>RIR</td><td>接收FIFO邮箱标识符寄存器</td></tr><tr><td>RDTR</td><td>接收FIFO邮箱数据长度和时间戳寄存器</td></tr><tr><td>RDLR</td><td>接收FIFO邮箱低字节数据寄存器</td></tr><tr><td>RDHR</td><td>接收FIFO邮箱高字节数据寄存器</td></tr><tr><td>CAN_FMR</td><td>CAN过滤器主控寄存器</td></tr><tr><td>CAN_FMOR</td><td>CAN过滤器模式寄存器</td></tr><tr><td>CAN_FSCOR</td><td>CAN过滤器位宽寄存器</td></tr><tr><td>CAN_FFAOR</td><td>CAN过滤器FIFO关联寄存器</td></tr><tr><td>CAN_FAOR</td><td>CAN过滤器激活寄存器</td></tr><tr><td>CAN_FR0</td><td>过滤器组0寄存器</td></tr><tr><td>CAN_FR1</td><td>过滤器组1寄存器</td></tr></table>

CAN外设同时在文件“stm32f10x_map.h”中声明如下：

```m4
define PERIPH_BASE((u32)0x40000000)
#define APB1PERIPH_BASE PERIPH_BASE
#define APB2PERIPH_BASE (PERIPH_BASE + 0x10000)
#define AHBPERIPH_BASE (PERIPH_BASE + 0x20000)
#define CAN_BASE (APB1PERIPH_BASE + 0x6400)
#ifndef DEBUG
...
#ifndef_CAN
#define CAN ((CAN_TYPEDef *) CAN_BASE)
#include /*_CAN */
...
else /* DEBUG */
...
#ifndef_CAN
EXT CAN_TYPEDef *CAN;
#include /*_CAN */
...
endif
```

使用Debug模式时，初始化CAN指针于文件“stm32f10x_lib.c”：

```c
#ifndef CAN
CAN = (CAN_TYPEDef *) CAN_BASE;
#endif /*_CAN*/
```

为了访问CAN寄存器，,_CAN必须在文件“stm32f10x_conf.h”中定义如下：

```txt
define CAN
```

# 6.2 CAN库函数

Table 71. 例举了 CAN 的库函数  
Table 71. CAN 库函数  

<table><tr><td>函数名</td><td>描述</td></tr><tr><td>CAN_DeInit</td><td>将外设CAN的全部寄存器重设为缺省值</td></tr><tr><td>CAN_Init</td><td>根据CAN_InitStruct中指定的参数初始化外设CAN的寄存器</td></tr><tr><td>CAN_FilterInit</td><td>根据CAN_FilterInitStruct中指定的参数初始化外设CAN的寄存器</td></tr><tr><td>CANSTRUCTInit</td><td>把CAN_InitStruct中的每一个参数按缺省值填入</td></tr><tr><td>CAN_ITConfig</td><td>使能或者失能指定的CAN中断</td></tr><tr><td>CAN_Transmit</td><td>开始一个消息的传输</td></tr><tr><td>CAN_TransmitStatus</td><td>检查消息传输的状态</td></tr><tr><td>CAN_CancelTransmit</td><td>取消一个传输请求</td></tr><tr><td>CAN_FIFORelease</td><td>释放一个FIFO</td></tr><tr><td>CAN_MessagePending</td><td>返回挂号的信息数量</td></tr><tr><td>CAN_Receive</td><td>接收一个消息</td></tr><tr><td>CAN_Sleep</td><td>使CAN进入低功耗模式</td></tr><tr><td>CAN_WakeUp</td><td>将CAN唤醒</td></tr><tr><td>CAN_GetFlagStatus</td><td>检查指定的CAN标志位被设置与否</td></tr><tr><td>CAN_ClearFlag</td><td>清除CAN的待处理标志位</td></tr><tr><td>CAN_GetITStatus</td><td>检查指定的CAN中断发生与否</td></tr><tr><td>CAN_ClearITPendingBit</td><td>清除CAN的中断待处理标志位</td></tr></table>

# 6.2.1 函数CAN_DeInit

Table 72. 描述了函数 CAN_DeInit  
Table 72. 函数 CAN_DeInit  

<table><tr><td>函数名</td><td>CAN_DeInit</td></tr><tr><td>函数原形</td><td>void CAN_DeInit(void)</td></tr><tr><td>功能描述</td><td>将外设CAN的全部寄存器重设为缺省值</td></tr><tr><td>输入参数</td><td>无</td></tr><tr><td>输出参数</td><td>无</td></tr><tr><td>返回值</td><td>无</td></tr><tr><td>先决条件</td><td>无</td></tr><tr><td>被调用函数</td><td>RCC_AP1PeriphResetCmd()</td></tr></table>

例：

/\*Deinitialize the CAN \*/ CAN_DeInit();

# 6.2.2 函数CAN_Init

Table 73. 描述了函数 CAN_Init  
Table 73. 函数 CAN_Init  

<table><tr><td>函数名</td><td>CAN_Init</td></tr><tr><td>函数原形</td><td>u8 CAN_Init(CAN_InitTypeDef* CAN_InitStruct)</td></tr><tr><td>功能描述</td><td>根据 CAN_InitStruct 中指定的参数初始化外设 CAN 的寄存器</td></tr><tr><td>输入参数</td><td>CAN_InitStruct: 指向结构 CAN_InitTypeDef 的指针, 包含了指定外设 CAN 的配置信息
参阅: Section: CAN_InitTypeDef 查阅更多该参数允许取值范围</td></tr><tr><td>输出参数</td><td>无</td></tr><tr><td>返回值</td><td>指示 CAN 初始化成功的常数
CANINITFAILED = 初始化失败
CANINITOK = 初始化成功</td></tr><tr><td>先决条件</td><td>无</td></tr><tr><td>被调用函数</td><td>无</td></tr></table>

# CAN_InitTypeDef structure

CAN_InitTypeDef 定义于文件“stm32f10x_CAN.h”：

```txt
typedef struct  
{  
FunctionnalState CAN_TTCM;  
FunctionnalState CAN_ABOM;  
FunctionnalState CAN_AWUM;  
FunctionnalState CAN_NART;  
FunctionnalState CAN_RFLM;  
FunctionnalState CAN_TXFP;  
u8 CAN_Mode;  
u8 CAN_SJW;  
u8 CAN_BS1;  
u8 CAN_BS2;  
u16 CAN_Prescaler;  
} CAN_InitTypeDef;
```

# CAN_TTCM

CAN_TTCM用来使能或者失能时间触发通讯模式，可以设置这个参数的值为ENABLE或者DISABLE。

# CAN_ABOM

CAN_ABOM 用来使能或者失能自动离线管理，可以设置这个参数的值为 ENABLE 或者 DISABLE。

# CAN_AWUM

CAN_AWUM 用来使能或者失能自动唤醒模式，可以设置这个参数的值为 ENABLE 或者 DISABLE。

# CAN_NART

CAN_NARM 用来使能或者失能非自动重传输模式，可以设置这个参数的值为 ENABLE 或者 DISABLE。

# CAN_RFLM

CAN_RFLM用来使能或者失能接收FIFO锁定模式，可以设置这个参数的值为ENABLE或者DISABLE。

# CAN_TXFP

CAN_TXFP用来使能或者失能发送FIFO优先级，可以设置这个参数的值为ENABLE或者DISABLE。

# CAN Mode

CAN_Mode 设置了 CAN 的工作模式，Table 74.给出了该参数可取的值

Table 74. CAN_Mode 值  

<table><tr><td>CAN_Mode</td><td>描述</td></tr><tr><td>CAN_Mode_Normal</td><td>CAN 硬件工作在正常模式</td></tr><tr><td>CAN_Mode_Silent</td><td>CAN 硬件工作在静默模式</td></tr><tr><td>CAN_Mode_LoopBack</td><td>CAN 硬件工作在环回模式</td></tr><tr><td>CAN_Mode_Silent_LoopBack</td><td>CAN 硬件工作在静默环回模式</td></tr></table>

# CAN_SJW

CAN_SJW 定义了重新同步跳跃宽度(SJW)，即在每位中可以延长或缩短多少个时间单位的上限，Table 75. 给出了该参数可取的值

Table 75. CAN_SJW 值  

<table><tr><td>CAN_SJW</td><td>描述</td></tr><tr><td>CAN_SJW_1tq</td><td>重新同步跳跃宽度 1 个时间单位</td></tr><tr><td>CAN_SJW_2tq</td><td>重新同步跳跃宽度 2 个时间单位</td></tr><tr><td>CAN_SJW_3tq</td><td>重新同步跳跃宽度 3 个时间单位</td></tr><tr><td>CAN_SJW_4tq</td><td>重新同步跳跃宽度 4 个时间单位</td></tr></table>

# CAN_BS1

CAN_BS1 设定了时间段 1 的时间单位数目，Table 76.给出了该参数可取的值

Table 76. CAN_BS1 值  

<table><tr><td>CAN_BS1</td><td>描述</td></tr><tr><td>CAN_BS1_1tq</td><td>时间段1为1个时间单位</td></tr><tr><td>...</td><td>...</td></tr><tr><td>CAN_BS1_16tq</td><td>时间段1为16个时间单位</td></tr></table>

# CAN_BS2

CAN_BS2 设定了时间段 1 的时间单位数目，Table 77.给出了该参数可取的值

Table 77. CAN_BS1 值  

<table><tr><td>CAN_BS1</td><td>描述</td></tr><tr><td>CAN_BS2_1tq</td><td>时间段2为1个时间单位</td></tr><tr><td>...</td><td>...</td></tr><tr><td>CAN_BS2_8tq</td><td>时间段2为8个时间单位</td></tr></table>

# CAN_Prescaler

CAN_Prescaler 设定了一个时间单位的长度，它的范围是 1 到 1024。

例：

```txt
/\* Initialize the CAN as 1Mb/s in normal mode, receive FIFO locked: \*/   
CAN_InitTypeDef CAN_InitStructure;   
CAN_InitStructure.CAN_TTCM  $=$  DISABLE;   
CAN_InitStructure.CAN_ABOM  $=$  DISABLE;   
CAN_InitStructure.CAN_AWUM  $=$  DISABLE;   
CAN_InitStructure.CAN_NART  $=$  DISABLE;   
CAN_InitStructure.CAN_RFLM  $=$  ENABLE;   
CAN_InitStructure.CAN_TXFP  $=$  DISABLE;   
CAN_InitStructure.CAN_Mode  $=$  CAN_Mode_Normal;   
CAN_InitStructure.CAN_BS1  $=$  CAN_BS1_4tq;   
CAN_InitStructure.CAN_BS2  $=$  CAN_BS2_3tq;   
CAN_InitStructure.CAN_Prescaler  $= 0$  .   
CAN_Init(&CAN_InitStructure);
```

# 6.2.3 函数CAN_FilterInit

Table 78. 描述了函数 CAN_FilterInit

Table 78. 函数 CAN_FilterInit  

<table><tr><td>函数名</td><td>CAN_DeInit</td></tr><tr><td>函数原形</td><td>void CAN_FilterInit(CAN_FilterInitTypeDef* CAN_FilterInitStruct)</td></tr><tr><td>功能描述</td><td>根据 CAN_FilterInitStruct 中指定的参数初始化外设 CAN 的寄存器</td></tr><tr><td>输入参数</td><td>CAN_FilterInitStruct: 指向结构 CAN_FilterInitTypeDef 的指针, 包含了相关配置信息参阅: Section: CAN_FilterInitTypeDef 结构查阅更多该参数允许取值范围</td></tr><tr><td>输出参数</td><td>无</td></tr><tr><td>返回值</td><td>无</td></tr><tr><td>先决条件</td><td>无</td></tr><tr><td>被调用函数</td><td>无</td></tr></table>

# CAN_FilterInitTypeDef structure

CAN_FilterInitTypeDef 定义于文件“stm32f10x_can.h”：

```c
typedef struct   
{   
u8 CAN_FilterNumber;   
u8 CAN_FilterMode;   
u8 CAN_FilterScale;   
u16 CAN_FilterIdHigh;   
u16 CAN_FilterIdLow;   
u16 CAN_FilterMaskIdHigh;   
u16 CAN_FilterMaskIdLow;   
u16 CAN_FilterFIFOAssignment;   
FunctionalState CAN_FilterActivation; }CAN_FilterInitTypeDef;
```

# CAN_FilterNumber

CAN_FilterNumber 指定了待初始化的过滤器，它的范围是 1 到 13。

# CAN_FilterMode

CAN_FilterMode 指定了过滤器将被初始化到的模式。Table 79. 给出了该参数可取的值

Table 79. CAN_FilterMode 值  

<table><tr><td>CAN_FilterMode</td><td>描述</td></tr><tr><td>CAN_FilterMode_IdMask</td><td>标识符屏蔽位模式</td></tr><tr><td>CAN_FilterMode_IdList</td><td>标识符列表模式</td></tr></table>

# CAN_FilterScale

CAN_FilterScale 给出了过滤器位宽，Table 80. 给出了该参数可取的值

Table 80. CAN_FilterScale 值  

<table><tr><td>CAN_FilterScale</td><td>描述</td></tr><tr><td>CAN_FilterScale_Two16bit</td><td>2个16位过滤器</td></tr><tr><td>CAN_FilterScale_One32bit</td><td>1个32位过滤器</td></tr></table>

# CAN_FilterIdHigh

CAN_FilterIdHigh 用来设定过滤器标识符（32 位位宽时为其高段位，16 位位宽时为第一个）。它的范围是 0x0000 到 0xFFFF。

# CAN_FilterIdLow

CAN_FilterIdHigh 用来设定过滤器标识符（32 位位宽时为其低段位，16 位位宽时为第二个）。它的范围是  $0 \times 0000$  到  $0 \times FFFF$ 。

# CAN_FilterMaskIdHigh

CAN_FilterMaskIdHigh用来设定过滤器屏蔽标识符或者过滤器标识符（32位位宽时为其高段位，16位位

ST

75/368

译文英文原版为UM0427 Oct. 2007 Rev 2, 译文仅供参考，与英文版冲突的，以英文版为准

宽时为第一个)。它的范围是0x0000到0xFFFF。

# CAN_FilterMaskIdLow

CAN_FilterMaskIdLow 用来设定过滤器屏蔽标识符或者过滤器标识符（32 位位宽时为其低段位，16 位位宽时为第二个）。它的范围是  $0 \times 0000$  到  $0 \times \mathrm{FFFF}$ 。

# CAN_FilterFIFO

CAN_FilterFIFO 设定了指向过滤器的 FIFO（0 或 1），Table 81. 给出了该参数可取的值

Table 81. CAN_FilterFIFO 值  

<table><tr><td>CAN_FilterFIFO</td><td>描述</td></tr><tr><td>CAN_FilterFIFO0</td><td>过滤器 FIFO0 指向过滤器 x</td></tr><tr><td>CAN_FilterFIFO1</td><td>过滤器 FIFO1 指向过滤器 x</td></tr></table>

# CAN_FilterActivation

CAN_FilterActivation使能或者失能过滤器。该参数可取的值为ENABLE或者DISABLE。

例：

```c
/\* Initialize the CAN filter 2 \*/   
CAN_FilterInitTypeDef CAN_FilterInitStructure;   
CAN_FilterInitStructure.CAN_FilterNumber  $= 2$  .   
CAN_FilterInitStructure.CAN_FilterMode  $=$  CAN_FilterMode_IdMask;   
CAN_FilterInitStructure.CAN_FilterScale  $=$  CAN_FilterScale_One32bit;   
CAN_FilterInitStructure.CAN_FilterIdHigh  $= 0\mathrm{x}\overline{0}\mathrm{F}0\mathrm{F}$  .   
CAN_FilterInitStructure.CAN_FilterIdLow  $= 0\mathrm{x}\overline{\mathrm{F}} 0\mathrm{F}0$  .   
CAN_FilterInitStructure.CAN_FilterMaskIdHigh  $= 0\mathrm{x}\overline{\mathrm{F}} 000$  .   
CAN_FilterInitStructure.CAN_FilterMaskIdLow  $= 0\mathrm{x}00\mathrm{FF}$  .   
CAN_FilterInitStructure.CAN_FilterFIFO  $=$  CAN_FilterFIFO00;   
CAN_FilterInitStructure.CAN_FilterActivation  $=$  ENABLE;   
CAN_FilterInit(&CAN_InitStructure);
```

# 6.2.4 函数CANSTRUCTInit

Table 82. 描述了函数 CANSTRUCTInit  
Table 82. 函数 CANSTRUCTInit  

<table><tr><td>函数名</td><td>CANSTRUCTInit</td></tr><tr><td>函数原形</td><td>void CANSTRUCTInit(CAN_InitTypeDef* CAN_InitStruct)</td></tr><tr><td>功能描述</td><td>把 CAN_InitStruct 中的每一个参数按缺省值填入</td></tr><tr><td>输入参数</td><td>CAN_InitStruct: 指向待初始化结构 CAN_InitTypeDef 的指针
参阅 Table 83. 查阅该结构成员缺省值</td></tr><tr><td>输出参数</td><td>无</td></tr><tr><td>返回值</td><td>无</td></tr><tr><td>先决条件</td><td>无</td></tr><tr><td>被调用函数</td><td>无</td></tr></table>

Table 83. CAN_InitStruct 结构缺省值  

<table><tr><td>成员</td><td>缺省值</td></tr><tr><td>CAN_TTCM</td><td>DISABLE</td></tr><tr><td>CAN_ABOM</td><td>DISABLE</td></tr><tr><td>CAN_AWUM</td><td>DISABLE</td></tr><tr><td>CAN_NART</td><td>DISABLE</td></tr><tr><td>CAN_RFLM</td><td>DISABLE</td></tr><tr><td>CAN_TXFP</td><td>DISABLE</td></tr><tr><td>CAN_Mode</td><td>CAN_Mode_Normal</td></tr><tr><td>CAN_SJW</td><td>CAN_SJW_1tq</td></tr><tr><td>CAN_BS1</td><td>CAN_BS1_4tq</td></tr><tr><td>CAN_BS2</td><td>CAN_BS2_3tq</td></tr><tr><td>CAN_Prescaler</td><td>1</td></tr></table>

例：  
/* Initialize a CAN_InitTypeDef structure. */  
CAN_InitTypeDef CAN_InitStructure;  
CANSTRUCTInit(&CAN_InitStructure);

# 6.2.5 函数CAN_ITConfig

Table 84. 描述了函数 CAN_ITConfig

Table 84. 函数 CAN_ITConfig  

<table><tr><td>函数名</td><td>CAN_ITConfig</td></tr><tr><td>函数原形</td><td>void CAN_ITConfig(u32 CAN_IT, FunctionalState NewState)</td></tr><tr><td>功能描述</td><td>使能或者失能指定的 CAN 中断</td></tr><tr><td>输入参数 1</td><td>CAN_IT: 待使能或者失能的 CAN 中断
参阅 Section: CAN_IT 查阅更多该参数允许取值范围</td></tr><tr><td>输入参数 2</td><td>NewState: CAN 中断的新状态
这个参数可以取: ENABLE 或者 DISABLE</td></tr><tr><td>输出参数</td><td>无</td></tr><tr><td>返回值</td><td>无</td></tr><tr><td>先决条件</td><td>无</td></tr><tr><td>被调用函数</td><td>无</td></tr></table>

# CAN IT

输入参数CAN_IT为待使能或者失能的CAN中断。可以使用下表中的一个参数，或者他们的组合。

Table 85. CAN_IT 值  

<table><tr><td>CAN_IT</td><td>描述</td></tr><tr><td>CAN_IT_TME</td><td>发送邮箱空中断屏蔽</td></tr><tr><td>CAN_IT_FMP0</td><td>FIFO0 消息挂号中断屏蔽</td></tr><tr><td>CAN_IT_FF0</td><td>FIFO0 满中断屏蔽</td></tr><tr><td>CAN_IT_FOV0</td><td>FIFO0 溢出中断屏蔽</td></tr><tr><td>AN_IT_FMP1</td><td>FIFO1 消息挂号中断屏蔽</td></tr><tr><td>CAN_IT_FF1</td><td>FIFO1 满中断屏蔽</td></tr><tr><td>CAN_IT_FOV1</td><td>FIFO1 溢出中断屏蔽</td></tr><tr><td>CAN_IT_EWG</td><td>错误警告中断屏蔽</td></tr><tr><td>CAN_IT_EPV</td><td>错误被动中断屏蔽</td></tr><tr><td>CAN_IT_BOF</td><td>离线中断屏蔽</td></tr><tr><td>CAN_IT_LEC</td><td>上次错误号中断屏蔽</td></tr><tr><td>CAN_IT_ERR</td><td>错误中断屏蔽</td></tr><tr><td>CAN_IT_WKU</td><td>唤醒中断屏蔽</td></tr><tr><td>CAN_IT_SLK</td><td>睡眠标志位中断屏蔽</td></tr></table>

例：

/\*EnableCANFIFO0 overruninterrupt\*/ CAN_ITConfig(CAN_IT_FOV0，ENABLE);

# 6.2.6 函数CAN_Transmit

Table 86. 描述了函数 CAN_Transmit  
Table 86. 函数 CAN_Transmit  

<table><tr><td>函数名</td><td>CAN_Transmit</td></tr><tr><td>函数原形</td><td>u8 CAN_Transmit(CanTxCMsg* TxMessage)</td></tr><tr><td>功能描述</td><td>开始一个消息的传输</td></tr><tr><td>输入参数</td><td>TxMessage: 指向某结构的指针, 该结构包含 CAN id, CAN DLC 和 CAN data</td></tr><tr><td>输出参数</td><td>无</td></tr><tr><td>返回值</td><td>所使用邮箱的号码, 如果没有空邮箱返回 CAN_NO_MB</td></tr><tr><td>先决条件</td><td>无</td></tr><tr><td>被调用函数</td><td>无</td></tr></table>

# CanTxDmsg

结构CanTxMsg定义于文件“stm32f10x_can.h”：

```txt
typedef str
{
u32 StdId;
u32 ExtId;
u8 IDE;
u8 RTR;
u8 DLC;
u8 Data[8];
} CanTxMsg;
```

# StdId

StdId 用来设定标准标识符。它的取值范围为 0 到 0x7FF

# ExtId

ExtId 用来设定扩展标识符。它的取值范围为 0 到 0x3FFFF

# IDE

IDE用来设定消息标识符的类型，Table87.给出了该参数可取的值

Table 87. IDE 值  

<table><tr><td>IDE</td><td>描述</td></tr><tr><td>CAN_ID_STD</td><td>使用标准标识符</td></tr><tr><td>CAN_ID_EXT</td><td>使用标准标识符 + 扩展标识符</td></tr></table>

# RTR

RTR用来设定待传输消息的帧类型。它可以设置为数据帧或者远程帧。

Table 88. RTR 值  

<table><tr><td>RTR</td><td>描述</td></tr><tr><td>CAN_RTR_DATA</td><td>数据帧</td></tr><tr><td>CAN_RTR remot</td><td>远程帧</td></tr></table>

# DLC

DLC用来设定待传输消息的帧长度。它的取值范围是0到  $0\mathrm{x}8$

# Data[8]

Data[8]包含了待传输数据，它的取值范围为0到0xFF。

# 例：

```txt
/\* Send a message with the CAN \*/ CanTxMsg TxMessage;   
TxMessage.Id = 0x1F;   
TxMessage.ExtId  $=$  0x00;
```

# ST

译文英文原版为UM0427 Oct. 2007 Rev 2, 译文仅供参考，与英文版冲突的，以英文版为准

```txt
TxMessage.IDE = CAN_ID_STD;  
TxMessage.RTR = CAN_RTR_DATA;  
TxMessage.DLC = 2;  
TxMessage.Data[0] = 0xAA;  
TxMessage.Data[1] = 0x55;  
CAN_Transmit(&TxMessage);
```

# 6.2.7 函数CAN_TransmitStatus

Table 89. 描述了函数 CAN_TransmitStatus  
Table 89. 函数 CAN_TransmitStatus  

<table><tr><td>函数名</td><td>CAN_TransmitStatus</td></tr><tr><td>函数原形</td><td>u8 CAN_TransmitStatus(u8 TransmitMailbox)</td></tr><tr><td>功能描述</td><td>检查消息传输的状态</td></tr><tr><td>输入参数</td><td>TransmitMailbox: 用来传输的邮箱号码</td></tr><tr><td>输出参数</td><td>无</td></tr><tr><td>返回值</td><td>CANTXOK CAN 驱动是否在传输数据
CANTXPENDING 消息是否挂号
CANTXFAILED 其他</td></tr><tr><td>先决条件</td><td>传输进行中</td></tr><tr><td>被调用函数</td><td>无</td></tr></table>

```c
例：  
/* Check the status of a transmission with the CAN */ CanTxMsg TxMessage;  
...  
switch(CAN_TransmitStatus(CAN_Transmit(&TxMessage)) {  
    case CANTXOK: ...; break;  
}
```

# 6.2.8 函数CAN_CancelTransmit

Table 90. 描述了函数 CAN_CancelTransmit  
Table 90. 函数 CAN_CancelTransmit  

<table><tr><td>函数名</td><td>CAN_CancelTransmit</td></tr><tr><td>函数原形</td><td>void CAN_CancelTransmit(u8 Mailbox)</td></tr><tr><td>功能描述</td><td>取消一个传输请求</td></tr><tr><td>输入参数</td><td>邮箱号码</td></tr><tr><td>输出参数</td><td>无</td></tr><tr><td>返回值</td><td>无</td></tr><tr><td>先决条件</td><td>传输挂号于某邮箱</td></tr><tr><td>被调用函数</td><td>无</td></tr></table>

```c
例：
/* Cancel a CAN transmit initiates by CANTransmit */
u8 MBNumber;
CanTxCMsg TxMessage;
MBNumber = CAN_Transmit(&TxMessage);
if (CAN_TransmitStatus(MBNumber) == CANTXPENDING)
{
CAN_CancelTransmit(MBNumber);
}
```

# 6.2.9 函数CAN_FIFORElease

Table 91. 描述了函数 CAN_FIFORElease  
Table 91. 函数 CAN_FIFORelease  

<table><tr><td>函数名</td><td>CAN_FIFORelease</td></tr><tr><td>函数原形</td><td>void CAN_FIFORelease(u8 FIFONumber)</td></tr><tr><td>功能描述</td><td>释放一个 FIFO</td></tr><tr><td>输入参数</td><td>FIFO number: 接收 FIFO, CANFIFO0 或者 CANFIFO0</td></tr><tr><td>输出参数</td><td>无</td></tr><tr><td>返回值</td><td>无</td></tr><tr><td>先决条件</td><td>无</td></tr><tr><td>被调用函数</td><td>无</td></tr></table>

例：  
/* Release FIFO 0*/  
CAN_FIFORElease(CANFIFO00);

# 6.2.10 函数CAN_MessagePending

Table 92. 描述了函数 CAN_MessagePending  
Table 92. 函数 CAN_MessagePending  

<table><tr><td>函数名</td><td>CAN_MessagePending</td></tr><tr><td>函数原形</td><td>u8 CAN_MessagePending(u8 FIFONumber)</td></tr><tr><td>功能描述</td><td>返回挂号的信息数量</td></tr><tr><td>输入参数</td><td>FIFO number: 接收 FIFO, CANFIFO0 或者 CANFIFO0</td></tr><tr><td>输出参数</td><td>无</td></tr><tr><td>返回值</td><td>NbMessage 为挂号的信息数量</td></tr><tr><td>先决条件</td><td>无</td></tr><tr><td>被调用函数</td><td>无</td></tr></table>

例：  
/* Check the number of pending messages for FIFO 0*/  
u8 MessagePending = 0;  
MessagePending = CAN_MessagePending(CANFIFO00);

# 6.2.11 函数CAN_Receive

Table 93. 描述了函数 CAN_Receive  
Table 93. 函数 CAN_Receive  

<table><tr><td>函数名</td><td>CAN_Receive</td></tr><tr><td>函数原形</td><td>void CAN_Receive(u8 FIFONumber, CanRxMsg* RxMessage)</td></tr><tr><td>功能描述</td><td>接收一个消息</td></tr><tr><td>输入参数</td><td>FIFO number: 接收 FIFO, CANFIFO0 或者 CANFIFO0</td></tr><tr><td>输出参数</td><td>RxMessage: 指向某结构的指针, 该结构包含 CAN id, CAN DLC 和 CAN data。</td></tr><tr><td>返回值</td><td>无</td></tr><tr><td>先决条件</td><td>无</td></tr><tr><td>被调用函数</td><td>无</td></tr></table>

# CanRxMsg

结构CanRxMsg定义于文件“stm32f10x_can.h”：

```txt
typedef struct   
{   
u32 StdId;   
u32 ExtId;   
u8 IDE;   
u8 RTR;   
u8 DLC;   
u8 Data[8];   
u8 FMI;   
} CanRxMsg;
```

# StdId

StdId 用来设定标准标识符。它的取值范围为 0 到 0x7FF

# ExtId

ExtId 用来设定扩展标识符。它的取值范围为 0 到 0x3FFFF

# IDE

IDE用来设定消息标识符的类型，Table87.给出了该参数可取的值

Table 94. IDE 值  

<table><tr><td>IDE</td><td>描述</td></tr><tr><td>CAN_ID_STD</td><td>使用标准标识符</td></tr><tr><td>CAN_ID_EXT</td><td>使用标准标识符 + 扩展标识符</td></tr></table>

# RTR

RTR用来设定待传输消息的帧类型。它可以设置为数据帧或者远程帧。

Table 95. RTR 值  

<table><tr><td>RTR</td><td>描述</td></tr><tr><td>CAN_RTR_DATA</td><td>数据帧</td></tr><tr><td>CAN_RTR remot</td><td>远程帧</td></tr></table>

# DLC

DLC用来设定待传输消息的帧长度。它的取值范围是0到  $0\mathrm{x}8$

# Data[8]

Data[8]包含了待传输数据，它的取值范围为0到0xFF。

# FMI

FMI 设定为消息将要通过的过滤器索引，这些消息存储于邮箱中。该参数取值范围 0 到 0xFF。

例：

```c
/\*Receive a message with the CAN \*/ CanRxMsg RxMessage;   
CAN_Receive(&RxMessage);
```

# ST

译文英文原版为UM0427 Oct. 2007 Rev 2, 译文仅供参考，与英文版冲突的，以英文版为准

# 6.2.12 函数CAN_Sleep

Table 96. 描述了函数 CAN_Sleep  
Table 96. 函数 CAN_Sleep  

<table><tr><td>函数名</td><td>CAN_Sleep</td></tr><tr><td>函数原形</td><td>u8 CAN_Sleep(void)</td></tr><tr><td>功能描述</td><td>使 CAN 进入低功耗模式</td></tr><tr><td>输入参数</td><td>无</td></tr><tr><td>输出参数</td><td>无</td></tr><tr><td>返回值</td><td>CANSLEEPOK 进入睡眠模式
CANSLEEPFAILED 其他</td></tr><tr><td>先决条件</td><td>无</td></tr><tr><td>被调用函数</td><td>无</td></tr></table>

例：  
/\*Enter the CAN sleep mode\*/ CAN_Sleep();

# 6.2.13 函数CAN_WakeUp

Table 97. 描述了函数 CAN_WakeUp  
Table 97. 函数 CAN_WakeUp  

<table><tr><td>函数名</td><td>CAN_WakeUp</td></tr><tr><td>函数原形</td><td>u8 CAN_WakeUp(void)</td></tr><tr><td>功能描述</td><td>将 CAN 唤醒</td></tr><tr><td>输入参数</td><td>无</td></tr><tr><td>输出参数</td><td>无</td></tr><tr><td>返回值</td><td>CANWAKEUPOK 退出睡眠模式
CANWAKEUPFAILDED 其他</td></tr><tr><td>先决条件</td><td>无</td></tr><tr><td>被调用函数</td><td>无</td></tr></table>

例：  
/\*CAN waking up \*/ CAN_WakeUp();

# 6.2.14 函数CAN_GetFlagStatus

Table 98. 描述了函数 CAN_GetFlagStatus  
Table 98. 函数 CAN_GetFlagStatus  

<table><tr><td>函数名</td><td>CAN_GetFlagStatus</td></tr><tr><td>函数原形</td><td>FlagStatus CAN_GetFlagStatus(u32 CAN_FLAG)</td></tr><tr><td>功能描述</td><td>检查指定的 CAN 标志位被设置与否</td></tr><tr><td>输入参数</td><td>CAN_FLAG: 待检查的 CAN 标志位
参阅 Section: CAN_FLAG 查阅更多该参数允许取值范围</td></tr><tr><td>输出参数</td><td>无</td></tr><tr><td>返回值</td><td>CAN_FLAG 的新状态 (SET 或者 RESET)</td></tr><tr><td>先决条件</td><td>无</td></tr><tr><td>被调用函数</td><td>无</td></tr></table>

# CAN_FLAG

CAN_FLAG 用来定义待检查的标志位类型。见 Table 99. 查阅更多 CAN_FLAG 取值描述

Table 99. CAN_FLAG 值  

<table><tr><td>CAN_FLAG</td><td>描述</td></tr><tr><td>CAN_FLAG_EWG</td><td>错误警告标志位</td></tr><tr><td>CAN_FLAG_EPV</td><td>错误被动标志位</td></tr><tr><td>CAN_FLAG_BOF</td><td>离线标志位</td></tr></table>

例：

/* Test if the CAN warning limit has been reached */

FlagStatus Status;

Status = CAN_GetFlagStatus(CAN_FLAG_EWG);

# 6.2.15 函数CAN_ClearFlag

Table 100. 描述了函数 CAN_ClearFlag  
Table 100. 函数 CAN_ClearFlag  

<table><tr><td>函数名</td><td>CAN_ClearFlag</td></tr><tr><td>函数原形</td><td>void CAN_ClearFlag(u32 CAN_Flag)</td></tr><tr><td>功能描述</td><td>清除CAN的待处理标志位</td></tr><tr><td>输入参数</td><td>CAN_FLAG: 待检查的CAN标志位
参阅Section: CAN_FLAG 查阅更多该参数允许取值范围</td></tr><tr><td>输出参数</td><td>无</td></tr><tr><td>返回值</td><td>无</td></tr><tr><td>先决条件</td><td>无</td></tr><tr><td>被调用函数</td><td>无</td></tr></table>

例：

/* Clear the CAN bus-off state flag */

CAN_ClearFlag(CAN_FLAG_BOF);

# 6.2.16 函数CAN_GetITStatus

Table 101. 描述了函数 CAN_GetITStatus

Table 101. 函数 CAN_GetITStatus  

<table><tr><td>函数名</td><td>CAN_GetITStatus</td></tr><tr><td>函数原形</td><td>ITStatus CAN_GetITStatus(u32 CAN_IT)</td></tr><tr><td>功能描述</td><td>检查指定的 CAN 中断发生与否</td></tr><tr><td>输入参数</td><td>CAN_IT: 待检查的 CAN 中断源
参阅 Section: CAN_IT 查阅更多该参数允许取值范围</td></tr><tr><td>输出参数</td><td>无</td></tr><tr><td>返回值</td><td>CAN_IT 的新状态 (SET 或者 RESET)</td></tr><tr><td>先决条件</td><td>无</td></tr><tr><td>被调用函数</td><td>无</td></tr></table>

# CAN_IT

输入参数CAN_IT选择待检查的中断。见Table102.查阅更多CAN_IT取值描述

Table 102. CAN_IT 值  

<table><tr><td>CAN_IT</td><td>描述</td></tr><tr><td>CAN_IT_RQCP0</td><td>邮箱1请求完成</td></tr><tr><td>CAN_IT_RQCP1</td><td>邮箱2请求完成</td></tr><tr><td>CAN_IT_RQCP2</td><td>邮箱3请求完成</td></tr><tr><td>CAN_IT_FMP0</td><td>FIFO0消息挂号</td></tr><tr><td>CAN_IT_FULL0</td><td>FIFO0已存入3消息</td></tr><tr><td>CAN_IT_FOVR0</td><td>FIFO0溢出</td></tr><tr><td>CAN_IT_FMP1</td><td>FIFO1消息挂号</td></tr><tr><td>CAN_IT_FULL1</td><td>FIFO1已存入3消息</td></tr><tr><td>CAN_IT_FOVR1</td><td>FIFO1溢出</td></tr><tr><td>CAN_IT_EWGF</td><td>上限到达警告</td></tr><tr><td>CAN_IT_EPVF</td><td>错误被动上限到达</td></tr><tr><td>CAN_IT_BOFF</td><td>进入离线状态</td></tr><tr><td>CAN_IT_WKUI</td><td>睡眠模式下SOF侦测</td></tr></table>

例：

/\*Testif theCANFIFO0overruninterrupthasoccurredornot\*/ITStatusStatus;Status  $=$  CAN_GetITStatus(CAN_IT_FOVR0);

# 6.2.17 函数CAN_ClearITPendingBit

Table 103. 描述了函数 CAN_ClearITPendingBit  
Table 103. 函数 CAN_ClearITPendingBit  

<table><tr><td>函数名</td><td>CAN_ClearITPendingBit</td></tr><tr><td>函数原形</td><td>void CAN_ClearITPendingBit(u32 CAN_IT)</td></tr><tr><td>功能描述</td><td>清除CAN中断待处理标志位</td></tr><tr><td>输入参数</td><td>CAN_IT: 待清除中断待处理标志位
参阅Section: CAN_IT 查阅更多该参数允许取值范围</td></tr><tr><td>输出参数</td><td>无</td></tr><tr><td>返回值</td><td>无</td></tr><tr><td>先决条件</td><td>无</td></tr><tr><td>被调用函数</td><td>无</td></tr></table>

例：  
/* Clear the CAN error passive overflow interrupt pending bit */
CAN_ClearITPendingBit(CAN_IT_EPVF);

# 7 DMA控制器（DMA）

DMA 控制器提供 7 个数据通道的访问。由于外设实现了向存储器的映射，因此数据对来自或者发向外设的数据传输，也可以像内存之间的数据传输一样管理。

Section 7.1 DMA 寄存器结构描述了固件函数库所使用的数据结构，Section 7.2 固件库函数介绍了函数库里的所有函数。

# 7.1 DMA寄存器结构

Table 104. 例举了 DMA 所有寄存器  
```txt
DMA寄存器结构，DMA_Cannel_TYPEDef和DMA_TYPEDef，在文件“stm32f10x_map.h”中定义如下：typedef struct{vu32CCR;vu32CNDTR;vu32CPAR;vu32CMAR;\}DMA_Channel_TYPEDef;typedefstruct{vu32ISR;vu32IFCR;\}DMA_TYPEDef;
```

Table 104. DMA 寄存器  

<table><tr><td>寄存器</td><td>描述</td></tr><tr><td>ISR</td><td>DMA中断状态寄存器</td></tr><tr><td>IFCR</td><td>DMA中断标志位清除寄存器</td></tr><tr><td>CCRx</td><td>DMA通道x设置寄存器</td></tr><tr><td>CNDTRx</td><td>DMA通道x待传输数据数目寄存器</td></tr><tr><td>CPARx</td><td>DMA通道x外设地址寄存器</td></tr><tr><td>CMARx</td><td>DMA通道x内存地址寄存器</td></tr></table>

DMA 和它的 7 个通道也声明于文件“stm32f10x.map”：

```c
define PERIPH_BASE((u32)0x40000000)   
#define APB1PERIPH_BASE PERIPH_BASE   
#define APB2PERIPH_BASE (PERIPH_BASE + 0x10000)   
#define AHBPERIPH_BASE (PERIPH_BASE + 0x20000)   
#define DMA_BASE (AHBPERIPH_BASE + 0x0000)   
#define DMA_Channel1_BASE (AHBPERIPH_BASE + 0x0008)   
#define DMA_Channel2_BASE (AHBPERIPH_BASE + 0x001C)   
#define DMA_Channel3_BASE (AHBPERIPH_BASE + 0x0030)   
#define DMA_Channel4_BASE (AHBPERIPH_BASE + 0x0044)   
#define DMA_Channel5_BASE (AHBPERIPH_BASE + 0x0058)   
#define DMA_Channel6_BASE (AHBPERIPH_BASE + 0x006C)   
#define DMA_Channel7_BASE (AHBPERIPH_BASE + 0x0080)   
#ifndef DEBUG   
#ifdef_DMA   
#define DMA ((DMA_TYPEDef \*) DMA_BASE)   
endif /* DMA */   
#ifdef_DMA_Channel1   
#define DMA_Channel1 ((DMA_Channel_TYPEDef \*) DMA_Channel1_BASE)
```

# ST

译文英文原版为UM0427 Oct. 2007 Rev 2，译文仅供参考，与英文版冲突的，以英文版为准

DMA  
```c
endif /* DMA_Channel1 */
ifdef_DMA_Channel2
#define DMA_Channel2 ((DMA_ChannelTypeDef *
DMA_Channel2_BASE)
#endif /* DMA_Channel2 */
ifdef_DMA_Channel3
#define DMA_Channel3 ((DMA_ChannelTypeDef *
DMA_Channel3_BASE)
#endif /* DMA_Channel3 */
#ifdef_DMA_Channel4
#define DMA_Channel4 ((DMA_ChannelTypeDef *
DMA_Channel4_BASE)
#endif /* DMA_Channel4 */
ifdef_DMA_Channel5
#define DMA_Channel5 ((DMA_ChannelTypeDef *
DMA_Channel5_BASE)
#endif /* DMA_Channel5 */
#ifdef_DMA_Channel6
#define DMA_Channel6 ((DMA_ChannelTypeDef *
DMA_Channel6_BASE)
#endif /* DMA_Channel6 */
#ifdef_DMA_Channel7
#define DMA_Channel7 ((DMA_ChannelTypeDef *
DMA_Channel7_BASE)
#endif /* DMA_Channel7 */
...
#else /* DEBUG */
...
#ifdef_DMA
EXT DMATypeDef *DMA;
#endif /* DMA */
#ifdef_DMA_Channel1
EXT DMA_Channel_TYPEDef *DMA_Channel1;
#endif /* DMA_Channel1 */
#ifdef_DMA_Channel2
EXT DMA_Channel_TYPEDef *DMA_Channel2;
#endif /* DMA_Channel2 */
#ifdef_DMA_Channel3
EXT DMA_Channel_TYPEDef *DMA_Channel3;
#endif /* DMA_Channel3 */
#ifdef_DMA_Channel4
EXT DMA_Channel_TYPEDef *DMA_Channel4;
#endif /* DMA_Channel4 */
#ifdef_DMA_Channel5
EXT DMA_Channel_TYPEDef *DMA_Channel5;
#endif /* DMA_Channel5 */
#ifdef_DMA_Channel6
EXT DMA_Channel_TYPEDef *DMA_Channel6;
#endif /* DMA_Channel6 */
#ifdef_DMA_Channel7
EXT DMA_Channel_TYPEDef *DMA_Channel7;
#endif /* DMA_Channel7 */
...
#endif
```

使用Debug模式时，初始化指针DMA, DMA_Channel1, DMA_Channel2,...，和

```c
DMA_Channel7于文件“stm32f10x_lib.c”：
ifdef_DMA
DMA = (DMATypeDef *) DMA_BASE;
endif /* DMA */
ifdef_DMA_Channel1
DMA_Channel1 = (DMA_Channel_TYPEDef *) DMA_Channel1_BASE;
endif /* DMA_Channel1 */
ifdef_DMA_Channel2
DMA_Channel2 = (DMA_Channel_TYPEDef *) DMA_Channel2_BASE;
endif /* DMA_Channel2 */
ifdef_DMA_Channel3
DMA_Channel3 = (DMA_Channel_TYPEDef *) DMA_Channel3_BASE;
```

```txt
ST
```

译文英文原版为UM0427 Oct. 2007 Rev 2, 译文仅供参考，与英文版冲突的，以英文版为准

DMA  
```c
endif /* DMA_Channel3 */
ifdef_DMA_Channel4
DMA_Channel4 = (DMA_Channel_TYPEDef *) DMA_Channel4_BASE;
#endif /* DMA_Channel4 */
ifdef_DMA_Channel5
DMA_Channel5 = (DMA_Channel_TYPEDef *) DMA_Channel5_BASE;
#endif /* DMA_Channel5 */
ifdef_DMA_Channel6
DMA_Channel6 = (DMA_Channel_TYPEDef *) DMA_Channel6_BASE;
#endif /* DMA_Channel6 */
ifdef_DMA_Channel7
DMA_Channel7 = (DMA_Channel_TYPEDef *) DMA_Channel7_BASE;
#endif /* DMA_Channel7 */
```

为了访问DMA寄存器，，_DMA，_DMA_Channel1到_DMA_Channel7必须在文件“stm32f10x_conf.h”中定义如下：

```txt
...   
define DMA   
#define DMA_Channel1   
#define DMA_Channel2   
#define DMA_Channel3   
#define DMA_Channel4   
#define DMA_Channel5   
#define DMA_Channel6   
#define DMA_Channel7
```

# 7.2 DMA库函数

Table 105. 例举了 DMA 的库函数  
Table 105. DMA 库函数  

<table><tr><td>函数名</td><td>描述</td></tr><tr><td>DMA_DeInit</td><td>将DMA的通道x寄存器重设为缺省值</td></tr><tr><td>DMA_Init</td><td>根据DMA_InitStruct中指定的参数初始化DMA的通道x寄存器</td></tr><tr><td>DMASTRUCTInit</td><td>把DMA_InitStruct中的每一个参数按缺省值填入</td></tr><tr><td>DMA_Cmd</td><td>使能或者失能指定的通道x</td></tr><tr><td>DMA_ITConfig</td><td>使能或者失能指定的通道x中断</td></tr><tr><td>DMA_GetCurrDataCounte</td><td>返回当前DMA通道x剩余的待传输数据数目</td></tr><tr><td>DMA_GetFlagStatus</td><td>检查指定的DMA通道x标志位设置与否</td></tr><tr><td>DMA_ClearFlag</td><td>清除DMA通道x待处理标志位</td></tr><tr><td>DMA_GetITStatus</td><td>检查指定的DMA通道x中断发生与否</td></tr><tr><td>DMA_ClearITPendingBit</td><td>清除DMA通道x中断待处理标志位</td></tr></table>

# 7.2.1 函数DMA_DeInit

Table 106. 描述了函数 DMA_DeInit

Table 106. 函数 DMA_DeInit  

<table><tr><td>函数名</td><td>DMA_DeInit</td></tr><tr><td>函数原形</td><td>void DMA_DeInit(DMA_Channel_TYPEDef* DMA_Channelx)</td></tr><tr><td>功能描述</td><td>将DMA的通道x寄存器重设为缺省值</td></tr><tr><td>输入参数</td><td>DMA Channelx: x可以是1, 2..., 或者7来选择DMA通道x</td></tr><tr><td>输出参数</td><td>无</td></tr><tr><td>返回值</td><td>无</td></tr><tr><td>先决条件</td><td>无</td></tr><tr><td>被调用函数</td><td>RCC_APBPeriphResetCmd()</td></tr></table>

例：/\*Deinitialize the DMA Channel2 \*/DMA_DeInit(DMA_Channel2);

# 7.2.2 函数DMA_Init

Table 107. 描述了函数 DMA_Init  
Table 107. 函数 DMA_Init  

<table><tr><td>函数名</td><td>DMA_Init</td></tr><tr><td>函数原形</td><td>void DMA_Init(DMA_Channel_TYPEDef* DMA_Channelx, DMA_InitTypeDef* DMA_InitStruct)</td></tr><tr><td>功能描述</td><td>根据DMA_InitStruct中指定的参数初始化DMA的通道x寄存器</td></tr><tr><td>输入参数1</td><td>DMA Channelx: x可以是1, 2..., 或者7来选择DMA通道x</td></tr><tr><td>输入参数2</td><td>DMA_InitStruct: 指向结构DMA_InitTypeDef的指针, 包含了DMA通道x的配置信息参阅: Section: DMA_InitTypeDef 查阅更多该参数允许取值范围</td></tr><tr><td>输出参数</td><td>无</td></tr><tr><td>返回值</td><td>无</td></tr><tr><td>先决条件</td><td>无</td></tr><tr><td>被调用函数</td><td>无</td></tr></table>

# DMA_InitTypeDef structure

DMA_InitTypeDef 定义于文件“stm32f10x_DMA.h”：

```txt
typedef struct   
{   
u32 DMA_PeripheralBaseAddr;   
u32 DMA_MemoryBaseAddr;   
u32 DMA_DIR;   
u32 DMA BufferSize;   
u32 DMA_PeripheralInc;   
u32 DMA_MemoryInc;   
u32 DMA_PeripheralDataSize;   
u32 DMA_MemoryDataSize;   
u32 DMA_Mode;   
u32 DMA_Priority;   
u32 DMA_M2M;   
} DMA_InitTypeDef;
```

# DMA_PeripheralBaseAddr

该参数用以定义 DMA 外设基地址

# DMA_MemoryBaseAddr

# ST

译文英文原版为UM0427 Oct. 2007 Rev 2, 译文仅供参考，与英文版冲突的，以英文版为准

该参数用以定义 DMA 内存基地址

# DMA_DIR

DMA_DIR 规定了外设是作为数据传输的目的地还是来源。Table 108. 给出了该参数的取值范围。

Table 108. DMA DIR 值  

<table><tr><td>DMA_DIR</td><td>描述</td></tr><tr><td>DMA_DIR_PeripheralDST</td><td>外设作为数据传输的目的地</td></tr><tr><td>DMA_DIR_PeripheralSRC</td><td>外设作为数据传输的来源</td></tr></table>

# DMA_Size

DMA_Size 用以定义指定 DMA 通道的 DMA 缓存的大小，单位为数据单位。根据传输方向，数据单位等于结构中参数 DMA_PeripheralDataSize 或者参数 DMA_MemoryDataSize 的值。

# DMA_PeripheralInc

DMA_PeripheralInc用来设定外设地址寄存器递增与否。Table109.给出了该参数的取值范围。

Table 109. DMA_PeripheralInc 值  

<table><tr><td>DMA_PeripheralInc</td><td>描述</td></tr><tr><td>DMA_PeripheralInc_Enable</td><td>外设地址寄存器递增</td></tr><tr><td>DMA_PeripheralInc_Disable</td><td>外设地址寄存器不变</td></tr></table>

# DMA_MemoryInc

DMA_MemoryInc用来设定内存地址寄存器递增与否。Table110.给出了该参数的取值范围。

Table 110. DMA_MemoryInc 值  

<table><tr><td>DMA_MemoryInc</td><td>描述</td></tr><tr><td>DMA_PeripheralInc_Enable</td><td>内存地址寄存器递增</td></tr><tr><td>DMA_PeripheralInc_Disable</td><td>内存地址寄存器不变</td></tr></table>

# DMA_PeripheralDataSize

DMA_PeripheralDataSize 设定了外设数据宽度。Table 111. 给出了该参数的取值范围。

Table 111. DMA_PeripheralDataSize 值  

<table><tr><td>DMA_PeripheralDataSize</td><td>描述</td></tr><tr><td>DMA_PeripheralDataSize_Note</td><td>数据宽度为8位</td></tr><tr><td>DMA_PeripheralDataSize_HalfWord</td><td>数据宽度为16位</td></tr><tr><td>DMA_PeripheralDataSize_Word</td><td>数据宽度为32位</td></tr></table>

# DMA_MemoryDataSize

DMA_MemoryDataSize 设定了外设数据宽度。Table 112. 给出了该参数的取值范围。

Table 112. DMA_MemoryDataSize 值  

<table><tr><td>DMA_MemoryDataSize</td><td>描述</td></tr><tr><td>DMA_MemoryDataSize_Byte</td><td>数据宽度为8位</td></tr><tr><td>DMA_MemoryDataSize_HalfWord</td><td>数据宽度为16位</td></tr><tr><td>DMA_MemoryDataSize_Word</td><td>数据宽度为32位</td></tr></table>

# DMA_Mode

DMA_Mode 设置了 CAN 的工作模式，Table 113.给出了该参数可取的值

Table 113. DMA_Mode 值  

<table><tr><td>DMA_Mode</td><td>描述</td></tr><tr><td>DMA_Mode_Circular</td><td>工作在循环缓存模式</td></tr><tr><td>DMA_Mode_Normal</td><td>工作在正常缓存模式</td></tr></table>

注意：当指定 DMA 通道数据传输配置为内存到内存时，不能使用循环缓存模式。（见 Section DMA_M2M)

# DMA_Priority

DMA_Priority 设定 DMA 通道 x 的软件优先级。Table 114.给出了该参数可取的值。

Table 114. DMA_Priority 值  

<table><tr><td>DMA_Mode</td><td>描述</td></tr><tr><td>DMA_Priority_VeryHigh</td><td>DMA 通道 x 拥有非常高优先级</td></tr><tr><td>DMA_Priority_High</td><td>DMA 通道 x 拥有高优先级</td></tr><tr><td>DMA_Priority_Medium</td><td>DMA 通道 x 拥有中优先级</td></tr><tr><td>DMA_Priority_Low</td><td>DMA 通道 x 拥有低优先级</td></tr></table>

# DMA_M2M

DMA_M2M使能DMA通道的内存到内存传输。Table115.给出了该参数可取的值。

Table 115. DMA_M2M 值  

<table><tr><td>DMA_M2M</td><td>描述</td></tr><tr><td>DMA_M2M_Enable</td><td>DMA通道x设置为内存到内存传输</td></tr><tr><td>DMA_M2M_Disable</td><td>DMA通道x没有设置为内存到内存传输</td></tr></table>

例：

```txt
/\* Initialize the DMA Channel1 according to the DMA_InitStructure members \*/ DMA_InitTypeDef DMA_InitStructure; DMA_InitStructure.DMA_PeripheralBaseAddr  $= 0\mathrm{x}40005400$  DMA_InitStructure.DMA_MemoryBaseAddr  $= 0\mathrm{x}20000100$  DMA_InitStructure.DMA_DIR  $=$  DMA_DIR_PeripheralSRC; DMA_InitStructure.DMA BufferSize  $= 256$  DMA_InitStructure.DMA_PeripheralInc  $=$  DMA_PeripheralInc_Disable; DMA_InitStructure.DMA_MemoryInc  $=$  DMA_MemoryInc_Enable; DMA_InitStructure.DMA_PeripheralDataSize  $=$  DMA_PeripheralDataSize_HalfWord; DMA_InitStructure.DMA_MemoryDataSize  $=$  DMA_MemoryDataSize_HalfWord; DMA_InitStructure.DMA_Mode  $=$  DMA_Mode_Normal; DMA_InitStructure.DMA_Priority  $=$  DMA_Priority_Medium; DMA_InitStructure.DMA_M2M  $=$  DMA_M2M_Disable; DMA_Init(DMA_Channel1, &DMA_InitStructure);
```

# 7.2.3 函数DMASTRUCTInit

Table 116. 描述了函数 DMASTRUCTInit

Table 116. 函数 DMASTRUCTInit  

<table><tr><td>函数名</td><td>DMASTRUCTInit</td></tr><tr><td>函数原形</td><td>void DMASTRUCTInit(DMA_InitTypeDef* DMA_InitStruct)</td></tr><tr><td>功能描述</td><td>把DMA_InitStruct中的每一个参数按缺省值填入</td></tr><tr><td>输入参数</td><td>DMA_InitStruct: 指向结构DMA_InitTypeDef的指针, 待初始化</td></tr><tr><td>输出参数</td><td>无</td></tr><tr><td>返回值</td><td>无</td></tr><tr><td>先决条件</td><td>无</td></tr><tr><td>被调用函数</td><td>无</td></tr></table>

结构 DMA_InitStruct 的各个成员有如下的缺省值：

Table 117. DMA_InitStruct 缺省值  

<table><tr><td>成员</td><td>缺省值</td></tr><tr><td>DMA_PeripheralBaseAddr</td><td>0</td></tr><tr><td>DMA_MemoryBaseAddr</td><td>0</td></tr><tr><td>DMA_DIR</td><td>DMA_DIR_PeripheralSRC</td></tr><tr><td>DMA BufferSize</td><td>0</td></tr><tr><td>DMA_PeripheralInc</td><td>DMA_PeripheralInc_Disable</td></tr><tr><td>DMA_MemoryInc</td><td>DMA_MemoryInc_Disable</td></tr><tr><td>DMA_PeripheralDataSize</td><td>DMA_PeripheralDataSize_NByte</td></tr><tr><td>DMA_MemoryDataSize</td><td>DMA_MemoryDataSize_NByte</td></tr><tr><td>DMA_Mode</td><td>DMA_Mode_Normal</td></tr><tr><td>DMA_Priority</td><td>DMA_Priority_Low</td></tr><tr><td>DMA_M2M</td><td>DMA_M2M_Disable</td></tr></table>

例：

```c
/* Initialize a DMA_InitTypeDef structure */
DMA_InitTypeDef DMA_InitStructure;
DMASTRUCTInit(&DMA_InitStructure);
```

# 7.2.4 函数DMA_Cmd

Table 118. 描述了函数 DMA_Cmd

Table 118. 函数 DMA_Cmd  

<table><tr><td>函数名</td><td>DMA_Cmd</td></tr><tr><td>函数原形</td><td>void DMA_Cmd(DMA_Channel_TYPEDef* DMA_Channelx, FunctionalState NewState)</td></tr><tr><td>功能描述</td><td>使能或者失能指定的通道x</td></tr><tr><td>输入参数1</td><td>DMA Channelx: x可以是1, 2..., 或者7来选择DMA通道x</td></tr><tr><td>输入参数2</td><td>NewState: DMA通道x的新状态
这个参数可以取: ENABLE或者 DISABLE</td></tr><tr><td>输出参数</td><td>无</td></tr><tr><td>返回值</td><td>无</td></tr><tr><td>先决条件</td><td>无</td></tr><tr><td>被调用函数</td><td>无</td></tr></table>

例：

```txt
/\*EnableDMAChannel7\*/ DMA_Cmd(DMA_Channel7，ENABLE);
```

# 7.2.5 函数DMA_ITConfig

Table 119. 描述了函数 DMA_ITConfig  
Table 119. 函数 DMA_ITConfig  

<table><tr><td>函数名</td><td>DMA_ITConfig</td></tr><tr><td>函数原形</td><td>void DMA_ITConfig(DMA_Channel_TYPEDef* DMA_Channelx, u32 DMA_IT, FunctionalState NewState)</td></tr><tr><td>功能描述</td><td>使能或者失能指定的通道x中断</td></tr><tr><td>输入参数1</td><td>DMA Channelx: x可以是1, 2..., 或者7来选择DMA通道x</td></tr><tr><td>输入参数2</td><td>DMA_IT: 待使能或者失能的DMA中断源, 使用操作符“|”可以同时选中多个DMA中断源
参阅Section: DMA_IT 查阅更多该参数允许取值范围</td></tr><tr><td>输入参数3</td><td>NewState: DMA通道x中断的新状态
这个参数可以取: ENABLE或者 DISABLE</td></tr><tr><td>输出参数</td><td>无</td></tr><tr><td>返回值</td><td>无</td></tr><tr><td>先决条件</td><td>无</td></tr><tr><td>被调用函数</td><td>无</td></tr></table>

# DMA_IT

输入参数 DMA_IT 使能或者失能 DMA 通道 x 的中断。可以取下表的一个或者多个取值的组合作为该参数的值。

Table 120. DMA_IT 值  

<table><tr><td>DMA_IT</td><td>描述</td></tr><tr><td>DMA_IT_TC</td><td>传输完成中断屏蔽</td></tr><tr><td>DMA_IT_HT</td><td>传输过半中断屏蔽</td></tr><tr><td>DMA_IT_TE</td><td>传输错误中断屏蔽</td></tr></table>

例：

```c
/* Enable DMA Channel5 complete transfer interrupt */
DMA_ITConfig(DMA_Channel5, DMA_IT_TC, ENABLE);
```

# 7.2.6 函数DMA_GetCurrDataCounte

Table 121. 描述了函数 DMA_GetCurrDataCounte  
Table 121. 函数 DMA_GetCurrDataCounte  

<table><tr><td>函数名</td><td>DMA_GetCurrDataCounte</td></tr><tr><td>函数原形</td><td>u16 DMA_GetCurrDataCounter(DMA_ChannelTypeDef*
DMA_Channelx)</td></tr><tr><td>功能描述</td><td>返回当前 DMA 通道 x 剩余的待传输数据数目</td></tr><tr><td>输入参数</td><td>DMA Channelx: x 可以是 1, 2...，或者 7 来选择 DMA 通道 x</td></tr><tr><td>输出参数</td><td>无</td></tr><tr><td>返回值</td><td>当前 DMA 通道 x 剩余的待传输数据数目</td></tr><tr><td>先决条件</td><td>无</td></tr><tr><td>被调用函数</td><td>无</td></tr></table>

例：

```txt
/\*Get the number of remaining data units in the current DMA Channel2 transfer \*/ u16 CurrDataCount; CurrDataCount  $=$  DMA_GetCurrDataCounter(DMA_Channel2);
```

# ST

译文英文原版为UM0427 Oct. 2007 Rev 2, 译文仅供参考，与英文版冲突的，以英文版为准

# 7.2.7 函数DMA_GetFlagStatus

Table 122. 描述了函数 DMA_GetFlagStatus

Table 122. 函数 DMA_GetFlagStatus  

<table><tr><td>函数名</td><td>DMA_GetFlagStatus</td></tr><tr><td>函数原形</td><td>FlagStatus DMA_GetFlagStatus(u32 DMA_FLAG)</td></tr><tr><td>功能描述</td><td>检查指定的 DMA 通道 x 标志位设置与否</td></tr><tr><td>输入参数</td><td>DMA_FLAG: 待检查的 DMA 标志位
参阅 Section: DMA_FLAG 查阅更多该参数允许取值范围</td></tr><tr><td>输出参数</td><td>无</td></tr><tr><td>返回值</td><td>DMA_FLAG 的新状态 (SET 或者 RESET)</td></tr><tr><td>先决条件</td><td>无</td></tr><tr><td>被调用函数</td><td>无</td></tr></table>

# DMA_FLAG

参数 DMA_FLAG 定义了待检察的标志位类型。见 Table 123. 查阅更多 DMA_FLAG 取值描述

Table 123. DMA_FLAG 值  

<table><tr><td>DMA_FLAG</td><td>描述</td></tr><tr><td>DMA_FLAG_GL1</td><td>通道1全局标志位</td></tr><tr><td>DMA_FLAG_TC1</td><td>通道1传输完成标志位</td></tr><tr><td>DMA_FLAG_HT1</td><td>通道1传输过半标志位</td></tr><tr><td>DMA_FLAG_SE1</td><td>通道1传输错误标志位</td></tr><tr><td>DMA_FLAG_GL2</td><td>通道2全局标志位</td></tr><tr><td>DMA_FLAG_TC2</td><td>通道2传输完成标志位</td></tr><tr><td>DMA_FLAG_HT2</td><td>通道2传输过半标志位</td></tr><tr><td>DMA_FLAG_SE2</td><td>通道2传输错误标志位</td></tr><tr><td>DMA_FLAG_GL3</td><td>通道3全局标志位</td></tr><tr><td>DMA_FLAG_TC3</td><td>通道3传输完成标志位</td></tr><tr><td>DMA_FLAG_HT3</td><td>通道3传输过半标志位</td></tr><tr><td>DMA_FLAG_SE3</td><td>通道3传输错误标志位</td></tr><tr><td>DMA_FLAG_GL4</td><td>通道4全局标志位</td></tr><tr><td>DMA_FLAG_TC4</td><td>通道4传输完成标志位</td></tr><tr><td>DMA_FLAG_HT4</td><td>通道4传输过半标志位</td></tr><tr><td>DMA_FLAG_SE4</td><td>通道4传输错误标志位</td></tr><tr><td>DMA_FLAG_GL5</td><td>通道5全局标志位</td></tr><tr><td>DMA_FLAG_TC5</td><td>通道5传输完成标志位</td></tr><tr><td>DMA_FLAG_HT5</td><td>通道5传输过半标志位</td></tr><tr><td>DMA_FLAG_SE5</td><td>通道5传输错误标志位</td></tr><tr><td>DMA_FLAG_GL6</td><td>通道6全局标志位</td></tr><tr><td>DMA_FLAG_TC6</td><td>通道6传输完成标志位</td></tr><tr><td>DMA_FLAG_HT6</td><td>通道6传输过半标志位</td></tr><tr><td>DMA_FLAG_SE6</td><td>通道6传输错误标志位</td></tr><tr><td>DMA_FLAG_GL7</td><td>通道7全局标志位</td></tr><tr><td>DMA_FLAG_TC7</td><td>通道7传输完成标志位</td></tr><tr><td>DMA_FLAG_HT7</td><td>通道7传输过半标志位</td></tr><tr><td>DMA_FLAG_SE7</td><td>通道7传输错误标志位</td></tr></table>

例：  
/\* Test if the DMA Channel6 half transfer interrupt flag is set or

# 7.2.8 函数DMA_ClearFlag

Table 124. 描述了函数 DMA_ClearFlag  
Table 124. 函数 DMA_ClearFlag  

<table><tr><td>函数名</td><td>DMA_ClearFlag</td></tr><tr><td>函数原形</td><td>void DMA_ClearFlag(u32 DMA_FLAG)</td></tr><tr><td>功能描述</td><td>清除DMA通道x待处理标志位</td></tr><tr><td>输入参数</td><td>DMA_FLAG: 待清除的 DMA 标志位, 使用操作符“|”可以同时选中多个DMA 标志位参阅 Section: DMA_FLAG 查阅更多该参数允许取值范围用户可以使用或操作选中多个标志位</td></tr><tr><td>输出参数</td><td>无</td></tr><tr><td>返回值</td><td>无</td></tr><tr><td>先决条件</td><td>无</td></tr><tr><td>被调用函数</td><td>无</td></tr></table>

例：
/* Clear the DMA Channel3 transfer error interrupt pending bit */
DMA_ClearFlag(DMA_FLAG_TE3);

# 7.2.9 函数DMA_GetITStatus

Table 125. 描述了函数 DMA_GetITStatus  
Table 125. 函数 DMA_GetITStatus  

<table><tr><td>函数名</td><td>DMA_GetITStatus</td></tr><tr><td>函数原形</td><td>ITStatus DMA_GetITStatus(u32 DMA_IT)</td></tr><tr><td>功能描述</td><td>检查指定的DMA通道x中断发生与否</td></tr><tr><td>输入参数</td><td>DMA_IT: 待检查的DMA中断源
参阅Section: DMA_IT 查阅更多该参数允许取值范围</td></tr><tr><td>输出参数</td><td>无</td></tr><tr><td>返回值</td><td>DMA_IT的新状态 (SET或者RESET)</td></tr><tr><td>先决条件</td><td>无</td></tr><tr><td>被调用函数</td><td>无</td></tr></table>

# DMA IT

参数 DMA_IT 定义了待检察的 DMA 中断。见 Table 126. 查阅更多该输入参数取值描述

Table 126. DMA_IT 值  

<table><tr><td>DMA_IT</td><td>描述</td></tr><tr><td>DMA_IT_GL1</td><td>通道1全局中断</td></tr><tr><td>DMA_IT_TC1</td><td>通道1传输完成中断</td></tr><tr><td>DMA_IT_HT1</td><td>通道1传输过半中断</td></tr><tr><td>DMA_IT_TE1</td><td>通道1传输错误中断</td></tr><tr><td>DMA_IT_GL2</td><td>通道2全局中断</td></tr><tr><td>DMA_IT_TC2</td><td>通道2传输完成中断</td></tr><tr><td>DMA_IT_HT2</td><td>通道2传输过半中断</td></tr><tr><td>DMA_IT_TE2</td><td>通道2传输错误中断</td></tr></table>

DMA  

<table><tr><td>DMA_IT_GL3</td><td>通道3全局中断</td></tr><tr><td>DMA_IT_TC3</td><td>通道3传输完成中断</td></tr><tr><td>DMA_IT_HT3</td><td>通道3传输过半中断</td></tr><tr><td>DMA_IT_TE3</td><td>通道3传输错误中断</td></tr><tr><td>DMA_IT_GL4</td><td>通道4全局中断</td></tr><tr><td>DMA_IT_TC4</td><td>通道4传输完成中断</td></tr><tr><td>DMA_IT_HT4</td><td>通道4传输过半中断</td></tr><tr><td>DMA_IT_TE4</td><td>通道4传输错误中断</td></tr><tr><td>DMA_IT_GL5</td><td>通道5全局中断</td></tr><tr><td>DMA_IT_TC5</td><td>通道5传输完成中断</td></tr><tr><td>DMA_IT_HT5</td><td>通道5传输过半中断</td></tr><tr><td>DMA_IT_TE5</td><td>通道5传输错误中断</td></tr><tr><td>DMA_IT_GL6</td><td>通道6全局中断</td></tr><tr><td>DMA_IT_TC6</td><td>通道6传输完成中断</td></tr><tr><td>DMA_IT_HT6</td><td>通道6传输过半中断</td></tr><tr><td>DMA_IT_TE6</td><td>通道6传输错误中断</td></tr><tr><td>DMA_IT_GL7</td><td>通道7全局中断</td></tr><tr><td>DMA_IT_TC7</td><td>通道7传输完成中断</td></tr><tr><td>DMA_IT_HT7</td><td>通道7传输过半中断</td></tr><tr><td>DMA_IT_TE7</td><td>通道7传输错误中断</td></tr></table>

例：  
/* Test if the DMA Channel7 transfer complete interrupt has occurred or not */  
ITStatus Status;  
Status = DMA_GetITStatus(DMA_IT_TC7);

# 7.2.10 函数DMA_ClearITPendingBit

Table 127. 描述了函数 DMA_ClearITPendingBit  
Table 127. 函数 DMA_ClearITPendingBit  

<table><tr><td>函数名</td><td>DMA_ClearITPendingBit</td></tr><tr><td>函数原形</td><td>void DMA_ClearITPendingBit(u32 DMA_IT)</td></tr><tr><td>功能描述</td><td>清除DMA通道x中断待处理标志位</td></tr><tr><td>输入参数</td><td>DMA_IT: 待清除的DMA中断待处理标志位
参阅Section: DMA_IT 查阅更多该参数允许取值范围</td></tr><tr><td>输出参数</td><td>无</td></tr><tr><td>返回值</td><td>无</td></tr><tr><td>先决条件</td><td>无</td></tr><tr><td>被调用函数</td><td>无</td></tr></table>

例：  
/* Clear the DMA Channel5 global interrupt pending bit */  
DMA_ClearITPendingBit(DMA_IT_GL5);

# 8 外部中断/事件控制器（EXTI）

外部中断/事件控制器由19个产生事件/中断要求的边沿检测器组成。每个输入线可以独立地配置输入类型（脉冲或挂起）和对应的触发事件（上升沿或下降沿或者双边沿都触发）。每个输入线都可以被独立的屏蔽。挂起寄存器保持着状态线的中断要求。

Section 8.1 EXTI 寄存器结构描述了固件函数库所使用的数据结构，Section 8.2 固件库函数介绍了函数库里的所有函数。

# 8.1EXTI寄存器结构

EXTI寄存器结构，EXTITypeDef，在文件“stm32f10x_map.h”中定义如下：

```txt
typedef struct  
{  
vu32 IMR;  
vu32 EMR;  
vu32 RTSR;  
vu32 FTSR;  
vu32 SWIER;  
vu32 PR;  
}EXTITypeDef;
```

Table 128. 例举了EXTI 所有寄存器

Table 128.EXTI 寄存器  

<table><tr><td>寄存器</td><td>描述</td></tr><tr><td>IMR</td><td>中断屏蔽寄存器</td></tr><tr><td>EMR</td><td>事件屏蔽寄存器</td></tr><tr><td>RTSR</td><td>上升沿触发选择寄存器</td></tr><tr><td>FTSR</td><td>下降沿触发选择寄存器</td></tr><tr><td>SWIR</td><td>软件中断事件寄存器</td></tr><tr><td>PR</td><td>挂起寄存器</td></tr></table>

外设EXTI也在同一个文件声明如下：

```c
define PERIPH_BASE ((u32)0x40000000)
#define APB1PERIPH_BASE PERIPH_BASE
#define APB2PERIPH_BASE (PERIPH_BASE + 0x10000)
#define AHBPERIPH_BASE (PERIPH_BASE + 0x20000)
...
#define EXTI_BASE (APB2PERIPH_BASE + 0x0400)
#	define DEBUG
...
#	define _EXTI
#	define _EXTI ((EXTI_TYPEDef *) EXTI_BASE)
...
else /* DEBUG */
...
#	define _EXTI
EXT _EXTI_TYPEDef *EXTI;
#endif /*_EXTI */
...
#endif
```

使用Debug模式时，初始化指针EXTI于文件“stm32f10x_lib.c”：

```c
#ifndef __EXTI
EXTI = (EXTITypeDef *)EXTI_BASE;
#endif /*EXTI */
```

为了访问EXTI寄存器，,__EXTI必须在文件“stm32f10x_conf.h”中定义如下：#define__EXTI

ST

译文英文原版为UM0427 Oct. 2007 Rev 2, 译文仅供参考，与英文版冲突的，以英文版为准

# 8.2EXTI库函数

Table 129. 例举了EXTI的库函数  
Table 129.EXTI库函数  

<table><tr><td>函数名</td><td>描述</td></tr><tr><td>EXTI_DeInit</td><td>将外设EXTI寄存器重设为缺省值</td></tr><tr><td>EXTI_Init</td><td>根据EXTI_InitStruct中指定的参数初始化外设EXTI寄存器</td></tr><tr><td>EXTISTRUCTInit</td><td>把EXTI_InitStruct中的每一个参数按缺省值填入</td></tr><tr><td>EXTI_GenerateSWInterrupt</td><td>产生一个软件中断</td></tr><tr><td>EXTI_GetFlagStatus</td><td>检查指定的EXTI线路标志位设置与否</td></tr><tr><td>EXTI_ClearFlag</td><td>清除EXTI线路挂起标志位</td></tr><tr><td>EXTI_GetITStatus</td><td>检查指定的EXTI线路触发请求发生与否</td></tr><tr><td>EXTI_ClearITPendingBit</td><td>清除EXTI线路挂起位</td></tr></table>

# 8.2.1 函数EXTI_DeInit

Table 130. 描述了函数EXTI_DeInit  
Table 130. 函数EXTI DeInit  

<table><tr><td>函数名</td><td>EXTI_DeInit</td></tr><tr><td>函数原形</td><td>void EXTI_DeInit(void)</td></tr><tr><td>功能描述</td><td>将外设EXTI寄存器重设为缺省值</td></tr><tr><td>输入参数</td><td>无</td></tr><tr><td>输出参数</td><td>无</td></tr><tr><td>返回值</td><td>无</td></tr><tr><td>先决条件</td><td>无</td></tr><tr><td>被调用函数</td><td>无</td></tr></table>

例：  
/\* Resets the EXTI registers to their default reset value \*/EXTI_DeInit();

# 8.2.2 函数EXTI_Init

Table 131. 描述了函数EXTI_Init  
Table 131. 函数EXTI Init  

<table><tr><td>函数名</td><td>EXTI_Init</td></tr><tr><td>函数原形</td><td>void EXTI_Init(EXTI_InitTypeDef*EXTI_InitStruct)</td></tr><tr><td>功能描述</td><td>根据EXTI_InitStruct中指定的参数初始化外设EXTI寄存器</td></tr><tr><td>输入参数</td><td>EXTI_InitStruct:指向结构EXTI_InitTypeDef的指针,包含了外设EXTI的配置信息参阅Section:EXTI_InitTypeDef查阅更多该参数允许取值范围</td></tr><tr><td>输出参数</td><td>无</td></tr><tr><td>返回值</td><td>无</td></tr><tr><td>先决条件</td><td>无</td></tr><tr><td>被调用函数</td><td>无</td></tr></table>

# EXTI_InitTypeDef structure

EXTI_InitTypeDef 定义于文件“stm32f10x_exti.h”：

```c
typedef struct   
{   
u32EXTI_Line;   
EXTIMode_TYPEDefEXTI_Mode;   
EXTIrigger_TYPEDefEXTI_Trigger;   
FunctionalStateEXTI_LineCmd;   
}EXTI_InitTypeDef;
```

# EXTI Line

EXTI_Line选择了待使能或者失能的外部线路。Table 132. 给出了该参数可取的值

Table 132.EXTI Line值  

<table><tr><td>EXTI_Line</td><td>描述</td></tr><tr><td>EXTI_Line0</td><td>外部中断线0</td></tr><tr><td>EXTI_Line1</td><td>外部中断线1</td></tr><tr><td>EXTI_Line2</td><td>外部中断线2</td></tr><tr><td>EXTI_Line3</td><td>外部中断线3</td></tr><tr><td>EXTI_Line4</td><td>外部中断线4</td></tr><tr><td>EXTI_Line5</td><td>外部中断线5</td></tr><tr><td>EXTI_Line6</td><td>外部中断线6</td></tr><tr><td>EXTI_Line7</td><td>外部中断线7</td></tr><tr><td>EXTI_Line8</td><td>外部中断线8</td></tr><tr><td>EXTI_Line9</td><td>外部中断线9</td></tr><tr><td>EXTI_Line10</td><td>外部中断线10</td></tr><tr><td>EXTI_Line11</td><td>外部中断线11</td></tr><tr><td>EXTI_Line12</td><td>外部中断线12</td></tr><tr><td>EXTI_Line13</td><td>外部中断线13</td></tr><tr><td>EXTI_Line14</td><td>外部中断线14</td></tr><tr><td>EXTI_Line15</td><td>外部中断线15</td></tr><tr><td>EXTI_Line16</td><td>外部中断线16</td></tr><tr><td>EXTI_Line17</td><td>外部中断线17</td></tr><tr><td>EXTI_Line18</td><td>外部中断线18</td></tr></table>

# EXTI_Mode

EXTI_Mode 设置了被使能线路的模式。Table 133. 给出了该参数可取的值

Table 133.EXTI_Mode值  

<table><tr><td>EXTI_Mode</td><td>描述</td></tr><tr><td>EXTI_Mode_Event</td><td>设置EXTI线路为事件请求</td></tr><tr><td>EXTI_Mode_Interrupt</td><td>设置EXTI线路为中断请求</td></tr></table>

# EXTI_Trigger

EXTI_Trigger 设置了被使能线路的触发边沿。Table 134. 给出了该参数可取的值

Table 134.EXTI_Trigger值  

<table><tr><td>EXTI_Trigger</td><td>描述</td></tr><tr><td>EXTI_Trigger_Falling</td><td>设置输入线路下降沿为中断请求</td></tr><tr><td>EXTI_Trigger_Rising</td><td>设置输入线路上升沿为中断请求</td></tr><tr><td>EXTI_Trigger_Rising_Falling</td><td>设置输入线路上升沿和下降沿为中断请求</td></tr></table>

# EXTI_Line

EXTI_LineCmd用来定义选中线路的新状态。它可以被设为ENABLE或者DISABLE。

例：

```txt
/\*Enables external lines 12 and 14 interrupt generation on falling edge \*/   
EXTI_InitTypeDef EXTI_InitStructure;   
EXTI_InitStructure.EXTI_Line  $=$  EXTI_Line12|EXTI_Line14;   
EXTI_InitStructure.EXTI_Mode  $=$  EXTI_Mode_Interrupt;   
EXTI_InitStructure.EXTI_Trigger  $=$  EXTI_Trigger_Falling;   
EXTI_InitStructure.EXTI_LineCmd  $=$  ENABLE;   
EXTI_Init(&EXTI_InitStructure);
```

# 8.2.3 函数EXTISTRUCTInit

Table 135. 描述了函数EXTISTRUCTInit  
Table 135. 函数EXTISTRUCTInit  

<table><tr><td>函数名</td><td>EXTISTRUCTInit</td></tr><tr><td>函数原形</td><td>voidEXTISTRUCTInit(EXTI_InitTypeDef*EXTI_InitStruct)</td></tr><tr><td>功能描述</td><td>把EXTI_InitStruct中的每一个参数按缺省值填入</td></tr><tr><td>输入参数</td><td>EXTI_InitStruct:指向结构EXTI_InitTypeDef的指针,待初始化</td></tr><tr><td>输出参数</td><td>无</td></tr><tr><td>返回值</td><td>无</td></tr><tr><td>先决条件</td><td>无</td></tr><tr><td>被调用函数</td><td>无</td></tr></table>

Table 136. 给出了EXTI_InitStruct各个成员的缺省值  
Table 136.EXTI_InitStruct 缺省值  

<table><tr><td>成员</td><td>缺省值</td></tr><tr><td>EXTI_Line</td><td>EXTI_LineNone</td></tr><tr><td>EXTI_Mode</td><td>EXTI_Mode_Interrupt</td></tr><tr><td>EXTI_Trigger</td><td>EXTI_Trigger_Falling</td></tr><tr><td>EXTI_LineCmd</td><td>DISABLE</td></tr></table>

例：

```c
/\* Initialize the EXTI Init Structure parameters \*/  
EXTI_InitTypeDef EXTI_InitStructure;  
EXTISTRUCTInit(&EXTI_InitStructure);
```

# 8.2.4 函数EXTI_GenerateSWInterrupt

Table 137. 描述了函数EXTI_GenerateSWInterrupt  
Table 137. 函数EXTI_GenerateSWInterrupt  

<table><tr><td>函数名</td><td>EXTI_GenerateSWInterrupt</td></tr><tr><td>函数原形</td><td>void EXTI_GenerateSWInterrupt(u32 EXTI_Line)</td></tr><tr><td>功能描述</td><td>产生一个软件中断</td></tr><tr><td>输入参数</td><td>EXTI_Line: 待使能或者失能的EXTI线路
参阅 Section: EXTI_Line 查阅更多该参数允许取值范围</td></tr><tr><td>输出参数</td><td>无</td></tr><tr><td>返回值</td><td>无</td></tr><tr><td>先决条件</td><td>无</td></tr><tr><td>被调用函数</td><td>无</td></tr></table>

例：  
/\* Generate a software interrupt request \*/EXTI_GenceraSWInterrupt(EXTI_Line6);

# 8.2.5 函数EXTI_GetFlagStatus

Table 138. 描述了函数EXTI_GetFlagStatus  
Table 138. 函数EXTI_GetFlagStatus  

<table><tr><td>函数名</td><td>EXTI_GetFlagStatus</td></tr><tr><td>函数原形</td><td>FlagStatus EXTI_GetFlagStatus(u32 EXTI_Line)</td></tr><tr><td>功能描述</td><td>检查指定的EXTI线路标志位设置与否</td></tr><tr><td>输入参数</td><td>EXTI_Line: 待检查的EXTI线路标志位参阅Section:EXTI_Line 查阅更多该参数允许取值范围</td></tr><tr><td>输出参数</td><td>无</td></tr><tr><td>返回值</td><td>EXTI_Line的新状态 (SET或者RESET)</td></tr><tr><td>先决条件</td><td>无</td></tr><tr><td>被调用函数</td><td>无</td></tr></table>

例：  
/\*Get the status ofEXTI line8\*/ FlagStatusEXTIStatus; EXTIStatus  $=$  EXTI_GetFlagStatus(EXTI_Line8);

# 8.2.6 函数EXTI_ClearFlag

Table 139. 描述了函数EXTI_ClearFlag

Table 139. 函数EXTI_ClearFlag  

<table><tr><td>函数名</td><td>EXTI_ClearFlag</td></tr><tr><td>函数原形</td><td>voidEXTI_ClearFlag(u32EXTI_Line)</td></tr><tr><td>功能描述</td><td>清除EXTI线路挂起标志位</td></tr><tr><td>输入参数</td><td>EXTI_Line:待清除标志位的EXTI线路
参阅Section:EXTI_Line 查阅更多该参数允许取值范围</td></tr><tr><td>输出参数</td><td>无</td></tr><tr><td>返回值</td><td>无</td></tr><tr><td>先决条件</td><td>无</td></tr><tr><td>被调用函数</td><td>无</td></tr></table>

例：  
/\* Clear the EXTI line 2 pending flag \*/EXTI_ClearFlag(EXTI_Line2);

# 8.2.7 函数EXTI_GetITStatus

Table 140. 描述了函数EXTI_GetITStatus  
Table 140. 函数EXTI_GetITStatus  

<table><tr><td>函数名</td><td>EXTI_GetITStatus</td></tr><tr><td>函数原形</td><td>ITStatus EXTI_GetITStatus(u32 EXTI_Line)</td></tr><tr><td>功能描述</td><td>检查指定的EXTI线路触发请求发生与否</td></tr><tr><td>输入参数</td><td>EXTI_Line: 待检查EXTI线路的挂起位
参阅Section: EXTI_Line 查阅更多该参数允许取值范围</td></tr><tr><td>输出参数</td><td>无</td></tr><tr><td>返回值</td><td>EXTI_Line的新状态 (SET或者RESET)</td></tr><tr><td>先决条件</td><td>无</td></tr><tr><td>被调用函数</td><td>无</td></tr></table>

例：  
/\*Get the status ofEXTI line 8 \*/   
ITStatusEXTIStatus;   
EXTIStatus  $=$  EXTI_GetITStatus(EXTI_Line8);

# 8.2.8 函数EXTI_ClearITPendingBit

Table 141. 描述了函数EXTI_ClearITPendingBit  
Table 141. 函数EXTI_ClearITPendingBit  

<table><tr><td>函数名</td><td>EXTI_ClearITPendingBit</td></tr><tr><td>函数原形</td><td>voidEXTI_ClearITPendingBit(u32EXTI_Line)</td></tr><tr><td>功能描述</td><td>清除EXTI线路挂起位</td></tr><tr><td>输入参数</td><td>EXTI_Line:待清除EXTI线路的挂起位
参阅Section:EXTI_Line 查阅更多该参数允许取值范围</td></tr><tr><td>输出参数</td><td>无</td></tr><tr><td>返回值</td><td>无</td></tr><tr><td>先决条件</td><td>无</td></tr><tr><td>被调用函数</td><td>无</td></tr></table>

例：  
/\* Clears the EXTI line 2 interrupt pending bit \*/EXTI_ClearITpendingBit(EXTI_Line2);

# 9 FLASH存储器(FLASH)

Section 9.1 FLASH 寄存器结构描述了固件函数库所使用的数据结构，Section 9.2 固件库函数介绍了函数库里的所有函数。

# 9.1 FLASH寄存器结构

FLASH 寄存器结构，FLASH_TYPEDef 和 OB_TYPEDef，在文件“stm32f10x_map.h”中定义如下：

```c
typedef struct   
{   
vu32 ACR;   
vu32 KEYR;   
vu32 OPTKEYR;   
vu32 SR;   
vu32 CR;   
vu32 AR;   
vu32 RESERVED;   
vu32 OBR;   
vu32 WRPR; } FLASHTypeDef; typedef struct   
{   
vu16 RDP;   
vu16 USER;   
vu16 Data0;   
vu16 Data1;   
vu16 WRPO;   
vu16 WRP1;   
vu16 WRP2;   
vu16 WRP3; } OBTypeDef;
```

Table 142.和 Table 143.例举了 FLASH 所有寄存器和选择字节（Option Byte OB）寄存器

Table 142. FLASH 寄存器  

<table><tr><td>寄存器</td><td>描述</td></tr><tr><td>ACR</td><td>FLASH 访问控制寄存器</td></tr><tr><td>KEYR</td><td>FPEC 密钥寄存器</td></tr><tr><td>OPTKEYR</td><td>选择字节密钥寄存器</td></tr><tr><td>SR</td><td>FLASH 状态寄存器</td></tr><tr><td>CR</td><td>FLASH 控制寄存器</td></tr><tr><td>AR</td><td>FLASH 地址寄存器</td></tr><tr><td>OBR</td><td>选择字节和状态寄存器</td></tr><tr><td>WRPR</td><td>选择字节写保护寄存器</td></tr></table>

Table 143. Option Byte (OB) 寄存器  

<table><tr><td>寄存器</td><td>描述</td></tr><tr><td>RDR</td><td>读出选择字节</td></tr><tr><td>USER</td><td>用户选择字节</td></tr><tr><td>Data0</td><td>Data0 选择字节</td></tr><tr><td>Data1</td><td>Data1 选择字节</td></tr><tr><td>WRP0</td><td>写保护0 选择字节</td></tr><tr><td>WRP1</td><td>写保护1 选择字节</td></tr></table>

FLASH  
FLASH 也在文件“stm32f10x_map.h”声明如下：  
```txt
WRP2 写保护2选择字节
WRP3 写保护3选择字节
```

```c
/\*Flash registers base address \*/   
#define FLASH_BASE ((u32)0x40022000)   
\*/FlashOptionBytesbaseaddress\*/   
#defineOB_BASE((u32)0x1FFFF800)   
#ifndefDEBUG   
...   
#ifdef_FLASH   
#defineFLASH((FLASHTypeDef\*)FLASH_BASE)   
#defineOB((OB_TYPEDef\*)OB_BASE)   
#endif/\*FLASH\*/   
...   
#else/\*DEBUG\*/   
...   
#ifdef FLASH   
EXT FLASHTypeDef\*FLASH;   
EXT OB_TYPEDef\*OB;   
#endif/\*FLASH\*/   
...   
#endif
```

使用Debug模式时，初始化指针FLASH和OB于文件“stm32f10x_lib.c”：  
为了访问EXTI寄存器，,FLASH必须在文件“stm32f10x_conf.h”中定义如下：  
define FLASH  
```c
#ifndef __FLASH
FLASH = (FLASHTypeDef *) FLASH_BASE;
OB = (OB_TYPEDef *) OB_BASE;
#endif /*__FLASH */
```

在默认情况下，只有执行 FLASH 设置（延迟，预取指，半周期）的函数式允许执行的。  
```txt
如果想要执行 FLASH 编写/擦除/保护函数，必须在文件“stm32f10x_conf.h”中定义_FLASH_PROG 如下：  
define _FLASH_PROG
```

# 9.2 FLASH库函数

Table 144. 例举了 FLASH 的库函数  
Table 144. FLASH 库函数  

<table><tr><td>函数名</td><td>描述</td></tr><tr><td>FLASH_SetLatency</td><td>设置代码延时值</td></tr><tr><td>FLASH_HalfCycleAccessCmd</td><td>使能或者失能 FLASH 半周期访问</td></tr><tr><td>FLASH_PrefetchBufferCmd</td><td>使能或者失能预取指缓存</td></tr><tr><td>FLASH_Undef</td><td>解锁 FLASH 编写擦除控制器</td></tr><tr><td>FLASH_Lock</td><td>锁定 FLASH 编写擦除控制器</td></tr><tr><td>FLASH_ErasePage</td><td>擦除一个 FLASH 页面</td></tr><tr><td>FLASH_EraseAllPages</td><td>擦除全部 FLASH 页面</td></tr><tr><td>FLASH_EraseOptionBytes</td><td>擦除 FLASH 选择字节</td></tr><tr><td>FLASH_ProgramWord</td><td>在指定地址编写一个字</td></tr><tr><td>FLASH_ProgramHalfWord</td><td>在指定地址编写半字</td></tr><tr><td>FLASH_ProgramOptionByteData</td><td>在指定 FLASH 选择字节地址编写半字</td></tr><tr><td>FLASH_EnableWriteProtection</td><td>对期望的页面写保护</td></tr><tr><td>FLASHREADINGProtection</td><td>使能或者失能读出保护</td></tr><tr><td>FLASH_OptionByteConfig</td><td>编写 FLASH 用户选择字节: IWDG_SW /RST_STOP /RST_STDBY</td></tr><tr><td>FLASH_GetUserOptionByte</td><td>返回 FLASH 用户选择字节的值</td></tr><tr><td>FLASH_GetWriteProtectionOptionByte</td><td>返回 FLASH 写保护选择字节的值</td></tr><tr><td>FLASH_GetReadOutProtectionStatus</td><td>检查 FLASH 读出保护设置与否</td></tr></table>

# ST

译文英文原版为UM0427 Oct. 2007 Rev 2, 译文仅供参考，与英文版冲突的，以英文版为准

FLASH  

<table><tr><td>FLASH_GetPrefetchBufferStatus</td><td>检查 FLASH 预取指缓存设置与否</td></tr><tr><td>FLASH_ITConfig</td><td>使能或者失能指定 FLASH 中断</td></tr><tr><td>FLASH_GetFlagStatus</td><td>检查指定的 FLASH 标志位设置与否</td></tr><tr><td>FLASH_ClearFlag</td><td>清除 FLASH 待处理标志位</td></tr><tr><td>FLASH_GetStatus</td><td>返回 FLASH 状态</td></tr><tr><td>FLASH_WaitForLastOperation</td><td>等待某一个 Flash 操作完成，或者发生 TIMEOUT</td></tr></table>

# 9.2.1 函数FLASH_SetLatency

Table 145. 描述了函数 FLASH_SetLatency  
Table 145. 函数 FLASH_SetLatency  

<table><tr><td>函数名</td><td>FLASH_SetLatency</td></tr><tr><td>函数原形</td><td>void FLASH_SetLatency(u32 FLASH_Latency)</td></tr><tr><td>功能描述</td><td>设置代码延时值</td></tr><tr><td>输入参数</td><td>FLASH_Latency: 指定 FLASH_Latency 的值
参阅 Section: FLASH_Latency 查阅更多该参数允许取值范围</td></tr><tr><td>输出参数</td><td>无</td></tr><tr><td>返回值</td><td>无</td></tr><tr><td>先决条件</td><td>无</td></tr><tr><td>被调用函数</td><td>无</td></tr></table>

# FLASH_Latency

FLASH_Latency用来设置FLASH存储器延时时钟周期数。见Table146.查阅该参数可取的值

Table 146. FLASH_Latency 值  

<table><tr><td>FLASH_Latency</td><td>描述</td></tr><tr><td>FLASH_Latency_0</td><td>0延时周期</td></tr><tr><td>FLASH_Latency_1</td><td>1延时周期</td></tr><tr><td>FLASH_Latency_2</td><td>2延时周期</td></tr></table>

例：

/* Configure the Latency cycle: Set 2 Latency cycles */
FLASH_SetLatency(FLASH_Latency_2);

# 9.2.2 函数FLASH_HalfCycleAccessCmd

Table 147. 描述了函数 FLASH_HalfCycleAccessCmd

Table 147. 函数 FLASH_HalfCycleAccessCmd  

<table><tr><td>函数名</td><td>FLASH_HalfCycleAccessCmd</td></tr><tr><td>函数原形</td><td>void FLASH_HalfCycleAccessCmd(u32 FLASH_HalfCycleAccess)</td></tr><tr><td>功能描述</td><td>使能或者失能 FLASH 半周期访问</td></tr><tr><td>输入参数</td><td>FLASH_HalfCycleAccess: FLASH_HalfCycle 访问模式
参阅 Section: FLASH_HalfCycle 查阅更多该参数允许取值范围</td></tr><tr><td>输出参数</td><td>无</td></tr><tr><td>返回值</td><td>无</td></tr><tr><td>先决条件</td><td>无</td></tr><tr><td>被调用函数</td><td>无</td></tr></table>

# FLASH_HalfCycleAccess

FLASH_HalfCycleAccess 用来选择 FLASH 半周期访问的模式。见 Table 148. 查阅该参数可取的值

Table 148. FLASH_HalfCycleAccess 值  

<table><tr><td>FLASH_HalfCycleAccess</td><td>描述</td></tr><tr><td>FLASH_HalfCycleAccess_Enable</td><td>半周期访问使能</td></tr><tr><td>FLASH_HalfCycleAccess_Disable</td><td>半周期访问失能</td></tr></table>

例：
/* Enable the Half Cycle Flash access */
FLASH_HalfCycleAccessCmd(FLASH_HalfCycleAccess_Enable);

# 9.2.3 函数FLASH_PrefetchBufferCmd

Table 149. 描述了函数 FLASH_PrefetchBufferCmd

Table 149. 函数 FLASH_PrefetchBufferCmd  

<table><tr><td>函数名</td><td>FLASH_PrefetchBufferCmd</td></tr><tr><td>函数原形</td><td>void FLASH_PrefetchBufferCmd(u32 FLASH_PrefetchBuffer)</td></tr><tr><td>功能描述</td><td>使能或者失能预取指缓存</td></tr><tr><td>输入参数</td><td>FLASH_PrefetchBuffer: 预取指缓存状态
参阅 Section: FLASH_PrefetchBuffer 查阅更多该参数允许取值范围</td></tr><tr><td>输出参数</td><td>无</td></tr><tr><td>返回值</td><td>无</td></tr><tr><td>先决条件</td><td>无</td></tr><tr><td>被调用函数</td><td>无</td></tr></table>

# FLASH_PrefetchBuffer

FLASH_PrefetchBuffer用来选择FLASH预取指缓存的模式。见Table150.查阅该参数可取的值

Table 150. FLASH_PrefetchBuffer 值  

<table><tr><td>FLASH_PrefetchBuffer</td><td>描述</td></tr><tr><td>FLASH_PrefetchBuffer_Enable</td><td>预取指缓存使能</td></tr><tr><td>FLASH_PrefetchBuffer_Disable</td><td>预取指缓存失能</td></tr></table>

例：
/* Enable The prefetch Buffer */
FLASH_PrefetchBufferCmd(FLASH_PrefetchBuffer_Enable);

# ST

译文英文原版为UM0427 Oct. 2007 Rev 2, 译文仅供参考，与英文版冲突的，以英文版为准

# 9.2.4 函数FLASHUnlock

Table 151. 描述了函数 FLASH_Undef  
Table 151. 函数 FLASHUnlock  

<table><tr><td>函数名</td><td>FLASH_Undef</td></tr><tr><td>函数原形</td><td>void FLASH_Undef(void)</td></tr><tr><td>功能描述</td><td>解锁FLASH编写擦除控制器</td></tr><tr><td>输入参数</td><td>无</td></tr><tr><td>输出参数</td><td>无</td></tr><tr><td>返回值</td><td>无</td></tr><tr><td>先决条件</td><td>无</td></tr><tr><td>被调用函数</td><td>无</td></tr></table>

例：  
/\* Unlocks the Flash FLASHUnlock();

# 9.2.5 函数FLASH_Lock

Table 152. 描述了函数 FLASH_Lock  
Table 152. 函数 FLASH_Lock  

<table><tr><td>函数名</td><td>FLASH_Lock</td></tr><tr><td>函数原形</td><td>void FLASH_Lock(void)</td></tr><tr><td>功能描述</td><td>锁定 FLASH 编写擦除控制器</td></tr><tr><td>输入参数</td><td>无</td></tr><tr><td>输出参数</td><td>无</td></tr><tr><td>返回值</td><td>无</td></tr><tr><td>先决条件</td><td>无</td></tr><tr><td>被调用函数</td><td>无</td></tr></table>

例：  
/\*LockstheFlash\*/ FLASH_Lock();

# 9.2.6 函数FLASH_ErasePage

Table 153. 描述了函数 FLASH_ErasePage  
Table 153. 函数 FLASH_ErasePage  

<table><tr><td>函数名</td><td>FLASH_ErasePage</td></tr><tr><td>函数原形</td><td>FLASH_Status FLASH_ErasePage(u32 Page_Address)</td></tr><tr><td>功能描述</td><td>擦除一个 FLASH 页面</td></tr><tr><td>输入参数</td><td>无</td></tr><tr><td>输出参数</td><td>无</td></tr><tr><td>返回值</td><td>擦除操作状态</td></tr><tr><td>先决条件</td><td>无</td></tr><tr><td>被调用函数</td><td>无</td></tr></table>

例：
/* Erases the Flash Page 0 */
FLASH_Status status = FLASH_COMPLETE;
status = FLASH_ErasePage(0x08000000);

# 9.2.7 函数FLASH_EraseAllPages

Table 154. 描述了函数 FLASH_EraseAllPages  
Table 154. 函数 FLASH_EraseAllPages  

<table><tr><td>函数名</td><td>FLASH_EraseAllPages</td></tr><tr><td>函数原形</td><td>FLASH_Status FLASH_EraseAllPages(void)</td></tr><tr><td>功能描述</td><td>擦除全部 FLASH 页面</td></tr><tr><td>输入参数</td><td>无</td></tr><tr><td>输出参数</td><td>无</td></tr><tr><td>返回值</td><td>擦除操作状态</td></tr><tr><td>先决条件</td><td>无</td></tr><tr><td>被调用函数</td><td>无</td></tr></table>

例：
/* Erases the Flash */
FLASH_Status status = FLASH_COMPLETE;
status = FLASH_EraseAllPages();

# 9.2.8 函数FLASH_EraseOptionBytes

Table 155. 描述了函数 FLASH_EraseOptionBytes  
Table 155. 函数 FLASH_EraseOptionBytes  

<table><tr><td>函数名</td><td>FLASH_EraseOptionBytes</td></tr><tr><td>函数原形</td><td>FLASH_Status FLASH_EraseOptionBytes(void)</td></tr><tr><td>功能描述</td><td>擦除 FLASH 选择字节</td></tr><tr><td>输入参数</td><td>无</td></tr><tr><td>输出参数</td><td>无</td></tr><tr><td>返回值</td><td>擦除操作状态</td></tr><tr><td>先决条件</td><td>无</td></tr><tr><td>被调用函数</td><td>无</td></tr></table>

例：
/* Erases the Flash Option Bytes */
FLASH_Status status = FLASH_COMPLETE;
status = FLASH_EraseOptionBytes();

# 9.2.9 函数FLASH_ProgramWord

Table 156. 描述了函数 FLASH_ProgramWord  
Table 156. 函数 FLASH_ProgramWord  

<table><tr><td>函数名</td><td>FLASH_ProgramWord</td></tr><tr><td>函数原形</td><td>FLASH_Status FLASH_ProgramWord(u32 Address, u32 Data)</td></tr><tr><td>功能描述</td><td>在指定地址编写一个字</td></tr><tr><td>输入参数1</td><td>Address: 待编写的地址</td></tr><tr><td>输入参数2</td><td>Data: 待写入的数据</td></tr><tr><td>输出参数</td><td>无</td></tr><tr><td>返回值</td><td>编写操作状态</td></tr><tr><td>先决条件</td><td>无</td></tr><tr><td>被调用函数</td><td>无</td></tr></table>

例：
/* Writes the Data1 at the Address1 */
FLASH_Status status = FLASH_COMPLETE;
u32 Data1 = 0x1234567;
u32 Address1 = 0x8000000;
status = FLASH_ProgramWord(Address1, Data1);

# 9.2.10 函数FLASH_ProgramHalfWord

Table 157. 描述了函数 FLASH_ProgramHalfWord  
Table 157. 函数 FLASH_ProgramHalfWord  

<table><tr><td>函数名</td><td>FLASH_ProgramHalfWord</td></tr><tr><td>函数原形</td><td>FLASH_Status FLASH_ProgramHalfWord(u32 Address, u16 Data)</td></tr><tr><td>功能描述</td><td>在指定地址编写半字</td></tr><tr><td>输入参数1</td><td>Address: 待编写的地址</td></tr><tr><td>输入参数2</td><td>Data: 待写入的数据</td></tr><tr><td>输出参数</td><td>无</td></tr><tr><td>返回值</td><td>编写操作状态</td></tr><tr><td>先决条件</td><td>无</td></tr><tr><td>被调用函数</td><td>无</td></tr></table>

例：

```txt
/\*Writes the Datal at the Address1 \*/ FLASH_Status status  $=$  FLASH_COMPLETE; u16 Datal  $= 0\mathrm{x}1234$  .   
u32 Address1  $= 0x8000004$    
status  $=$  FLASH_ProgramHalfWord(Address1, Data1);
```

# 9.2.11 函数FLASH_ProgramOptionByteData

Table 158. 描述了函数 FLASH_ProgramOptionByteData  
Table 158. 函数 FLASH_ProgramOptionByteData  

<table><tr><td>函数名</td><td>FLASH_ProgramOptionByteData</td></tr><tr><td>函数原形</td><td>FLASH_Status FLASH_ProgramOptionByteData(u32 Address, u8 Data)</td></tr><tr><td>功能描述</td><td>在指定 FLASH 选择字节地址编写半字</td></tr><tr><td>输入参数1</td><td>Address: 待编写的地址, 该参数取值可以是 0x1FFF804 或者 0x1FFF806</td></tr><tr><td>输入参数2</td><td>Data: 待写入的数据</td></tr><tr><td>输出参数</td><td>无</td></tr><tr><td>返回值</td><td>无</td></tr><tr><td>先决条件</td><td>无</td></tr><tr><td>被调用函数</td><td>无</td></tr></table>

例：

```javascript
/\*Writes the Datal at the Address1 \*/ FLASH_Status status  $=$  FLASH_COMPLETE; u8Data1  $= 0\mathrm{x}12$  . u32Address1  $= 0\mathrm{x}1\mathrm{FFF}804$  . status  $=$  FLASH_ProgramOptionByteData(Address1, Data1);
```

# 9.2.12 函数FLASH_EnableWriteProtection

Table 159. 描述了函数 FLASH_EnableWriteProtection

Table 159. 函数 FLASH_EnableWriteProtection  

<table><tr><td>函数名</td><td>FLASH_EnableWriteProtection</td></tr><tr><td>函数原形</td><td>FLASH_Status FLASH_EnableWriteProtection(u32 FLASH_Pages)</td></tr><tr><td>功能描述</td><td>对期望的页面写保护</td></tr><tr><td>输入参数</td><td>FLASH_Page: 待写保护页面的地址
参阅 Section: FLASH_Page 查阅更多该参数允许取值范围</td></tr><tr><td>输出参数</td><td>无</td></tr><tr><td>返回值</td><td>写保护操作状态</td></tr><tr><td>先决条件</td><td>无</td></tr><tr><td>被调用函数</td><td>无</td></tr></table>

# FLASH_Pages

FLASH_Page 用来设置写保护的页面。见 Table 160. 查阅该参数可取的值

Table 160. FLASH_Page 值  

<table><tr><td>FLASH_Page</td><td>描述</td></tr><tr><td>FLASH_WRProt_Pages0to3</td><td>写保护页面0到3</td></tr><tr><td>FLASH_WRProt_Pages4to7</td><td>写保护页面4到7</td></tr><tr><td>FLASH_WRProt_Pages8to11</td><td>写保护页面8到11</td></tr><tr><td>FLASH_WRProt_Pages12to15</td><td>写保护页面12到15</td></tr><tr><td>FLASH_WRProt_Pages16to19</td><td>写保护页面16到19</td></tr><tr><td>FLASH_WRProt_Pages20to23</td><td>写保护页面20到23</td></tr><tr><td>FLASH_WRProt_Pages24to27</td><td>写保护页面24到27</td></tr><tr><td>FLASH_WRProt_Pages28to31</td><td>写保护页面28到31</td></tr><tr><td>FLASH_WRProt_Pages32to35</td><td>写保护页面32到35</td></tr><tr><td>FLASH_WRProt_Pages36to39</td><td>写保护页面36到39</td></tr><tr><td>FLASH_WRProt_Pages40to43</td><td>写保护页面40到43</td></tr><tr><td>FLASH_WRProt_Pages44to47</td><td>写保护页面44到47</td></tr><tr><td>FLASH_WRProt_Pages48to51</td><td>写保护页面58到51</td></tr><tr><td>FLASH_WRProt_Pages52to55</td><td>写保护页面52到55</td></tr><tr><td>FLASH_WRProt_Pages56to59</td><td>写保护页面56到59</td></tr><tr><td>FLASH_WRProt_Pages60to63</td><td>写保护页面60到63</td></tr><tr><td>FLASH_WRProt_Pages64to67</td><td>写保护页面64到67</td></tr><tr><td>FLASH_WRProt_Pages68to71</td><td>写保护页面68到71</td></tr><tr><td>FLASH_WRProt_Pages72to75</td><td>写保护页面72到75</td></tr><tr><td>FLASH_WRProt_Pages76to79</td><td>写保护页面76到79</td></tr><tr><td>FLASH_WRProt_Pages80to83</td><td>写保护页面80到83</td></tr><tr><td>FLASH_WRProt_Pages84to87</td><td>写保护页面84到87</td></tr><tr><td>FLASH_WRProt_Pages88to91</td><td>写保护页面88到91</td></tr><tr><td>FLASH_WRProt_Pages92to95</td><td>写保护页面92到95</td></tr><tr><td>FLASH_WRProt_Pages96to99</td><td>写保护页面92到99</td></tr><tr><td>FLASH_WRProt_Pages100to103</td><td>写保护页面100到103</td></tr><tr><td>FLASH_WRProt_Pages104to107</td><td>写保护页面104到107</td></tr><tr><td>FLASH_WRProt_Pages108to111</td><td>写保护页面108到111</td></tr><tr><td>FLASH_WRProt_Pages112to115</td><td>写保护页面112到115</td></tr><tr><td>FLASH_WRProt_Pages116to119</td><td>写保护页面115到119</td></tr></table>

FLASH  

<table><tr><td>FLASH_WRProt_Pages120to123</td><td>写保护页面 120 到 123</td></tr><tr><td>FLASH_WRProt_Pages124to127</td><td>写保护页面 124 到 127</td></tr><tr><td>FLASH_WRProt_AllPages</td><td>写保护全部页面</td></tr></table>

例：

```txt
/\*Protects the Pages0to3 and Pages108to111 \*/ FLASH_Status status  $=$  FLASH_COMPLETE; status  $=$  FLASH_EnableWriteProtection (FLASH_WRProt_Pageso to3|FLASH_WRProt_Pages108to11);
```

# 9.2.13 函数FLASH_ReadOutProtection

Table 161. 描述了函数 FLASH_ReadOutProtection  
Table 161. 函数 FLASH_ReadOutProtection  

<table><tr><td>函数名</td><td>FLASH_ReadOutProtection</td></tr><tr><td>函数原形</td><td>FLASH_Status FLASH_ReadOutProtection(FunctionalState NewState)</td></tr><tr><td>功能描述</td><td>使能或者失能读出保护</td></tr><tr><td>输入参数</td><td>NewState: 读出保护的新状态。
这个参数可以取: ENABLE 或者 DISABLE</td></tr><tr><td>输出参数</td><td>无</td></tr><tr><td>返回值</td><td>保护操作状态</td></tr><tr><td>先决条件</td><td>如果用户在调用本函数之前编写过其他选择字节,那么必须在调用本函数之后重新编写选择字节,因为本操作会擦除所有选择字节</td></tr><tr><td>被调用函数</td><td>无</td></tr></table>

例：

```javascript
/\*Disables the ReadOut Protection \*/ FLASH_Status status  $=$  FLASH_COMPLETE; status  $=$  FLASH_ReadOutProtection(DISABLE);
```

注意：为了安全地编写选择字节，用户必须遵从下列操作步骤：

1. 如果想要读保护 Flash 存储器，调用函数 FLASH_ReadOutProtection  
2. 调用函数 FLASH_EnableWriteProtection 来写保护 Flash 存储器部分或者全部页面  
3. 调用函数 FLASH_USEROptionByteConfig 来设置用户选择字节：IWDG_SW/RST_STOP/RST_STDBY  
4. 调用函数 FLASH_ProgramOptionByteData 来对指定选择字节数据地址写入半字  
5. 产生复位以装入新的选择字节

# 9.2.14 函数FLASH_UserOptionByteConfig

Table 162. 描述了函数 FLASH_UserOptionByteConfig

Table 162. 函数 FLASH_UserOptionByteConfig  

<table><tr><td>函数名</td><td>FLASH_UserOptionByteConfig</td></tr><tr><td>函数原形</td><td>FLASH_Status FLASH_UserOptionByteConfig(u16 OB_IWDG, u16 OB_STOP, u16 OB_STDBY)</td></tr><tr><td>功能描述</td><td>编写FLASH用户选择字节：IWDG_SW/RST_STOP/RST_STDBY</td></tr><tr><td>输入参数1</td><td>OB_IWDG: 选择IWDG模式
参阅Section: OB_IWDG 查阅更多该参数允许取值范围</td></tr><tr><td>输入参数2</td><td>OB_STOP: 当进入STOP模式产生复位事件
参阅Section: OB_STOP 查阅更多该参数允许取值范围</td></tr><tr><td>输入参数3</td><td>OB_STDBY: 当进入Standby模式产生复位事件
参阅Section: OB_STDBY 查阅更多该参数允许取值范围</td></tr><tr><td>输出参数</td><td>无</td></tr><tr><td>返回值</td><td>选择字节编写状态</td></tr><tr><td>先决条件</td><td>无</td></tr><tr><td>被调用函数</td><td>无</td></tr></table>

# OB_IWDG

OB_IWDG 用来选择 IWDG(独立看门狗)的模式。见 Table 163. 查阅该参数可取的值

Table 163. OB_IWDG 值  

<table><tr><td>OB_IWDG</td><td>描述</td></tr><tr><td>OB_IWDG_SW</td><td>选择软件独立看门狗</td></tr><tr><td>OB_IWDG_HW</td><td>选择硬件独立看门狗</td></tr></table>

# OB_STOP

OB_STOP 用来选择进入 STOP 模式是否产生复位。见 Table 164. 查阅该参数可取的值

Table 164. OB_STOP 值  

<table><tr><td>OB_STOP</td><td>描述</td></tr><tr><td>OB_STOP_NoRST</td><td>进入 STOP 模式不产生复位</td></tr><tr><td>OB_STOP_RST</td><td>进入 STOP 模式产生复位</td></tr></table>

# OB_STDBY

OB_STDBY 用来选择进入 Standby 模式是否产生复位。见 Table 165. 查阅该参数可取的值

Table 165. OB_STDBY 值  

<table><tr><td>OB_STDBY</td><td>描述</td></tr><tr><td>OB_STDBY_NoRST</td><td>进入 Standby 模式不产生复位</td></tr><tr><td>OB_STDBY_RST</td><td>进入 Standby 模式产生复位</td></tr></table>

例：

/\*Option Bytes Configuration: software watchdog, Reset generation when entering in STOP and No reset generation when entering in STANDBY \*/ FLASH_Status status  $=$  FLASH_COMPLETE; status  $=$  FLASH_USEROptionByteConfig(OB_IWDG_SW, OB_STOP_RST, OB_STDBY_NoRST);

# 9.2.15 函数FLASH_GetUserOptionByte

Table 166. 描述了函数 FLASH_GetUserOptionByte  
Table 166. 函数 FLASH_GetUserOptionByte  

<table><tr><td>函数名</td><td>FLASH_GetUserOptionByte</td></tr><tr><td>函数原形</td><td>u32 FLASH_GetUserOptionByte(void)</td></tr><tr><td>功能描述</td><td>返回 FLASH 用户选择字节的值</td></tr><tr><td>输入参数</td><td>无</td></tr><tr><td>输出参数</td><td>无</td></tr><tr><td>返回值</td><td>FLASH 用户选择字节的值: IWDG_SW(Bit0),RST_STOP(Bit1) and RST_STDBY(Bit2)</td></tr><tr><td>先决条件</td><td>无</td></tr><tr><td>被调用函数</td><td>无</td></tr></table>

例：

```txt
/\*Gets the user option byte values \*/   
u32 用户ByteValue  $= 0\mathrm{x}0$    
u32 IWDGValue  $= 0\mathrm{x}0$  RST_STOPValue  $= 0\mathrm{x}0$  RST_STDBYValue  $= 0\mathrm{x}0$  ·   
UserByteValue  $=$  FLASH_GetUserInfo();   
IWDGValue  $=$  UserByteValue&0x0001;   
RST_STOPValue  $=$  UserByteValue&0x0002;   
RST_STDBYValue  $=$  UserByteValue&0x0004;
```

# 9.2.16 函数FLASH_GetWriteProtectionOptionByte

Table 167. 描述了函数 FLASH_GetWriteProtectionOptionByte  
Table 167. 函数 FLASH_GetWriteProtectionOptionByte  

<table><tr><td>函数名</td><td>FLASH_GetWriteProtectionOptionByte</td></tr><tr><td>函数原形</td><td>u32 FLASH_GetWriteProtectionOptionByte(void)</td></tr><tr><td>功能描述</td><td>返回 FLASH 写保护选择字节的值</td></tr><tr><td>输入参数</td><td>无</td></tr><tr><td>输出参数</td><td>无</td></tr><tr><td>返回值</td><td>FLASH 写保护选择字节的值</td></tr><tr><td>先决条件</td><td>无</td></tr><tr><td>被调用函数</td><td>无</td></tr></table>

例：

```txt
/\*Gets the Write Protection option byte values \*/ u32 WriteProtectionValue  $= 0\mathrm{x}0$  WriteProtectionValue  $=$  FLASH_GetWriteProtectionOptionByte();
```

# 9.2.17 函数FLASH_GetReadOutProtectionStatus

Table 168. 描述了函数 FLASH_GetReadOutProtectionStatus  
Table 168. 函数 FLASH_GetReadOutProtectionStatus  

<table><tr><td>函数名</td><td>FLASH_GetReadOutProtectionStatus</td></tr><tr><td>函数原形</td><td>FlagStatus FLASH_GetReadOutProtectionStatus(void)</td></tr><tr><td>功能描述</td><td>检查 FLASH 读出保护设置与否</td></tr><tr><td>输入参数</td><td>无</td></tr><tr><td>输出参数</td><td>无</td></tr><tr><td>返回值</td><td>FLASH 读出保护状态 (SET 或者 RESET)</td></tr><tr><td>先决条件</td><td>无</td></tr><tr><td>被调用函数</td><td>无</td></tr></table>

例：

```javascript
/\*Gets the ReadOut Protection status \*/ FlagStatus status  $=$  RESET; status  $=$  FLASH_GetReadOutProtectionStatus();
```

# 9.2.18 函数FLASH_GetPrefetchBufferStatus

Table 169. 描述了函数 FLASH_GetPrefetchBufferStatus  
Table 169. 函数 FLASH_GetPrefetchBufferStatus  

<table><tr><td>函数名</td><td>FLASH_GetPrefetchBufferStatus</td></tr><tr><td>函数原形</td><td>FlagStatus FLASH_GetPrefetchBufferStatus(void)</td></tr><tr><td>功能描述</td><td>检查 FLASH 预取指缓存设置与否</td></tr><tr><td>输入参数</td><td>无</td></tr><tr><td>输出参数</td><td>无</td></tr><tr><td>返回值</td><td>FLASH 预取指缓存状态 (SET 或者 RESET)</td></tr><tr><td>先决条件</td><td>无</td></tr><tr><td>被调用函数</td><td>无</td></tr></table>

例：

```txt
/\*Gets the Prefetch Buffer status \*/ FlagStatus status  $=$  RESET; status  $=$  FLASH_GetPrefetchBufferStatus();
```

# 9.2.19 函数FLASH_ITConfig

Table 170. 描述了函数 FLASH_ITConfig

Table 170. 函数 FLASH_ITConfig  

<table><tr><td>函数名</td><td>FLASH_ITConfig</td></tr><tr><td>函数原形</td><td>void FLASH_ITConfig(u16 FLASH_IT, FunctionalState NewState)</td></tr><tr><td>功能描述</td><td>使能或者失能指定 FLASH 中断</td></tr><tr><td>输入参数 1</td><td>FLASH_IT: 待使能或者失能的指定 FLASH 中断源
参阅 Section: FLASH_IT 查阅更多该参数允许取值范围</td></tr><tr><td>输入参数 2</td><td>NewState: 指定 FLASH 中断的新状态。
这个参数可以取: ENABLE 或者 DISABLE</td></tr><tr><td>输出参数</td><td>无</td></tr><tr><td>返回值</td><td>无</td></tr><tr><td>先决条件</td><td>无</td></tr><tr><td>被调用函数</td><td>无</td></tr></table>

# FLASH_IT

FLASH_IT用来使能或者失能指定的FLASH中断。见Table171.查阅该参数可取的值

Table 171. FLASH IT 值  

<table><tr><td>FLASH_IT</td><td>描述</td></tr><tr><td>FLASH_IT_ERROR</td><td>FPEC错误中断源</td></tr><tr><td>FLASH_IT_EOP</td><td>FLASH操作结束中断源</td></tr></table>

例：

```sql
/\*Enables the EOP Interrupt source \*/ FLASH_ITConfig(FLASH_IT_EOP，ENABLE);
```

# 9.2.20 函数FLASH_GetFlagStatus

Table 172. 描述了函数 FLASH_GetFlagStatus

Table 172. 函数 FLASH_GetFlagStatus  

<table><tr><td>函数名</td><td>FLASH_GetFlagStatus</td></tr><tr><td>函数原形</td><td>FlagStatus FLASH_GetFlagStatus(u16 FLASH_FLAG)</td></tr><tr><td>功能描述</td><td>检查指定的 FLASH 标志位设置与否</td></tr><tr><td>输入参数</td><td>FLASH_FLAG: 待检查的标志位
参阅 Section: FLASH_FLAG 查阅更多该参数允许取值范围</td></tr><tr><td>输出参数</td><td>无</td></tr><tr><td>返回值</td><td>无</td></tr><tr><td>先决条件</td><td>无</td></tr><tr><td>被调用函数</td><td>无</td></tr></table>

# FLASH_FLAG

FLASH_FLAG 为能够被函数 FLASH_GetFlagStatus 检查的标志位。它们列举于下表:

Table 173. FLASH_FLAG 值  

<table><tr><td>FLASH_FLAG</td><td>描述</td></tr><tr><td>FLASH_FLAG_BSY</td><td>FLASH忙标志位</td></tr><tr><td>FLASH_FLAG_EOP</td><td>FLASH操作结束标志位</td></tr><tr><td>FLASH_FLAG_PGERR</td><td>FLASH编写错误标志位</td></tr></table>

# ST

译文英文原版为UM0427 Oct. 2007 Rev 2, 译文仅供参考，与英文版冲突的，以英文版为准

FLASH

<table><tr><td>FLASH_FLAG_WRPRTERR</td><td>FLASH页面写保护错误标志位</td></tr><tr><td>FLASH_FLAG_OPTERR</td><td>FLASH选择字节错误标志位</td></tr></table>

例：

/\* Checks whether the EOP Flag Status is SET or not \*/

FlagStatus status = RESET;

status = FLASH_GetFlagStatus(FLASH_FLAG_EOP);

# 9.2.21 函数FLASH_ClearFlag

Table 174. 描述了函数 FLASH_ClearFlag  
Table 174. 函数 FLASH_ClearFlag  

<table><tr><td>函数名</td><td>FLASH_ClearFlag</td></tr><tr><td>函数原形</td><td>void FLASH_ClearFlag(u16 FLASH_Flag)</td></tr><tr><td>功能描述</td><td>清除 FLASH 待处理标志位</td></tr><tr><td>输入参数</td><td>FLASH_FLAG: 待清除的标志位
参阅 Section: FLASH_FLAG 查阅更多该参数允许取值范围</td></tr><tr><td>输出参数</td><td>无</td></tr><tr><td>返回值</td><td>无</td></tr><tr><td>先决条件</td><td>无</td></tr><tr><td>被调用函数</td><td>无</td></tr></table>

# FLASH_FLAG

FLASH_FLAG 为能够被函数 FLASH_ClearFlag 清除的标志位。它们列举于下表:

Table 175. FLASH_FLAG 值  

<table><tr><td>FLASH_FLAG</td><td>描述</td></tr><tr><td>FLASH_FLAG_BSY</td><td>FLASH忙标志位</td></tr><tr><td>FLASH_FLAG_EOP</td><td>FLASH操作结束标志位</td></tr><tr><td>FLASH_FLAG_PGERR</td><td>FLASH编写错误标志位</td></tr><tr><td>FLASH_FLAG_WRPRTERR</td><td>FLASH页面写保护错误标志位</td></tr></table>

例：

/* Clears all flags */

FLASH_ClearFlag(FLASH_FLAG_BSY|FLASH_FLAG_EOP|FLASH_FLAG_PGER

| FLASH_FLAG_WRPTERR) ;

# 9.2.22 函数FLASH_GetStatus

Table 176. 描述了函数 FLASH_GetStatus  
Table 176. 函数 FLASH_GetStatus  

<table><tr><td>函数名</td><td>FLASH_GetStatus</td></tr><tr><td>函数原形</td><td>FLASH_Status FLASH_GetStatus(void)</td></tr><tr><td>功能描述</td><td>返回 FLASH 状态</td></tr><tr><td>输入参数</td><td>无</td></tr><tr><td>输出参数</td><td>无</td></tr><tr><td>返回值</td><td>FLASH_Status: 返回值可以是: FLASH_BUSY,
FLASH_ERROR_PG, FLASH_ERROR_WRP 或者
FLASH_COMPLETE</td></tr><tr><td>先决条件</td><td>无</td></tr><tr><td>被调用函数</td><td>无</td></tr></table>

例：
/* Check for the Flash status */
FLASH_Status status = FLASH_COMPLETE;
status = FLASH_GetStatus();

# 9.2.23 函数FLASH_WaitForLastOperation

Table 177. 描述了函数 FLASH_WaitForLastOperation  
Table 177. 函数 FLASH_WaitForLastOperation  

<table><tr><td>函数名</td><td>FLASH_WaitForLastOperation</td></tr><tr><td>函数原形</td><td>FLASH_Status FLASH_WaitForLastOperation(u32 Timeout)</td></tr><tr><td>功能描述</td><td>等待某一个Flash操作完成，或者发生TIMEOUT</td></tr><tr><td>输入参数</td><td>无</td></tr><tr><td>输出参数</td><td>无</td></tr><tr><td>返回值</td><td>返回适当的操作状态。
这个参数可以是: FLASH_BUSY, FLASH_ERROR_PG, FLASH_ERROR_WRP, FLASH_COMPLETE 或者 FLASH_TIMEOUT</td></tr><tr><td>先决条件</td><td>无</td></tr><tr><td>被调用函数</td><td>无</td></tr></table>

例：
/* Waits for the Flash operation to be completed */
FLASH_Status status = FLASH_COMPLETE;
status = FLASH_WaitForLastOperation();

# 10 通用输入/输出（GPIO）

GPIO驱动可以用作多个用途，包括管脚设置，单位设置/重置，锁定机制，从端口管脚读入或者向端口管脚写入数据。

Section 10.1 GPIO 寄存器结构描述了固件函数库所使用的数据结构, Section 10.2 固件库函数介绍了函数库里的所有函数。

# 10.1 GPIO寄存器结构

GPIO 寄存器结构，GPIOTypeDef 和 AFIOTypeDef，在文件“stm32f10x_map.h”中定义如下：

```c
typedef struct  
{  
vu32 CRL;  
vu32 CRH;  
vu32 IDR;  
vu32 ODR;  
vu32 BSRR;  
vu32 BRR;  
vu32 LCKR;  
} GPIOTypeDef;  
typedef struct  
{  
vu32 EVCR;  
vu32 MAPR;  
vu32 EXTICR[4];  
} AFIOTypeDef;
```

Table 178.例举了 GPIO 所有寄存器

Table 178. GPIO 寄存器  

<table><tr><td>寄存器</td><td>描述</td></tr><tr><td>CRL</td><td>端口配置低寄存器</td></tr><tr><td>CRH</td><td>端口配置高寄存器</td></tr><tr><td>IDR</td><td>端口输入数据寄存器</td></tr><tr><td>ODR</td><td>端口输出数据寄存器</td></tr><tr><td>BSRR</td><td>端口位设置/复位寄存器</td></tr><tr><td>BRR</td><td>端口位复位寄存器</td></tr><tr><td>LCKR</td><td>端口配置锁定寄存器</td></tr><tr><td>EVCR</td><td>事件控制寄存器</td></tr><tr><td>MAPR</td><td>复用重映射和调试I/O配置寄存器</td></tr><tr><td>EXTICR</td><td>外部中断线路0-15配置寄存器</td></tr></table>

五个 GPIO 外设声明于文件“stm32f10x_map.h”：

```c
define PERIPH_BASE ((u32)0x40000000)
#define APB1PERIPH_BASE PERIPH_BASE
#define APB2PERIPH_BASE (PERIPH_BASE + 0x10000)
#define AHBPERIPH_BASE (PERIPH_BASE + 0x20000)
...
#define AFIO_BASE (APB2PERIPH_BASE + 0x0000)
#define GPIOA_BASE (APB2PERIPH_BASE + 0x0800)
#define GPIOB_BASE (APB2PERIPH_BASE + 0x0C00)
#define GPIOC_BASE (APB2PERIPH_BASE + 0x1000)
#define GPIOD_BASE (APB2PERIPH_BASE + 0x1400)
#define GPIOE_BASE (APB2PERIPH_BASE + 0x1800)
#ifndef DEBUG
```

ST

译文英文原版为UM0427 Oct. 2007 Rev 2, 译文仅供参考，与英文版冲突的，以英文版为准

```txt
ifdef_AFIO
define AFIO ((AFIO_TYPEDef *) AFIO_BASE)
endif /*_AFIO */
ifdef_GPIOA
define GPIOA ((GPIO_TYPEDef *) GPIOA_BASE)
endif /*_GPIOA */
ifdef_GPIOB
define GPIOB ((GPIO_TYPEDef *) GPIOB_BASE)
endif /*_GPIOB */
ifdef_GPIOC
define GPIOC ((GPIO_TYPEDef *) GPIOC_BASE)
endif /*_GPIOC */
ifdef_GPIOD
define GPIOD ((GPIO_TYPEDef *) GPIOD_BASE)
endif /*_GPIOD */
ifdef_GPIOE
define GPIOE ((GPIO_TYPEDef *) GPIOE_BASE)
endif /*_GPIOE */
...
else /* DEBUG */
...
ifdef_AFIO
EXT AFIO_TYPEDef *AFIO;
endif /*_AFIO */
ifdef_GPIOA
EXT GPI_O_TypeDef *GPIOA;
endif /*_GPIOA */
ifdef_GPIOB
EXT GPI_O_TypeDef *GPIOB;
endif /*_GPIOB */
ifdef_GPIOC
EXT GPI_O_TypeDef *GPIOC;
endif /*_GPIOC */
ifdef_GPIOD
EXT GPI_O_TypeDef *GPIOD;
endif /*_GPIOD */
ifdef_GPIOE
EXT GPI_O_TypeDef *GPIOE;
endif /*_GPIOE */
...
endif
```

使用Debug模式时，初始化指针AFIO,GPIOA,GPIOB,GPIOC,GPIOD和GPIOE

于文件“stm32f10x_lib.c”：

```c
#ifndef __GPIOA
GPIOA = (GPIOTypeDef *) GPIOA_BASE;
#include <pi> __GPIOAB
#include <pi>
GPIOB = (GPIOTypeDef *) GPIOB_BASE;
#include <pi>
GPIOC = (GPIOTypeDef *) GPIOC_BASE;
#include <pi>
GPIOC */
#include <pi>
GPIOD = (GPIOTypeDef *) GPIOD_BASE;
#include <pi>
GPIOD */
#include <pi>
GPIOE = (GPIOTypeDef *) GPIOE_BASE;
#include <pi>
GPIOE */
#include <pi>
AFIO
AFIO = (AFIOTypeDef *) AFIO_BASE;
#include <pi>
```

为了访问 GPIO 寄存器，, _GPIO, _AFIO, _GPIOA, _GPIOB, _GPIOC, _GPIOD 和 _GPIOE 必须在文件“stm32f10x_conf.h”中定义如下：

```c
define GPIO
#define __GPIOA
#define __GPIOB
#define __GPIOC
#define __GPIOD
```

# 10.2 GPIO库函数

Table 179. 例举了 GPIO 的库函数  
Table 179. GPIO 库函数  

<table><tr><td>函数名</td><td>描述</td></tr><tr><td>GPIO_DeInit</td><td>将外设 GPIOx 寄存器重设为缺省值</td></tr><tr><td>GPIO_AFIODEInit</td><td>将复用功能（重映射事件控制和EXTI设置）重设为缺省值</td></tr><tr><td>GPIO_Init</td><td>根据 GPIO_InitStruct 中指定的参数初始化外设 GPIOx 寄存器</td></tr><tr><td>GPIOSTRUCTInit</td><td>把 GPIO_InitStruct 中的每一个参数按缺省值填入</td></tr><tr><td>GPIO_ReadInputDataBit</td><td>读取指定端口管脚的输入</td></tr><tr><td>GPIO_ReadInputData</td><td>读取指定的 GPIO 端口输入</td></tr><tr><td>GPIO_ReadOutputDataBit</td><td>读取指定端口管脚的输出</td></tr><tr><td>GPIO_ReadOutputData</td><td>读取指定的 GPIO 端口输出</td></tr><tr><td>GPIO_SetBits</td><td>设置指定的数据端口位</td></tr><tr><td>GPIORESETBits</td><td>清除指定的数据端口位</td></tr><tr><td>GPIO_WritesBit</td><td>设置或者清除指定的数据端口位</td></tr><tr><td>GPIO_Write</td><td>向指定 GPIO 数据端口写入数据</td></tr><tr><td>GPIO_PinLockConfig</td><td>锁定 GPIO 管脚设置寄存器</td></tr><tr><td>GPIO_EventOutputConfig</td><td>选择 GPIO 管脚用作事件输出</td></tr><tr><td>GPIO_EventOutputCmd</td><td>使能或者失能事件输出</td></tr><tr><td>GPIO_PinRemapConfig</td><td>改变指定管脚的映射</td></tr><tr><td>GPIO_EXTILineConfig</td><td>选择 GPIO 管脚用作外部中断线路</td></tr></table>

# 10.2.1 函数GPIO_DeInit

Table 180. 描述了函数 GPIO_DeInit  
Table 180. 函数 GPIO_DeInit  

<table><tr><td>函数名</td><td>GPIO_DeInit</td></tr><tr><td>函数原形</td><td>void GPIO_DeInit(GPIO_TYPEDef* GPIOx)</td></tr><tr><td>功能描述</td><td>将外设 GPIOx 寄存器重设为缺省值</td></tr><tr><td>输入参数</td><td>GPIOx: x 可以是 A, B, C, D 或者 E, 来选择 GPIO 外设</td></tr><tr><td>输出参数</td><td>无</td></tr><tr><td>返回值</td><td>无</td></tr><tr><td>先决条件</td><td>无</td></tr><tr><td>被调用函数</td><td>RCC_AP2PeriphResetCmd()</td></tr></table>

例：

```txt
/* Resets the GPIOA peripheral registers to their default reset values */
GPIO_DeInit(GPIOA);
```

# 10.2.2 函数GPIO_AFIODeInit

Table 181. 描述了函数 GPIO_AFIODeInit  
Table 181. 函数 GPIO_AFIODeInit  

<table><tr><td>函数名</td><td>GPIO_AFIODeInit</td></tr><tr><td>函数原形</td><td>void GPIO_AFIODeInit(void)</td></tr><tr><td>功能描述</td><td>将复用功能（重映射事件控制和EXTI设置）重设为缺省值</td></tr><tr><td>输入参数</td><td>无</td></tr><tr><td>输出参数</td><td>无</td></tr><tr><td>返回值</td><td>无</td></tr><tr><td>先决条件</td><td>无</td></tr><tr><td>被调用函数</td><td>RCC_AP2PeriphResetCmd()</td></tr></table>

例：

```txt
/* Resets the Alternate functions registers to their default reset values */
GPIO_AFIODEInit();
```

# 10.2.3 函数GPIO_Init

Table 182. 描述了函数 GPIO_Init  
Table 182. 函数 GPIO_Init  

<table><tr><td>函数名</td><td>GPIO_Init</td></tr><tr><td>函数原形</td><td>void GPIO_Init(GPIO_TYPEDef* GPIOx, GPIO_InitTypeDef* GPIO_InitStruct)</td></tr><tr><td>功能描述</td><td>根据 GPIO_InitStruct 中指定的参数初始化外设 GPIOx 寄存器</td></tr><tr><td>输入参数 1</td><td>GPIOx: x 可以是 A, B, C, D 或者 E, 来选择 GPIO 外设</td></tr><tr><td>输入参数 2</td><td>GPIO_InitStruct: 指向结构 GPIO_InitTypeDef 的指针, 包含了外设 GPIO 的配置信息参阅 Section: GPIO_InitTypeDef 查阅更多该参数允许取值范围</td></tr><tr><td>输出参数</td><td>无</td></tr><tr><td>返回值</td><td>无</td></tr><tr><td>先决条件</td><td>无</td></tr><tr><td>被调用函数</td><td>无</td></tr></table>

# GPIO_InitTypeDef structure

GPIO_InitTypeDef 定义于文件“stm32f10x_gpio.h”：

typedef struct

{

u16 GPIO Pin;

GPIOSpeed TypeDef GPIO Speed;

GPIOModeTypeDef GPIO Mode;

} GPIO_InitTypeDef;

# GPIO_Pin

该参数选择待设置的 GPIO 管脚，使用操作符“|”可以一次选中多个管脚。可以使用下表中的任意组合。

Table 183. GPIO_Pin 值  

<table><tr><td>GPIO_Pin</td><td>描述</td></tr><tr><td>GPIO_Pin_None</td><td>无管脚被选中</td></tr><tr><td>GPIO_Pin_0</td><td>选中管脚0</td></tr><tr><td>GPIO_Pin_1</td><td>选中管脚1</td></tr><tr><td>GPIO_Pin_2</td><td>选中管脚2</td></tr><tr><td>GPIO_Pin_3</td><td>选中管脚3</td></tr><tr><td>GPIO_Pin_4</td><td>选中管脚4</td></tr><tr><td>GPIO_Pin_5</td><td>选中管脚5</td></tr><tr><td>GPIO_Pin_6</td><td>选中管脚6</td></tr><tr><td>GPIO_Pin_7</td><td>选中管脚7</td></tr><tr><td>GPIO_Pin_8</td><td>选中管脚8</td></tr><tr><td>GPIO_Pin_9</td><td>选中管脚9</td></tr><tr><td>GPIO_Pin_10</td><td>选中管脚10</td></tr><tr><td>GPIO_Pin_11</td><td>选中管脚11</td></tr><tr><td>GPIO_Pin_12</td><td>选中管脚12</td></tr><tr><td>GPIO_Pin_13</td><td>选中管脚13</td></tr><tr><td>GPIO_Pin_14</td><td>选中管脚14</td></tr><tr><td>GPIO_Pin_15</td><td>选中管脚15</td></tr><tr><td>GPIO_Pin_All</td><td>选中全部管脚</td></tr></table>

# GPIO_Speed

GPIO_Speed 用以设置选中管脚的速率。Table 184. 给出了该参数可取的值

Table 184. GPIO_Speed 值  

<table><tr><td>GPIO_Speed</td><td>描述</td></tr><tr><td>GPIO_Speed_10MHz</td><td>最高输出速率 10MHz</td></tr><tr><td>GPIO_Speed_2MHz</td><td>最高输出速率 2MHz</td></tr><tr><td>GPIO_Speed_50MHz</td><td>最高输出速率 50MHz</td></tr></table>

# GPIO_Mode

GPIO_Mode 用以设置选中管脚的工作状态。Table 185. 给出了该参数可取的值

Table 185. GPIO_Mode 值  

<table><tr><td>GPIO_Speed</td><td>描述</td></tr><tr><td>GPIO_Mode_AIN</td><td>模拟输入</td></tr><tr><td>GPIO_Mode_IN_FLOATING</td><td>浮空输入</td></tr><tr><td>GPIO_Mode_IPD</td><td>下拉输入</td></tr><tr><td>GPIO_Mode_IPU</td><td>上拉输入</td></tr><tr><td>GPIO_Mode_Out_OD</td><td>开漏输出</td></tr><tr><td>GPIO_Mode_Out_PP</td><td>推挽输出</td></tr><tr><td>GPIO_Mode_AF_OD</td><td>复用开漏输出</td></tr><tr><td>GPIO_Mode_AF_PP</td><td>复用推挽输出</td></tr></table>

注意：  
当某管脚设置为上拉或者下拉输入模式，使用寄存器  $\mathrm{Px\_BSRR}$  和  $\mathrm{PxBRR}$  
■ GPIO_Mode 允许同时设置 GPIO 方向（输入/输出）和对应的输入/输出设置，：位[7:4]对应 GPIO 方向，位[4:0]对应配置。GPIO 方向有如下索引

- GPIO 输入模式 = 0x00  
- GPIO 输出模式 = 0x01

Table 186. 给出了所有 GPIO_Mode 的索引和编码  
Table 186. GPIO_Mode 的索引和编码  

<table><tr><td>GPIO方向</td><td>索引</td><td>模式</td><td>设置</td><td>模式代码</td></tr><tr><td rowspan="4">GPIO Input</td><td rowspan="4">0x00</td><td>GPIO_Mode_AIN</td><td>0x00</td><td>0x00</td></tr><tr><td>GPIO_Mode_IN_FLOATING</td><td>0x04</td><td>0x04</td></tr><tr><td>GPIO_Mode_IPD</td><td>0x08</td><td>0x28</td></tr><tr><td>GPIO_Mode_IPU</td><td>0x08</td><td>0x48</td></tr><tr><td rowspan="4">GPIO Output</td><td rowspan="4">0x01</td><td>GPIO_Mode_Out_OD</td><td>0x04</td><td>0x14</td></tr><tr><td>GPIO_Mode_Out_PP</td><td>0x00</td><td>0x10</td></tr><tr><td>GPIO_Mode_AF_OD</td><td>0x0C</td><td>0x1C</td></tr><tr><td>GPIO_Mode_AF_PP</td><td>0x08</td><td>0x18</td></tr></table>

例：  
/* Configure all the GPIOA in Input Floating mode */
GPIO_InitTypeDef GPIO_InitStructure;
GPIO_InitStructure.GPIO_Pin = GPIO_Pin_All;
GPIO_InitStructure.GPIO_Speed = GPIO_Speed_10MHz;
GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IN_FLOATING;
GPIO_Init(GPIOA, &GPIO_InitStructure);

# 10.2.4 函数GPIOSTRUCTInit

Table 187. 描述了函数 GPIOSTRUCTInit

Table 187. 函数 GPIOStructInit  

<table><tr><td>函数名</td><td>GPIOStructInit</td></tr><tr><td>函数原形</td><td>void GPIOStructInit(GPIO_InitTypeDef* GPIO_InitStruct)</td></tr><tr><td>功能描述</td><td>把 GPIO_InitStruct 中的每一个参数按缺省值填入</td></tr><tr><td>输入参数</td><td>GPIO_InitStruct: 指向结构 GPIO_InitTypeDef 的指针, 待初始化</td></tr><tr><td>输出参数</td><td>无</td></tr><tr><td>返回值</td><td>无</td></tr><tr><td>先决条件</td><td>无</td></tr><tr><td>被调用函数</td><td>无</td></tr></table>

Table 188. 给出了 GPIO_InitStruct 各个成员的缺省值

Table 188. GPIO_InitStruct 缺省值  

<table><tr><td>成员</td><td>缺省值</td></tr><tr><td>GPIO_Pin</td><td>GPIO_Pin_All</td></tr><tr><td>GPIO_Speed</td><td>GPIO_Speed_2MHz</td></tr><tr><td>GPIO_Mode</td><td>GPIO_Mode_IN_FLOATING</td></tr></table>

例：

/* Initialize the GPIO Init Structure parameters */

GPIO_InitTypeDef GPIO_InitStructure;

GPIOSTRUCTInit(&GPIO_InitStructure);

# 10.2.5 函数GPIO_GetReadingDataBit

Table 189. 描述了函数 GPIO_ReadInputDataBit

Table 189. 函数 GPIO_InputDataBit  

<table><tr><td>函数名</td><td>GPIO_ReadInputDataBit</td></tr><tr><td>函数原形</td><td>u8 GPIO_ReadInputDataBit(GPIO_TYPEDef* GPIOx, u16 GPIO_Pin)</td></tr><tr><td>功能描述</td><td>读取指定端口管脚的输入</td></tr><tr><td>输入参数1</td><td>GPIOx: x可以是A, B, C, D或者E, 来选择GPIO外设</td></tr><tr><td>输入参数2</td><td>GPIO_Pin: 待读取的端口位
参阅 Section: GPIO_Pin 查阅更多该参数允许取值范围</td></tr><tr><td>输出参数</td><td>无</td></tr><tr><td>返回值</td><td>输入端口管脚值</td></tr><tr><td>先决条件</td><td>无</td></tr><tr><td>被调用函数</td><td>无</td></tr></table>

例：

/* Reads the seventh pin of the GPIO and store it in ReadValue

variable \*/

u8 ReadValue;

ReadValue = GPIO_ReadInputDataBit(GPIO, GPIO_Pin_7);

# 10.2.6 函数GPIOREADINGInputData

Table 190. 描述了函数 GPIO_InputData

Table 190. 函数 GPIO_ReadInputData  

<table><tr><td>函数名</td><td>GPIO_ReadInputData</td></tr><tr><td>函数原形</td><td>u16 GPIO_ReadInputData(GPIOTypeDef* GPIOx)</td></tr><tr><td>功能描述</td><td>读取指定的 GPIO 端口输入</td></tr><tr><td>输入参数</td><td>GPIOx: x 可以是 A, B, C, D 或者 E, 来选择 GPIO 外设</td></tr><tr><td>输出参数</td><td>无</td></tr><tr><td>返回值</td><td>GPIO 输入数据端口值</td></tr><tr><td>先决条件</td><td>无</td></tr><tr><td>被调用函数</td><td>无</td></tr></table>

例：  
/*Read the GPIOC input data port and store it in ReadValue variable*/  
u16 ReadValue;  
ReadValue = GPIO_ReadInputData(GPIOC);

# 10.2.7 函数GPIO_GetOutputDataBit

Table 191. 描述了 GPIO_ReadOutputDataBit

Table 191. 函数 GPIO_ReadOutputDataBit  

<table><tr><td>函数名</td><td>GPIO_ReadOutputDataBit</td></tr><tr><td>函数原形</td><td>u8 GPIO_ReadOutputDataBit(GPIO_TYPEDef* GPIOx, u16 GPIO_Pin)</td></tr><tr><td>功能描述</td><td>读取指定端口管脚的输出</td></tr><tr><td>输入参数1</td><td>GPIOx: x 可以是 A, B, C, D 或者 E, 来选择 GPIO 外设</td></tr><tr><td>输入参数2</td><td>GPIO_Pin: 待读取的端口位
参阅 Section: GPIO_Pin 查阅更多该参数允许取值范围</td></tr><tr><td>输出参数</td><td>无</td></tr><tr><td>返回值</td><td>输出端口管脚值</td></tr><tr><td>先决条件</td><td>无</td></tr><tr><td>被调用函数</td><td>无</td></tr></table>

例：  
/\*Reads the seventh pin of the GPIO and store it in ReadValue variable \*/   
u8 ReadValue;   
ReadValue  $=$  GPIO_ReadOutputDataBit(GPIO,GPIO_Pin_7);

# 10.2.8 函数GPIO_ReadOutputData

Table 192. 描述了函数 GPIO_ReadOutputData  
Table 192. 函数 GPIO_ReadOutputData  

<table><tr><td>函数名</td><td>GPIO_ReadOutputData</td></tr><tr><td>函数原形</td><td>u16 GPIO_ReadOutputData(GPIO_TYPEDef* GPIOx)</td></tr><tr><td>功能描述</td><td>读取指定的 GPIO 端口输出</td></tr><tr><td>输入参数</td><td>GPIOx: x 可以是 A, B, C, D 或者 E, 来选择 GPIO 外设</td></tr><tr><td>输出参数</td><td>无</td></tr><tr><td>返回值</td><td>GPIO 输出数据端口值</td></tr><tr><td>先决条件</td><td>无</td></tr><tr><td>被调用函数</td><td>无</td></tr></table>

例：  
/* Read the GPIOC output data port and store it in ReadValue variable */  
u16 ReadValue;  
ReadValue = GPIO_ReadOutputData(GPIOC);

# 10.2.9 函数GPIO_SetBits

Table 193. 描述了 GPIO_SetBits  
Table 193. 函数 GPIO_SetBits  

<table><tr><td>函数名</td><td>GPIO_SetBits</td></tr><tr><td>函数原形</td><td>void GPIO_SetBits(GPIOTypeDef* GPIOx, u16 GPIO_Pin)</td></tr><tr><td>功能描述</td><td>设置指定的数据端口位</td></tr><tr><td>输入参数1</td><td>GPIOx: x可以是A, B, C, D或者E, 来选择GPIO外设</td></tr><tr><td>输入参数2</td><td>GPIO_Pin: 待设置的端口位
该参数可以取GPIO_Pin_x(x可以是0-15)的任意组合
参阅 Section: GPIO_Pin 查阅更多该参数允许取值范围</td></tr><tr><td>输出参数</td><td>无</td></tr><tr><td>返回值</td><td>无</td></tr><tr><td>先决条件</td><td>无</td></tr><tr><td>被调用函数</td><td>无</td></tr></table>

例：
/* Set the GPIOA port pin 10 and pin 15 */
GPIO_SetBits(GPIOA, GPIO_Pin_10 | GPIO_Pin_15);

# 10.2.10 函数GPIO_SetBits

Table 194. 描述了 GPIO ResetBits  
Table 194. 函数 GPIO ResetBits  

<table><tr><td>函数名</td><td>GPIORESETBits</td></tr><tr><td>函数原形</td><td>void GPIO ResetBits(GPIO_TYPEDef* GPIOx, u16 GPIO_Pin)</td></tr><tr><td>功能描述</td><td>清除指定的数据端口位</td></tr><tr><td>输入参数1</td><td>GPIOx: x可以是A, B, C, D或者E, 来选择GPIO外设</td></tr><tr><td>输入参数2</td><td>GPIO_Pin: 待清除的端口位
该参数可以取GPIO_Pin_x(x可以是0-15)的任意组合
参阅 Section: GPIO_Pin 查阅更多该参数允许取值范围</td></tr><tr><td>输出参数</td><td>无</td></tr><tr><td>返回值</td><td>无</td></tr><tr><td>先决条件</td><td>无</td></tr><tr><td>被调用函数</td><td>无</td></tr></table>

例：
/* Clears the GPIOA port pin 10 and pin 15 */
GPIO ResetBits(GPIOA, GPIO_Pin_10 | GPIO_Pin_15);

# 10.2.11 函数GPIO_Writes

Table 195. 描述了 GPIO_Writes  
Table 195. 函数 GPIO_Writes  

<table><tr><td>函数名</td><td>GPIO_WritesBit</td></tr><tr><td>函数原形</td><td>void GPIO_WritesBit(GPIO_TYPEDef* GPIOx, u16 GPIO_Pin, BitAction BitVal)</td></tr><tr><td>功能描述</td><td>设置或者清除指定的数据端口位</td></tr><tr><td>输入参数1</td><td>GPIOx: x可以是A, B, C, D或者E, 来选择GPIO外设</td></tr><tr><td>输入参数2</td><td>GPIO_Pin: 待设置或者清除指的端口位
该参数可以取GPIO_Pin_x(x 可以是0-15)的任意组合
参阅 Section: GPIO_Pin 查阅更多该参数允许取值范围</td></tr><tr><td>输入参数3</td><td>BitVal: 该参数指定了待写入的值
该参数必须取枚举BitAction 的其中一个值
Bit_RESET: 清除数据端口位
Bit_SET: 设置数据端口位</td></tr><tr><td>输出参数</td><td>无</td></tr><tr><td>返回值</td><td>无</td></tr><tr><td>先决条件</td><td>无</td></tr><tr><td>被调用函数</td><td>无</td></tr></table>

例：
/* Set the GPIOA port pin 15 */
GPIO_writeBit(GPIOA, GPIO_Pin_15, Bit_SET);

# 10.2.12 函数GPIO_Writes

Table 196. 描述了 GPIO_Write  
Table 196. 函数 GPIO_Write  

<table><tr><td>函数名</td><td>GPIO Write</td></tr><tr><td>函数原形</td><td>void GPIO_Writ(GPIO_TYPEDef* GPIOx, u16 PortVal)</td></tr><tr><td>功能描述</td><td>向指定 GPIO 数据端口写入数据</td></tr><tr><td>输入参数 1</td><td>GPIOx: x 可以是 A, B, C, D 或者 E, 来选择 GPIO 外设</td></tr><tr><td>输入参数 2</td><td>PortVal: 待写入端口数据寄存器的值</td></tr><tr><td>输出参数</td><td>无</td></tr><tr><td>返回值</td><td>无</td></tr><tr><td>先决条件</td><td>无</td></tr><tr><td>被调用函数</td><td>无</td></tr></table>

例：  
/* Write data to GPIOA data port */
GPIO_write(GPIOA, 0x1101);

# 10.2.13 函数GPIO_PinLockConfig

Table 197. 描述了 GPIO_PinLockConfig  
Table 197. 函数 GPIO_PinLockConfig  

<table><tr><td>函数名</td><td>GPIO_PinLockConfig</td></tr><tr><td>函数原形</td><td>void GPIO_PinLockConfig(GPIO_TYPEDef* GPIOx, u16 GPIO_Pin)</td></tr><tr><td>功能描述</td><td>锁定 GPIO 管脚设置寄存器</td></tr><tr><td>输入参数 1</td><td>GPIOx: x 可以是 A, B, C, D 或者 E, 来选择 GPIO 外设</td></tr><tr><td>输入参数 2</td><td>GPIO_Pin: 待锁定的端口位
该参数可以取 GPIO_Pin_x(x 可以是 0-15)的任意组合
参阅 Section: GPIO_Pin 查阅更多该参数允许取值范围</td></tr><tr><td>输出参数</td><td>无</td></tr><tr><td>返回值</td><td>无</td></tr><tr><td>先决条件</td><td>无</td></tr><tr><td>被调用函数</td><td>无</td></tr></table>

例：  
/* Lock GPIOA Pin0 and Pin1 */
GPIO_PINLockConfig(GPIOA, GPIO_PIN_0 | GPIO_PIN_1);

# 10.2.14 函数GPIO_EventOutputConfig

Table 198. 描述了 GPIO_EventOutputConfig

Table 198. 函数 GPIO_EventOutputConfig  

<table><tr><td>函数名</td><td>GPIO_EventOutputConfig</td></tr><tr><td>函数原形</td><td>void GPIO_EventOutputConfig(u8 GPIO_PortSource, u8 GPIO_PinSource)</td></tr><tr><td>功能描述</td><td>选择 GPIO 管脚用作事件输出</td></tr><tr><td>输入参数 1</td><td>GPIO_PortSource: 选择用作事件输出的 GPIO 端口
参阅 Section: GPIO_PortSource 查阅更多该参数允许取值范围</td></tr><tr><td>输入参数 2</td><td>GPIO_PinSource: 事件输出的管脚
该参数可以取 GPIO_PinSourcex(x 可以是 0-15)</td></tr><tr><td>输出参数</td><td>无</td></tr><tr><td>返回值</td><td>无</td></tr><tr><td>先决条件</td><td>无</td></tr><tr><td>被调用函数</td><td>无</td></tr></table>

# GPIO_PortSource

GPIO_PortSource 用以选择用作事件输出的 GPIO 端口。Table 199. 给出了该参数可取的值

Table 199. GPIO_PortSource 值  

<table><tr><td>GPIO_PortSource</td><td>描述</td></tr><tr><td>GPIO_PortSourceGPIOA</td><td>选择 GPIOA</td></tr><tr><td>GPIO_PortSourceGPIOB</td><td>选择 GPIOB</td></tr><tr><td>GPIO_PortSourceGPIOC</td><td>选择 GPIOC</td></tr><tr><td>GPIO_PortSourceGPIOD</td><td>选择 GPIOD</td></tr><tr><td>GPIO_PortSourceGPIOE</td><td>选择 GPIOE</td></tr></table>

例：

```txt
/* Selects the GPIO pin 5 for EVENT output */
GPIO_EventOutputConfig(GPIO_PortSourceGPIO, GPIO_PinSource5);
```

# 10.2.15 函数GPIO_EventOutputCmd

Table 200. 描述了 GPIO_EventOutputCmd

Table 200. 函数 GPIO_EventOutputCmd  

<table><tr><td>函数名</td><td>GPIO_EventOutputCmd</td></tr><tr><td>函数原形</td><td>void GPIO_EventOutputCmd(FunctionalState NewState)</td></tr><tr><td>功能描述</td><td>使能或者失能事件输出</td></tr><tr><td>输入参数1</td><td>NewState: 事件输出的新状态
这个参数可以取: ENABLE 或者 DISABLE</td></tr><tr><td>输出参数</td><td>无</td></tr><tr><td>返回值</td><td>无</td></tr><tr><td>先决条件</td><td>无</td></tr><tr><td>被调用函数</td><td>无</td></tr></table>

例：

```c
/\*EnableEventOutput to the GPIO pin 6 \*/ GPIO_EventOutputConfig(GPIO_PortSourceGPIOC，GPIO_PinSource6); GPIO_EventOutputCmd(ENABLE)；
```

# 10.2.16 函数GPIO_PinRemapConfig

Table 201. 描述了 GPIO_PinRemapConfig

Table 201. 函数 GPIO_PinRemapConfig  

<table><tr><td>函数名</td><td>GPIO_PinRemapConfig</td></tr><tr><td>函数原形</td><td>void GPIO_PinRemapConfig(u32 GPIO_Remap, FunctionalState NewState)</td></tr><tr><td>功能描述</td><td>改变指定管脚的映射</td></tr><tr><td>输入参数1</td><td>GPIO_Remap: 选择重映射的管脚
参阅 Section: GPIO_Remap 查阅更多该参数允许取值范围</td></tr><tr><td>输入参数2</td><td>NewState: 管脚重映射的新状态
这个参数可以取: ENABLE 或者 DISABLE</td></tr><tr><td>输出参数</td><td>无</td></tr><tr><td>返回值</td><td>无</td></tr><tr><td>先决条件</td><td>无</td></tr><tr><td>被调用函数</td><td>无</td></tr></table>

# GPIO_Remap

GPIO_Remap 用以选择用作事件输出的 GPIO 端口。Table 202. 给出了该参数可取的值

Table 202. GPIO_Remap 值  

<table><tr><td>GPIO_Remap</td><td>描述</td></tr><tr><td>GPIO_Remap_SPI1</td><td>SPI1 复用功能映射</td></tr><tr><td>GPIO_Remap_I2C1</td><td>I2C1 复用功能映射</td></tr><tr><td>GPIO_Remap_USART1</td><td>USART1 复用功能映射</td></tr><tr><td>GPIO_PartialRemap_USART3</td><td>USART2 复用功能映射</td></tr><tr><td>GPIO_FullRemap_USART3</td><td>USART3 复用功能完全映射</td></tr><tr><td>GPIO_PartialRemap_TIM1</td><td>USART3 复用功能部分映射</td></tr><tr><td>GPIO_FullRemap_TIM1</td><td>TIM1 复用功能完全映射</td></tr><tr><td>GPIO_PartialRemap1_TIM2</td><td>TIM2 复用功能部分映射 1</td></tr><tr><td>GPIO_PartialRemap2_TIM2</td><td>TIM2 复用功能部分映射 2</td></tr><tr><td>GPIO_FullRemap_TIM2</td><td>TIM2 复用功能完全映射</td></tr><tr><td>GPIO_PartialRemap_TIM3</td><td>TIM3 复用功能部分映射</td></tr><tr><td>GPIO_FullRemap_TIM3</td><td>TIM3 复用功能完全映射</td></tr><tr><td>GPIO_Remap_TIM4</td><td>TIM4 复用功能映射</td></tr><tr><td>GPIO_Remap1_CAN</td><td>CAN 复用功能映射 1</td></tr><tr><td>GPIO_Remap2_CAN</td><td>CAN 复用功能映射 2</td></tr><tr><td>GPIO_Remap_PD01</td><td>PD01 复用功能映射</td></tr><tr><td>GPIO_Remap_SWJ_NoJTRST</td><td>除 JTRST 外 SWJ 完全使能 (JTAG+SW-DP)</td></tr><tr><td>GPIO_Remap_SWJ_JTAGDisable</td><td>JTAG-DP 失能 + SW-DP 使能</td></tr><tr><td>GPIO_Remap_SWJ_Disable</td><td>SWJ 完全失能 (JTAG+SW-DP)</td></tr></table>

例：  
/* I2C1_SCL on PB.08, I2C1_SDA on PB.09 */
GPIO_PinRemapConfig(GPIO_Remap_I2C1, ENABLE);

# 10.2.17 函数GPIO_EXTILineConfig

Table 203. 描述了 GPIO_EXTILineConfig  
Table 203. 函数 GPIO_EXTILineConfig  

<table><tr><td>函数名</td><td>GPIO_EXTILineConfig</td></tr><tr><td>函数原形</td><td>void GPIO_EXTILineConfig(u8 GPIO_PortSource, u8 GPIO_PinSource)</td></tr><tr><td>功能描述</td><td>选择 GPIO 管脚用作外部中断线路</td></tr><tr><td>输入参数 1</td><td>GPIO_PortSource: 选择用作外部中断线源的 GPIO 端口
参阅 Section: GPIO_PortSource 查阅更多该参数允许取值范围</td></tr><tr><td>输入参数 2</td><td>GPIO_PinSource: 待设置的外部中断线路
该参数可以取 GPIO_PinSourcex(x 可以是 0-15)</td></tr><tr><td>输出参数</td><td>无</td></tr><tr><td>返回值</td><td>无</td></tr><tr><td>先决条件</td><td>无</td></tr><tr><td>被调用函数</td><td>无</td></tr></table>

例：  
/\* Selects PB.08 as EXTI Line 8 \*/ GPIO_EXTILineConfig(GPIO_PortSource_GPIOB，GPIO_PinSource8);

# 11 内部集成电路（ $\mathbf{I}^2\mathbf{C}$ ）

I2C总线接口连接微控制器和串行I2C总线。它提供多主机功能，控制所有I2C总线特定的时序、协议、仲裁和定时。支持标准和快速两种模式，同时与SMBus2.0兼容。I2C总线有多种用途，包括CRC码的生成和校验、SMBus(系统管理总线System Management Bus)PMBus(电源管理总线Power Management Bus)。

I2C驱动可以用来通过I2C界面发送和接收数据，还可以返回传输操作的状态。

Section 11.1 I2C 寄存器结构描述了固件函数库所使用的数据结构，Section 11.2 固件库函数介绍了函数库里的所有函数。

# 11.1 I2C寄存器结构

I2C寄存器结构，I2C_TYPEDeff，在文件“stm32f10x_map.h”中定义如下：

```c
typedef struct  
{  
vu16 CR1;  
u16 RESERVED0;  
vu16 CR2;  
u16 RESERVED1;  
vu16 OAR1;  
u16 RESERVED2;  
vu16 OAR2;  
u16 RESERVED3;  
vu16 DR;  
u16 RESERVED4;  
vu16 SR1;  
u16 RESERVED5;  
vu16 SR2;  
u16 RESERVED6;  
vu16 CCR;  
u16 RESERVED7;  
vu16 TRISE;  
u16 RESERVED8;  
} I2C_TYPEDef;
```

Table 204.例举了 I2C 所有寄存器  
Table 204. I2C 寄存器  

<table><tr><td>寄存器</td><td>描述</td></tr><tr><td>CR1</td><td>I2C控制寄存器1</td></tr><tr><td>CR2</td><td>I2C控制寄存器2</td></tr><tr><td>OAR1</td><td>I2C自身地址寄存器1</td></tr><tr><td>OAR2</td><td>I2C自身地址寄存器2</td></tr><tr><td>DR</td><td>I2C数据寄存器</td></tr><tr><td>SR1</td><td>I2C状态寄存器1</td></tr><tr><td>SR2</td><td>I2C状态寄存器2</td></tr><tr><td>CCR</td><td>I2C时钟控制寄存器</td></tr><tr><td>TRISE</td><td>I2C上升时间寄存器</td></tr></table>

2个I2C外设声明于文件“stm32f10x_map.h”：

```c
define PERIPH_BASE ((u32)0x40000000)  
#define APB1PERIPH_BASE PERIPH_BASE  
#define APB2PERIPH_BASE (PERIPH_BASE + 0x10000)  
#define AHBPERIPH_BASE (PERIPH_BASE + 0x20000)
```

# ST

译文英文原版为UM0427 Oct. 2007 Rev 2, 译文仅供参考，与英文版冲突的，以英文版为准

I2C  
```c
define I2C1_BASE (APB1PERIPH_BASE + 0x5400)  
#define I2C2_BASE (APB1PERIPH_BASE + 0x5800)  
...  
#	define DEBUG  
...  
#	define_I2C1  
#	define_I2C1 ((I2C_TYPEDef *) I2C1_BASE)  
#endif /*_I2C1 */  
#	define_I2C2  
#	define_I2C2 ((I2C_TYPEDef *) I2C2_BASE)  
#endif /*_I2C2 */  
...  
#else /* DEBUG */  
...  
#	define_I2C1  
EXT I2C_TYPEDef *I2C1;  
#endif /*_I2C1 */  
#	define_I2C2  
EXT I2C_TYPEDef *I2C2;  
#endif /*_I2C2 */  
...  
#endif
```

使用Debug模式时，初始化指针I2C1,I2C2于文件“stm32f10x_lib.c”：

```c
...
#ifdef I2C1
I2C1 = (I2CTypeDef *) I2C1_BASE;
#endif /*_I2C1 */
#ifdef I2C2
I2C2 = (I2CTypeDef *) I2C2_BASE;
#endif /*_I2C2 */
```

为了访问I2C寄存器，_I2C，_I2C1,_I2C2必须在文件“stm32f10x_conf.h”中定义如下：

```c
define I2C
#define I2C1
#define I2C2
```

# 11.2 I2C库函数

Table 205. 例举了 I2C 的库函数  
Table 205. I2C 库函数  

<table><tr><td>函数名</td><td>描述</td></tr><tr><td>I2C_DeInit</td><td>将外设 I2Cx 寄存器重设为缺省值</td></tr><tr><td>I2C_Init</td><td>根据 I2C_InitStruct 中指定的参数初始化外设 I2Cx 寄存器</td></tr><tr><td>I2CSTRUCTInit</td><td>把 I2C_InitStruct 中的每一个参数按缺省值填入</td></tr><tr><td>I2C_Cmd</td><td>使能或者失能 I2C 外设</td></tr><tr><td>I2C_DMAcd</td><td>使能或者失能指定 I2C 的 DMA 请求</td></tr><tr><td>I2C_DMALastTransferCmd</td><td>使下一次 DMA 传输为最后一次传输</td></tr><tr><td>I2C_GenerateSTART</td><td>产生 I2Cx 传输 START 条件</td></tr><tr><td>I2C_GenerateSTOP</td><td>产生 I2Cx 传输 STOP 条件</td></tr><tr><td>I2C_AcknowledgeConfig</td><td>使能或者失能指定 I2C 的应答功能</td></tr><tr><td>I2C_OwnAddress2Config</td><td>设置指定 I2C 的自身地址 2</td></tr><tr><td>I2C_DualAddressCmd</td><td>使能或者失能指定 I2C 的双地址模式</td></tr><tr><td>I2C_GeneralCallCmd</td><td>使能或者失能指定 I2C 的广播呼叫功能</td></tr><tr><td>I2C_ITConfig</td><td>使能或者失能指定的 I2C 中断</td></tr><tr><td>I2C_SendDateData</td><td>通过外设 I2Cx 发送一个数据</td></tr><tr><td>I2C_ReceiveData</td><td>返回通过 I2Cx 最近接收的数据</td></tr><tr><td>I2C_Send7bitAddress</td><td>向指定的从 I2C 设备传送地址字</td></tr></table>

# ST

译文英文原版为UM0427 Oct. 2007 Rev 2, 译文仅供参考，与英文版冲突的，以英文版为准

I2C  

<table><tr><td>I2C_ReadRegister</td><td>读取指定的 I2C 寄存器并返回其值</td></tr><tr><td>I2C_SoftwareResetCmd</td><td>使能或者失能指定 I2C 的软件复位</td></tr><tr><td>I2C_SMBusAlertConfig</td><td>驱动指定 I2Cx 的 SMBusAlert 管脚电平为高或低</td></tr><tr><td>I2C_TransmitPEC</td><td>使能或者失能指定 I2C 的 PEC 传输</td></tr><tr><td>I2C_PECPositionConfig</td><td>选择指定 I2C 的 PEC 位置</td></tr><tr><td>I2C_CalculatePEC</td><td>使能或者失能指定 I2C 的传输字 PEC 值计算</td></tr><tr><td>I2C_GetPEC</td><td>返回指定 I2C 的 PEC 值</td></tr><tr><td>I2C_ARPCmd</td><td>使能或者失能指定 I2C 的 ARP</td></tr><tr><td>I2C_StretchClockCmd</td><td>使能或者失能指定 I2C 的时钟延展</td></tr><tr><td>I2C_FastModeDutyCycleConfig</td><td>选择指定 I2C 的快速模式占空比</td></tr><tr><td>I2C_GetLastEvent</td><td>返回最近一次 I2C 事件</td></tr><tr><td>I2CcheckingEvent</td><td>检查最近一次 I2C 事件是否是输入的事件</td></tr><tr><td>I2C_GetFlagStatus</td><td>检查指定的 I2C 标志位设置与否</td></tr><tr><td>I2C_ClearFlag</td><td>清除 I2Cx 的待处理标志位</td></tr><tr><td>I2C_GetITStatus</td><td>检查指定的 I2C 中断发生与否</td></tr><tr><td>I2C_ClearITPendingBit</td><td>清除 I2Cx 的中断待处理位</td></tr></table>

# 11.2.1 函数I2C_DeInit

Table 206. 描述了函数 I2C_DeInit  
Table 206. 函数 I2C_DeInit  

<table><tr><td>函数名</td><td>I2C_DeInit</td></tr><tr><td>函数原形</td><td>void I2C_DeInit(I2C_TYPEDef* I2Cx)</td></tr><tr><td>功能描述</td><td>将外设 I2Cx 寄存器重设为缺省值</td></tr><tr><td>输入参数</td><td>I2Cx: x 可以是 1 或者 2, 来选择 I2C 外设</td></tr><tr><td>输出参数</td><td>无</td></tr><tr><td>返回值</td><td>无</td></tr><tr><td>先决条件</td><td>无</td></tr><tr><td>被调用函数</td><td>RCC_APBIPeriphClockCmd().</td></tr></table>

例：  
/* Deinitialize I2C2 interface*/  
I2C_DeInit(I2C2);

# 11.2.2 函数I2C_Init

Table 207. 描述了函数 I2C_Init

Table 207. 函数 I2C_Init  

<table><tr><td>函数名</td><td>I2C_Init</td></tr><tr><td>函数原形</td><td>void I2C_Init(I2C_TYPEDef* I2Cx, I2C_InitTypeDef* I2C_InitStruct)</td></tr><tr><td>功能描述</td><td>根据 I2C_InitStruct 中指定的参数初始化外设 I2Cx 寄存器</td></tr><tr><td>输入参数 1</td><td>I2Cx: x 可以是 1 或者 2, 来选择 I2C 外设</td></tr><tr><td>输入参数 2</td><td>I2C_InitStruct: 指向结构 I2C_InitTypeDef 的指针, 包含了外设 GPIO 的配置信息参阅 Section: I2C_InitTypeDef 查阅更多该参数允许取值范围</td></tr><tr><td>输出参数</td><td>无</td></tr><tr><td>返回值</td><td>无</td></tr><tr><td>先决条件</td><td>无</td></tr><tr><td>被调用函数</td><td>无</td></tr></table>

# I2C_InitTypeDef structure

I2C_InitTypeDef 定义于文件“stm32f10x_i2c.h”：

typedef struct

$\left\{  {1,2,3}\right\}$

u16 I2C Mode;

u16 I2C DutyCycle;

ul6 I2C_OwnAddress1;

u16 I2C Ack;

u16 I2C_AcknowledgedAddress;

u32 I2C ClockSpeed;

} I2C_IInitTypeDef;

# I2C_Mode

I2C_Mode 用以设置 I2C 的模式。Table 208. 给出了该参数可取的值

Table 208. I2C_Mode 值  

<table><tr><td>I2C_Mode</td><td>描述</td></tr><tr><td>I2C_Mode_I2C</td><td>设置 I2C 为 I2C 模式</td></tr><tr><td>I2C_Mode_SMBusDevice</td><td>设置 I2C 为 SMBus 设备模式</td></tr><tr><td>I2C_Mode_SMBusHost</td><td>设置 I2C 为 SMBus 主控模式</td></tr></table>

# I2C_DutyCycle

I2C_DutyCycle 用以设置 I2C 的占空比。Table 209. 给出了该参数可取的值

Table 209. I2C_DutyCycle 值  

<table><tr><td>I2C_DutyCycle</td><td>描述</td></tr><tr><td>I2C_DutyCycle_16_9</td><td>I2C 快速模式 Tlow / Thigh = 16/9</td></tr><tr><td>I2C_DutyCycle_2</td><td>I2C 快速模式 Tlow / Thigh = 2</td></tr></table>

注意：该参数只有在I2C工作在快速模式（时钟工作频率高于  $100\mathrm{kHz}$  ）下才有意义。

# I2C_OwnAddress1

该参数用来设置第一个设备自身地址，它可以是一个7位地址或者一个10位地址。

# I2C_Ack

I2C_Ack使能或者失能应答（ACK），Table210.给出了该参数可取的值

Table 210. I2C_Ack 值  

<table><tr><td>I2C_Ack</td><td>描述</td></tr><tr><td>I2C_Ack_Enable</td><td>使能应答（ACK）</td></tr><tr><td>I2C_Ack_Disable</td><td>失能应答（ACK）</td></tr></table>

# I2C_AcknowledgedAddress

I2C_AcknowledgedAddress 定义了应答 7 位地址还是 10 位地址。Table 211. 给出了该参数可取的值

Table 211. I2C_AcknowledgedAddress 值  

<table><tr><td>I2C_AcknowledgedAddress</td><td>描述</td></tr><tr><td>I2C_AcknowledgeAddress_7bit</td><td>应答7位地址</td></tr><tr><td>I2C_AcknowledgeAddress_10bit</td><td>应答10位地址</td></tr></table>

# I2C_ClockSpeed

该参数用来设置时钟频率，这个值不能高于  $400\mathrm{KHz}$ 。

例：

```c
/* Initialize the I2C1 according to the I2C_InitStructure members */
I2C_InitTypeDef I2C_InitStructure;
I2C_InitStructure.I2C_Mode = I2C_Mode_SMBusHost;
I2C_InitStructure.I2C_DutyCycle = I2C_DutyCycle_2;
I2C_InitStructure.I2C_OwnAddress1 = 0x03A2;
I2C_InitStructure.I2C_Ack = I2C_Ack_Enable;
I2C_InitStructure.I2C_AcknowledgedAddress =
I2C_AcknowledgedAddress_7bit;
I2C_InitStructure.I2C_ClockSpeed = 200000;
I2C_Init(I2C1, &I2C_InitStructure);
```

# 11.2.3 函数I2CSTRUCTInit

Table 212. 描述了函数 I2CSTRUCTInit  
Table 212. 函数 I2CSTRUCTInit  

<table><tr><td>函数名</td><td>I2CSTRUCTInit</td></tr><tr><td>函数原形</td><td>void I2CSTRUCTInit(I2C_InitTypeDef* I2C_InitStruct)</td></tr><tr><td>功能描述</td><td>把I2C_InitStruct中的每一个参数按缺省值填入</td></tr><tr><td>输入参数</td><td>I2C_InitStruct: 指向结构I2C_InitTypeDef的指针, 待初始化</td></tr><tr><td>输出参数</td><td>无</td></tr><tr><td>返回值</td><td>无</td></tr><tr><td>先决条件</td><td>无</td></tr><tr><td>被调用函数</td><td>无</td></tr></table>

Table 213. 给出了 I2C_InitStruct 各个成员的缺省值  
Table 213. I2C_InitStruct 缺省值  

<table><tr><td>成员</td><td>缺省值</td></tr><tr><td>I2C_Mode</td><td>I2C_Mode_I2C</td></tr><tr><td>I2C_DutyCycle</td><td>I2C_DutyCycle_2</td></tr><tr><td>I2C_OwnAddress1</td><td>0</td></tr><tr><td>I2C_Ack</td><td>I2C_Ack_Disable</td></tr><tr><td>I2C_AcknowledgedAddress</td><td>I2C_AcknowledgedAddress_7bit</td></tr><tr><td>I2C_ClockSpeed</td><td>5000</td></tr></table>

例：

```c
/* Initialize an I2C_InitTypeDef structure */
I2C_InitTypeDef I2C_InitStructure;
I2CSTRUCTInit(&I2C_InitStructure);
```

# 11.2.4 函数I2C_Cmd

Table 214. 描述了函数 I2C_Cmd  
Table 214. 函数 I2C_Cmd  

<table><tr><td>函数名</td><td>I2C_Cmd</td></tr><tr><td>函数原形</td><td>void I2C_Cmd(I2CTypeDef* I2Cx, FunctionalState NewState)</td></tr><tr><td>功能描述</td><td>使能或者失能 I2C 外设</td></tr><tr><td>输入参数 1</td><td>I2Cx: x 可以是 1 或者 2, 来选择 I2C 外设</td></tr><tr><td>输入参数 2</td><td>NewState: 外设 I2Cx 的新状态
这个参数可以取: ENABLE 或者 DISABLE</td></tr><tr><td>输出参数</td><td>无</td></tr><tr><td>返回值</td><td>无</td></tr><tr><td>先决条件</td><td>无</td></tr><tr><td>被调用函数</td><td>无</td></tr></table>

例：
/* Enable I2C1 peripheral */
I2C_Cmd(I2C1, ENABLE);

# 11.2.5 函数I2C_DMACmd

Table 215. 描述了函数 I2C_DMAcmd  
Table 215. 函数 I2C_DMACmd  

<table><tr><td>函数名</td><td>I2C_DMAcd</td></tr><tr><td>函数原形</td><td>I2C_DMAcd(I2CTypeDef* I2Cx, FunctionalState NewState)</td></tr><tr><td>功能描述</td><td>使能或者失能指定 I2C 的 DMA 请求</td></tr><tr><td>输入参数 1</td><td>I2Cx: x 可以是 1 或者 2, 来选择 I2C 外设</td></tr><tr><td>输入参数 2</td><td>NewState: I2Cx DMA 传输的新状态
这个参数可以取: ENABLE 或者 DISABLE</td></tr><tr><td>输出参数</td><td>无</td></tr><tr><td>返回值</td><td>无</td></tr><tr><td>先决条件</td><td>无</td></tr><tr><td>被调用函数</td><td>无</td></tr></table>

例：
/* Enable I2C2 DMA transfer */
I2C_DMAcd(I2C2, ENABLE);

# 11.2.6 函数I2C_DMALastTransferCmd

Table 216. 描述了函数 I2C_DMALastTransferCmd

Table 216. 函数 I2C_DMALastTransferCmd  

<table><tr><td>函数名</td><td>I2C_DMALastTransferCmd</td></tr><tr><td>函数原形</td><td>I2C_DMALastTransferCmd(I2C_TYPEDef* I2Cx, FunctionalState NewState)</td></tr><tr><td>功能描述</td><td>使下一次 DMA 传输为最后一次传输</td></tr><tr><td>输入参数1</td><td>I2Cx: x 可以是 1 或者 2, 来选择 I2C 外设</td></tr><tr><td>输入参数2</td><td>NewState: I2Cx DMA 最后一次传输的新状态
这个参数可以取: ENABLE 或者 DISABLE</td></tr><tr><td>输出参数</td><td>无</td></tr><tr><td>返回值</td><td>无</td></tr><tr><td>先决条件</td><td>无</td></tr><tr><td>被调用函数</td><td>无</td></tr></table>

例：
/* Specify that the next I2C2 DMA transfer is the last one */
I2C_DMALastTransferCmd(I2C2, ENABLE);

# 11.2.7 函数I2C_GenerateSTART

Table 217. 描述了函数 I2CGenerateSTART

Table 217. 函数 I2CGenerateSTART  

<table><tr><td>函数名</td><td>I2CGenerateSTART</td></tr><tr><td>函数原形</td><td>void I2CGenerateSTART(I2CTypeDef* I2Cx, FunctionalState NewState)</td></tr><tr><td>功能描述</td><td>产生 I2Cx 传输 START 条件</td></tr><tr><td>输入参数1</td><td>I2Cx: x 可以是 1 或者 2 ,来选择 I2C 外设</td></tr><tr><td>输入参数2</td><td>NewState: I2Cx START 条件的新状态
这个参数可以取: ENABLE 或者 DISABLE</td></tr><tr><td>输出参数</td><td>无</td></tr><tr><td>返回值</td><td>无</td></tr><tr><td>先决条件</td><td>无</td></tr><tr><td>被调用函数</td><td>无</td></tr></table>

例：/\*GenerateaSTARTconditiononI2C1\*/I2C_GenerateSTART(I2C1，ENABLE);

# 11.2.8 函数I2C_GenerateSTOP

Table 218. 描述了函数 I2CGenerateSTOP  
Table 218. 函数 I2CGenerateSTOP  

<table><tr><td>函数名</td><td>I2C_GenerateSTOP</td></tr><tr><td>函数原形</td><td>void I2C_GenerateSTOP(I2C_TYPEDef* I2Cx, FunctionalState NewState)</td></tr><tr><td>功能描述</td><td>产生 I2Cx 传输 STOP 条件</td></tr><tr><td>输入参数1</td><td>I2Cx: x 可以是 1 或者 2, 来选择 I2C 外设</td></tr><tr><td>输入参数2</td><td>NewState: I2Cx STOP 条件的新状态
这个参数可以取: ENABLE 或者 DISABLE</td></tr><tr><td>输出参数</td><td>无</td></tr><tr><td>返回值</td><td>无</td></tr><tr><td>先决条件</td><td>无</td></tr><tr><td>被调用函数</td><td>无</td></tr></table>

例：/\*GenerateaSTOPconditiononI2C2\*/I2C_GenerateSTOP(I2C2，ENABLE)；

# 11.2.9 函数I2C_AcknowledgeConfig

Table 219. 描述了函数 I2C_AcknowledgeConfig  
Table 219. 函数 I2C_AcknowledgeConfig  

<table><tr><td>函数名</td><td>I2C_AcknowledgeConfig</td></tr><tr><td>函数原形</td><td>void I2C_AcknowledgeConfig(I2CTypeDef* I2Cx, FunctionalState NewState)</td></tr><tr><td>功能描述</td><td>使能或者失能指定 I2C 的应答功能</td></tr><tr><td>输入参数 1</td><td>I2Cx: x 可以是 1 或者 2, 来选择 I2C 外设</td></tr><tr><td>输入参数 2</td><td>NewState: I2Cx 应答的新状态
这个参数可以取: ENABLE 或者 DISABLE</td></tr><tr><td>输出参数</td><td>无</td></tr><tr><td>返回值</td><td>无</td></tr><tr><td>先决条件</td><td>无</td></tr><tr><td>被调用函数</td><td>无</td></tr></table>

例：
/* Enable the I2C1 Acknowledgement */
I2C_AcknowledgeConfig(I2C1, ENABLE);

# 11.2.10 函数I2C_OwnAddress2Config

Table 220. 描述了函数 I2C_OwnAddress2Config

Table 220. 函数 I2C_OwnAddress2Config  

<table><tr><td>函数名</td><td>I2C_OwnAddress2Config</td></tr><tr><td>函数原形</td><td>void I2C_OwnAddress2Config(I2C_TYPEDef* I2Cx, u8 Address)</td></tr><tr><td>功能描述</td><td>设置指定 I2C 的自身地址 2</td></tr><tr><td>输入参数 1</td><td>I2Cx: x 可以是 1 或者 2, 来选择 I2C 外设</td></tr><tr><td>输入参数 2</td><td>Address: 指定的 7 位 I2C 自身地址 2</td></tr><tr><td>输出参数</td><td>无</td></tr><tr><td>返回值</td><td>无</td></tr><tr><td>先决条件</td><td>无</td></tr><tr><td>被调用函数</td><td>无</td></tr></table>

例：  
/\*Set the I2C1 own address2 to 0x38 \*/ I2C_OwnAddress2Config(I2C1,0x38);

# 11.2.11 函数I2C_DualAddressCmd

Table 221. 描述了函数 I2C_DualAddressCmd  
Table 221. 函数 I2C_DualAddressCmd  

<table><tr><td>函数名</td><td>I2C_DualAddressCmd</td></tr><tr><td>函数原形</td><td>void I2C_DualAddressCmd(I2CTypeDef* I2Cx, FunctionalState NewState)</td></tr><tr><td>功能描述</td><td>使能或者失能指定 I2C 的双地址模式</td></tr><tr><td>输入参数 1</td><td>I2Cx: x 可以是 1 或者 2, 来选择 I2C 外设</td></tr><tr><td>输入参数 2</td><td>NewState: I2Cx 双地址模式的新状态
这个参数可以取: ENABLE 或者 DISABLE</td></tr><tr><td>输出参数</td><td>无</td></tr><tr><td>返回值</td><td>无</td></tr><tr><td>先决条件</td><td>无</td></tr><tr><td>被调用函数</td><td>无</td></tr></table>

例：  
/\* Enable the I2C2 dual addressing mode\*/ I2C_DualAdressCmd(I2C2, ENABLE);

# 11.2.12 函数I2CGENERALCallCmd

Table 222. 描述了函数 I2CGENERALCallCmd

Table 222. 函数 I2C_GeneralCallCmd  

<table><tr><td>函数名</td><td>I2C_GeneralCallCmd</td></tr><tr><td>函数原形</td><td>void I2C_GeneralCallCmd(I2C_TYPEDef* I2Cx, FunctionalState NewState)</td></tr><tr><td>功能描述</td><td>使能或者失能指定 I2C 的广播呼叫功能</td></tr><tr><td>输入参数1</td><td>I2Cx: x 可以是 1 或者 2, 来选择 I2C 外设</td></tr><tr><td>输入参数2</td><td>NewState: I2Cx 广播呼叫的新状态
这个参数可以取: ENABLE 或者 DISABLE</td></tr><tr><td>输出参数</td><td>无</td></tr><tr><td>返回值</td><td>无</td></tr><tr><td>先决条件</td><td>无</td></tr><tr><td>被调用函数</td><td>无</td></tr></table>

例：  
/\*Enable the I2C1 general call feature \*/ I2CGENERALCallCmd(I2C1，ENABLE);

# 11.2.13 函数I2C_ITConfig

Table 223. 描述了函数 I2C_ITConfig

Table 223. 函数 I2C_ITConfig  

<table><tr><td>函数名</td><td>I2C_ITConfig</td></tr><tr><td>函数原形</td><td>void I2C_ITConfig(I2C_TYPEDef* I2Cx, u16 I2C_IT, FunctionalState NewState)</td></tr><tr><td>功能描述</td><td>使能或者失能指定的 I2C 中断</td></tr><tr><td>输入参数 1</td><td>I2Cx: x 可以是 1 或者 2, 来选择 I2C 外设</td></tr><tr><td>输入参数 2</td><td>I2C_IT: 待使能或者失能的 I2C 中断源
参阅 Section: I2C_IT 查阅更多该参数允许取值范围</td></tr><tr><td>输入参数 3</td><td>NewState: I2Cx 中断的新状态
这个参数可以取: ENABLE 或者 DISABLE</td></tr><tr><td>输出参数</td><td>无</td></tr><tr><td>返回值</td><td>无</td></tr><tr><td>先决条件</td><td>无</td></tr><tr><td>被调用函数</td><td>无</td></tr></table>

# I2C IT

输入参数I2C_IT使能或者失能I2C的中断。可以取下表的一个或者多个取值的组合作为该参数的值。

Table 224. I2C_IT 值  

<table><tr><td>I2C_IT</td><td>描述</td></tr><tr><td>I2C_ITBUF</td><td>缓存中断屏蔽</td></tr><tr><td>I2C_IT_EVT</td><td>事件中断屏蔽</td></tr><tr><td>I2C_IT_ERR</td><td>错误中断屏蔽</td></tr></table>

例：  
/\*EnableI2C2event and buffer interrupts\*/ I2C_ITConfig(I2C2，I2C_ITBUF|I2C_IT_EVT，ENABLE);

# 11.2.14 函数I2C_) SendData

Table 225. 描述了函数 I2C_SendData  
Table 225. 函数 I2C_) SendData  

<table><tr><td>函数名</td><td>I2C_SendDate</td></tr><tr><td>函数原形</td><td>void I2C_SendDate(I2C_TYPEDef* I2Cx, u8 Data)</td></tr><tr><td>功能描述</td><td>通过外设 I2Cx 发送一个数据</td></tr><tr><td>输入参数1</td><td>I2Cx: x 可以是 1 或者 2, 来选择 I2C 外设</td></tr><tr><td>输入参数2</td><td>Data: 待发送的数据</td></tr><tr><td>输出参数</td><td>无</td></tr><tr><td>返回值</td><td>无</td></tr><tr><td>先决条件</td><td>无</td></tr><tr><td>被调用函数</td><td>无</td></tr></table>

例：
/* Transmit 0x5D byte on I2C2 */
I2C_SendData(I2C2, 0x5D);

# 11.2.15 函数I2C_ReceiveData

Table 226. 描述了函数 I2C_ReceiveData  
Table 226. 函数 I2C_ReceiveData  

<table><tr><td>函数名</td><td>I2C_ReceiveData</td></tr><tr><td>函数原形</td><td>u8 I2C_ReceiveData(I2C_TYPEDef* I2Cx)</td></tr><tr><td>功能描述</td><td>返回通过 I2Cx 最近接收的数据</td></tr><tr><td>输入参数</td><td>I2Cx: x 可以是 1 或者 2, 来选择 I2C 外设</td></tr><tr><td>输出参数</td><td>无</td></tr><tr><td>返回值</td><td>接收到的字</td></tr><tr><td>先决条件</td><td>无</td></tr><tr><td>被调用函数</td><td>无</td></tr></table>

例：
/* Read the received byte on I2C1 */
u8 ReceivedData;
ReceivedData = I2C_ReceiveData(I2C1);

# 11.2.16 函数I2C_Send7bitAddress

Table 227. 描述了函数 I2C_Send7bitAddress

Table 227. 函数 I2C_Send7bitAddress  

<table><tr><td>函数名</td><td>I2C_Send7bitAddress</td></tr><tr><td>函数原形</td><td>void I2C_Send7bitAddress(I2C_TYPEDef* I2Cx, u8 Address, u8 I2C_Direction)</td></tr><tr><td>功能描述</td><td>向指定的从 I2C 设备传送地址字</td></tr><tr><td>输入参数1</td><td>I2Cx: x 可以是 1 或者 2, 来选择 I2C 外设</td></tr><tr><td>输入参数2</td><td>Address: 待传输的从 I2C 地址</td></tr><tr><td>输入参数3</td><td>I2C_Direction: 设置指定的 I2C 设备工作为发射端还是接收端参阅 Section: I2C_Direction 查阅更多该参数允许取值范围</td></tr><tr><td>输出参数</td><td>无</td></tr><tr><td>返回值</td><td>无</td></tr><tr><td>先决条件</td><td>无</td></tr><tr><td>被调用函数</td><td>无</td></tr></table>

# 12C_Direction

该参数设置I2C界面为发送端模式或者接收端模式（见Table228.）。

Table 228. I2C_Direction 值  

<table><tr><td>I2C_Direction</td><td>描述</td></tr><tr><td>I2C_Direction_Transmitter</td><td>选择发送方向</td></tr><tr><td>I2C_Direction_Receiver</td><td>选择接收方向</td></tr></table>

例：

/* Send, as transmitter, the Slave device address 0xA8 in 7-bit addressing mode in I2C1 */
I2C_Send7bitAddress(I2C1, 0xA8, I2C_Direction_Transmitter);

# 11.2.17 函数I2C_ReadRegister

Table 229. 描述了函数 I2C_ReadRegister

Table 229. 函数 I2C_ReadRegister  

<table><tr><td>函数名</td><td>I2C_ReadRegister</td></tr><tr><td>函数原形</td><td>u16 I2C_ReadRegister(I2CTypeDef* I2Cx, u8 I2CRegister)</td></tr><tr><td>功能描述</td><td>读取指定的 I2C 寄存器并返回其值</td></tr><tr><td>输入参数 1</td><td>I2Cx: x 可以是 1 或者 2, 来选择 I2C 外设</td></tr><tr><td>输入参数 2</td><td>I2CRegister: 待读取的 I2C 寄存器
参阅 Section: I2CRegister 查阅更多该参数允许取值范围</td></tr><tr><td>输出参数</td><td>无</td></tr><tr><td>返回值</td><td>被读取的寄存器值¹.</td></tr><tr><td>先决条件</td><td>无</td></tr><tr><td>被调用函数</td><td>无</td></tr></table>

1. 读取寄存器可能会清除某些标志位

# I2CRegister

Table 230. 给出了所有可以被函数 I2C_ReadRegister 读取的寄存器列表

Table 230. I2CRegister 值  

<table><tr><td>I2CRegister</td><td>描述</td></tr><tr><td>I2CRegister_CR1</td><td>选择读取寄存器 I2C_CR1</td></tr><tr><td>I2CRegister_CR2</td><td>选择读取寄存器 I2C_CR2</td></tr><tr><td>I2CRegister_OAR1</td><td>选择读取寄存器 I2C_OAR1</td></tr><tr><td>I2CRegister_OAR2</td><td>选择读取寄存器 I2C_OAR2</td></tr><tr><td>I2CRegister_DR</td><td>选择读取寄存器 I2C_DR</td></tr><tr><td>I2CRegister_SR1</td><td>选择读取寄存器 I2C_SR1</td></tr><tr><td>I2CRegister_SR2</td><td>选择读取寄存器 I2C_SR2</td></tr><tr><td>I2CRegister_CCR</td><td>选择读取寄存器 I2C_CCR</td></tr><tr><td>I2CRegister_TRISE</td><td>选择读取寄存器 I2C_TRISE</td></tr></table>

例：  
/\* Return the I2C_CR1 register value of I2C2 peripheral \*/ u16 RegisterValue;  
RegisterValue = I2C_ReadRegister(I2C2, I2C_Register_CR1);

# 11.2.18 函数I2CSOFTWAREResetCmd

Table 231. 描述了函数 I2C_SoftwareResetCmd  
Table 231. 函数 I2C_SoftwareResetCmd  

<table><tr><td>函数名</td><td>I2C_SoftwareResetCmd</td></tr><tr><td>函数原形</td><td>I2C_SoftwareResetCmd(I2C_TYPEDef* I2Cx, FunctionalState NewState)</td></tr><tr><td>功能描述</td><td>使能或者失能指定 I2C 的软件复位</td></tr><tr><td>输入参数1</td><td>I2Cx: x 可以是 1 或者 2, 来选择 I2C 外设</td></tr><tr><td>输入参数2</td><td>NewState: I2Cx 软件复位的新状态
这个参数可以取: ENABLE 或者 DISABLE</td></tr><tr><td>输出参数</td><td>无</td></tr><tr><td>返回值</td><td>无</td></tr><tr><td>先决条件</td><td>无</td></tr><tr><td>被调用函数</td><td>无</td></tr></table>

例：  
/\*Put under reset the I2C1 peripheral \*/ I2CSOFTWAREResetCmd(I2C1，ENABLE);

# 11.2.19 函数I2C_SMBusAlertConfig

Table 232. 描述了函数 I2C_SMBusAlertConfig

Table 232. 函数 I2C_SMBusAlertConfig  

<table><tr><td>函数名</td><td>I2C_SMBusAlertConfig</td></tr><tr><td>函数原形</td><td>void I2C_SMBusAlertConfig(I2C_TYPEDef* I2Cx, u16 I2C_SMBusAlert)</td></tr><tr><td>功能描述</td><td>驱动指定 I2Cx 的 SMBusAlert 管脚电平为高或低</td></tr><tr><td>输入参数 1</td><td>I2Cx: x 可以是 1 或者 2, 来选择 I2C 外设</td></tr><tr><td>输入参数 2</td><td>I2C_SMBusAlert: SMBusAlert 管脚电平
参阅 Section: I2C_SMBusAlert 查阅更多该参数允许取值范围</td></tr><tr><td>输出参数</td><td>无</td></tr><tr><td>返回值</td><td>无</td></tr><tr><td>先决条件</td><td>无</td></tr><tr><td>被调用函数</td><td>无</td></tr></table>

# I2C_SMBusAlert

I2C_SMBusAlert 用以设置 SMBusAlert 管脚的有效电平。Table 233. 给出了该参数可取的值

Table 233. I2C_SMBusAlert 值  

<table><tr><td>I2C_SMBusAlert</td><td>描述</td></tr><tr><td>I2C_SMBusAlert_Low</td><td>驱动 SMBusAlert 管脚电平为高</td></tr><tr><td>I2C_SMBusAlert_High</td><td>驱动 SMBusAlert 管脚电平为低</td></tr></table>

例：

/\*Let the I2C2 SMBusAlert pin High \*/ I2C_SMBusAlertConfig(I2C2，I2C_SMBusAlert_High);

# 11.2.20 函数I2C_TransmitPEC

Table 234. 描述了函数 I2C_TransmitPEC

Table 234. 函数 I2C_TransmitPEC  

<table><tr><td>函数名</td><td>I2C_TransmitPEC</td></tr><tr><td>函数原形</td><td>I2C_TransmitPEC(I2C_TYPEDef* I2Cx, FunctionalState NewState)</td></tr><tr><td>功能描述</td><td>使能或者失能指定 I2C 的 PEC 传输</td></tr><tr><td>输入参数1</td><td>I2Cx: x 可以是 1 或者 2, 来选择 I2C 外设</td></tr><tr><td>输入参数2</td><td>NewState: I2CxPEC 传输的新状态
这个参数可以取: ENABLE 或者 DISABLE</td></tr><tr><td>输出参数</td><td>无</td></tr><tr><td>返回值</td><td>无</td></tr><tr><td>先决条件</td><td>无</td></tr><tr><td>被调用函数</td><td>无</td></tr></table>

例：

/\*Enable the I2C1 PEC transfer \*/ I2C_TransmitPEC(I2C1，ENABLE);

# 11.2.21 函数I2C_PECPositionConfig

Table 235. 描述了函数 I2C_PECPositionConfig

Table 235. 函数 I2C_PECPositionConfig  

<table><tr><td>函数名</td><td>I2C_PECPositionConfig</td></tr><tr><td>函数原形</td><td>void I2C_PECPositionConfig(I2C_TYPEDef* I2Cx, u16 I2C_PECPosition)</td></tr><tr><td>功能描述</td><td>选择指定 I2C 的 PEC 位置</td></tr><tr><td>输入参数 1</td><td>I2Cx: x 可以是 1 或者 2, 来选择 I2C 外设</td></tr><tr><td>输入参数 2</td><td>I2C_PECPosition: PEC 位置
参阅 Section: I2C_PECPosition 查阅更多该参数允许取值范围</td></tr><tr><td>输出参数</td><td>无</td></tr><tr><td>返回值</td><td>无</td></tr><tr><td>先决条件</td><td>无</td></tr><tr><td>被调用函数</td><td>无</td></tr></table>

# I2C_PECPosition

I2C_PECPosition 用以设置 PEC 位置。Table 235. 给出了该参数可取的值

Table 236. I2C_PECPosition 值  

<table><tr><td>I2C_PECPosition</td><td>描述</td></tr><tr><td>I2C_PECPosition_Next</td><td>PEC位提示下一字为PEC</td></tr><tr><td>I2C_PECPosition_Current</td><td>PEC位提示当前字为PEC</td></tr></table>

例：

/* Configure the PEC bit to indicates that the next byte in shift

register is PEC for I2C2 */

I2C_PECPositionConfig(I2C2, I2C_PECPosition_Next);

# 11.2.22 函数I2C CalculatePEC

Table 237. 描述了函数 I2C CalculatePEC

Table 237. 函数 I2C CalculatePEC  

<table><tr><td>函数名</td><td>I2C_CalculatePEC</td></tr><tr><td>函数原形</td><td>void I2C_CalculatePEC(I2CTypeDef* I2Cx, FunctionalState NewState)</td></tr><tr><td>功能描述</td><td>使能或者失能指定 I2C 的传输字 PEC 值计算</td></tr><tr><td>输入参数 1</td><td>I2Cx: x 可以是 1 或者 2, 来选择 I2C 外设</td></tr><tr><td>输入参数 2</td><td>NewState: I2Cx 传输字 PEC 值计算的新状态
这个参数可以取: ENABLE 或者 DISABLE</td></tr><tr><td>输出参数</td><td>无</td></tr><tr><td>返回值</td><td>无</td></tr><tr><td>先决条件</td><td>无</td></tr><tr><td>被调用函数</td><td>无</td></tr></table>

例：

/* Enable the PEC calculation for the transferred bytes from I2C2 */

I2C_CalculatePEC(I2C2, ENABLE);

# 11.2.23 函数I2C_GetPEC

Table 238. 描述了函数 I2C_GetPEC

Table 238. 函数 I2C_GetPEC  

<table><tr><td>函数名</td><td>I2C_GetPEC</td></tr><tr><td>函数原形</td><td>u8 I2C_GetPEC(I2C_TYPEDef* I2Cx)</td></tr><tr><td>功能描述</td><td>返回指定 I2C 的 PEC 值</td></tr><tr><td>输入参数</td><td>I2Cx: x 可以是 1 或者 2, 来选择 I2C 外设</td></tr><tr><td>输出参数</td><td>无</td></tr><tr><td>返回值</td><td>PEC 值</td></tr><tr><td>先决条件</td><td>无</td></tr><tr><td>被调用函数</td><td>无</td></tr></table>

例：

```javascript
/\* Returns the I2C2 PEC value \*/ u8 PECValue; PECValue  $=$  I2C_GetPEC(I2C2);
```

# 11.2.24 函数I2C_ARPCmd

Table 239. 描述了函数 I2C_ARPcmd

Table 239. 函数 I2C_ARPcmd  

<table><tr><td>函数名</td><td>I2C_ARPcmd</td></tr><tr><td>函数原形</td><td>void I2C_ARPcmd(I2CTypeDef* I2Cx, FunctionalState NewState)</td></tr><tr><td>功能描述</td><td>使能或者失能指定 I2C 的 ARP</td></tr><tr><td>输入参数 1</td><td>I2Cx: x 可以是 1 或者 2, 来选择 I2C 外设</td></tr><tr><td>输入参数 2</td><td>NewState: I2Cx ARP 的新状态
这个参数可以取: ENABLE 或者 DISABLE</td></tr><tr><td>输出参数</td><td>无</td></tr><tr><td>返回值</td><td>无</td></tr><tr><td>先决条件</td><td>无</td></tr><tr><td>被调用函数</td><td>无</td></tr></table>

例：

```txt
/\*Enable the I2C1 ARP feature \*/ I2C_ARPCmd(I2C1，ENABLE);
```

# 11.2.25 函数I2C_SqueezeClockCmd

Table 240. 描述了函数 I2C_SqueezeClockCmd

Table 240. 函数 I2C_SqueezeClockCmd  

<table><tr><td>函数名</td><td>I2C_SqueezeCmd</td></tr><tr><td>函数原形</td><td>void I2C_SqueezeCmd(I2CTypeDef* I2Cx, FunctionalState NewState)</td></tr><tr><td>功能描述</td><td>使能或者失能指定 I2C 的时钟延展</td></tr><tr><td>输入参数 1</td><td>I2Cx: x 可以是 1 或者 2, 来选择 I2C 外设</td></tr><tr><td>输入参数 2</td><td>NewState: I2Cx 时钟延展的新状态
这个参数可以取: ENABLE 或者 DISABLE</td></tr><tr><td>输出参数</td><td>无</td></tr><tr><td>返回值</td><td>无</td></tr><tr><td>先决条件</td><td>无</td></tr><tr><td>被调用函数</td><td>无</td></tr></table>

例：  
/* Enable the I2C2 clock stretching */  
I2C_StretchClockCmd(I2C2, ENABLE);

# 11.2.26 函数I2C_FastModeDutyCycleConfig

Table 241. 描述了函数 I2C_FastModeDutyCycleConfig

Table 241. 函数 I2C_FastModeDutyCycleConfig  

<table><tr><td>函数名</td><td>I2C_FastModeDutyCycleConfig</td></tr><tr><td>函数原形</td><td>void I2C_FastModeDutyCycleConfig(I2C_TYPEDef* I2Cx, u16 I2C_DutyCycle)</td></tr><tr><td>功能描述</td><td>选择指定 I2C 的快速模式占空比</td></tr><tr><td>输入参数 1</td><td>I2Cx: x 可以是 1 或者 2, 来选择 I2C 外设</td></tr><tr><td>输入参数 2</td><td>I2C_DutyCycle: 快速模式占空比
参阅 Section: I2C_DutyCycle 查阅更多该参数允许取值范围</td></tr><tr><td>输出参数</td><td>无</td></tr><tr><td>返回值</td><td>无</td></tr><tr><td>先决条件</td><td>无</td></tr><tr><td>被调用函数</td><td>无</td></tr></table>

# 12C_DutyCycle

I2C_DutyCycle 用以设置 I2C 快速模式的占空比。Table 242. 给出了该参数可取的值

Table 242. I2C_DutyCycle 值  

<table><tr><td>I2C_DutyCycle</td><td>描述</td></tr><tr><td>I2C_DutyCycle_16_9</td><td>I2C 快速模式 Tlow / Thigh = 16/9</td></tr><tr><td>I2C_DutyCycle_2</td><td>I2C 快速模式 Tlow / Thigh = 2</td></tr></table>

例：  
/* Set the fast mode duty cyle to 16/9 for I2C2 */
I2C_FastModeDutyCycleConfig(I2C2, I2C_DutyCycle_16_9);

# 11.2.27 函数I2C_GetLastEvent

Table 243. 描述了函数 I2C_GetLastEvent

Table 243. 函数 I2C_GetLastEvent  

<table><tr><td>函数名</td><td>I2C_GetLastEvent</td></tr><tr><td>函数原形</td><td>u32 I2C_GetLastEvent(I2C_TYPEDef* I2Cx)</td></tr><tr><td>功能描述</td><td>返回最近一次I2C事件</td></tr><tr><td>输入参数</td><td>I2Cx: x可以是1或者2,来选择I2C外设</td></tr><tr><td>输出参数</td><td>无</td></tr><tr><td>返回值</td><td>最近一次I2C事件</td></tr><tr><td>先决条件</td><td>无</td></tr><tr><td>被调用函数</td><td>无</td></tr></table>

```c
例：
/* Get last I2C1 event */
u32 Event;
Event = I2C_GetLastEvent(I2C1);
11.2.28 函数 I2CcheckingEvent
Table 244. 描述了函数 I2CcheckingEvent
```

Table 244. 函数 I2C ✓CheckEvent  

<table><tr><td>函数名</td><td>I2C_CheckEvent</td></tr><tr><td>函数原形</td><td>ErrorStatus I2C_CheckEvent(I2C_TYPEDef* I2Cx, u32 I2C_EVENT)</td></tr><tr><td>功能描述</td><td>检查最近一次 I2C 事件是否是输入的事件</td></tr><tr><td>输入参数 1</td><td>I2Cx: x 可以是 1 或者 2, 来选择 I2C 外设</td></tr><tr><td>输入参数 3</td><td>I2C_Event: 待检查的事件
参阅 Section: I2C_Event 查阅更多该参数允许取值范围</td></tr><tr><td>输出参数</td><td>无</td></tr><tr><td>返回值</td><td>ErrorStatus 枚举值:
SUCCEED: 最近一次 I2C 事件是 I2C_Event
ERROR: 最近一次 I2C 事件不是 I2C_Event</td></tr><tr><td>先决条件</td><td>无</td></tr><tr><td>被调用函数</td><td>无</td></tr></table>

# I2C_Event

Table 245.列举了所有可以被函数 I2C ✓CheckEvent 检查的事件。

Table 245. I2C_Event 值  

<table><tr><td>I2C_Event</td><td>描述</td></tr><tr><td>I2C_EVENT_SLAVE RECEIVER_ADDRESS_MATCHED</td><td>EV1</td></tr><tr><td>I2C_EVENT_SLAVE_TRANSMITTER_ADDRESS_MATCHED</td><td>EV1</td></tr><tr><td>I2C_EVENT_SLAVE RECEIVER_SECONDADDRESS_MATCHED</td><td>EV1</td></tr><tr><td>I2C_EVENT_SLAVE_TRANSMITTER_SECONDADDRESS_MATCHED</td><td>EV1</td></tr><tr><td>I2C_EVENT_SLAVE_generalCALLADDRESS_MATCHED</td><td>EV1</td></tr><tr><td>I2C_EVENT_SLAVE_BYTE_RECEIVED</td><td>EV2</td></tr><tr><td>I2C_EVENT_SLAVE_BYTE_TRANSMITTED</td><td>EV3</td></tr><tr><td>I2C_EVENT_SLAVE_ACK_FAILURE</td><td>EV3-1</td></tr><tr><td>I2C_EVENT_SLAVE_STOP_MATCHED</td><td>EV4</td></tr><tr><td>I2C_EVENT MASTER_MODE_SELECT</td><td>EV5</td></tr><tr><td>I2C_EVENT MASTER RECEIVER_MODE_SELECT</td><td>EV6</td></tr><tr><td>I2C_EVENT MASTER_TRANSMITTER_MODE_SELECT</td><td>EV6</td></tr><tr><td>I2C_EVENT MASTER_BYTE_received</td><td>EV7</td></tr><tr><td>I2C_EVENT MASTER_BYTE_TRANSMITTED</td><td>EV8</td></tr><tr><td>I2C_EVENT MASTER_MODE_ADDRESS10</td><td>EV9</td></tr></table>

例：

```javascript
/\* Check if the event happen on I2C1 is equal to I2C_EVENT MASTER_BYTE_received \*/ ErrorStatus Status; Status  $=$  I2C ✓CheckEvent(I2C1,I2C_EVENT MASTER_BYTE_received);
```

# 11.2.29 函数I2C_GetFlagStatus

Table 246. 描述了函数 I2C_GetFlagStatus

Table 246. 函数 I2C_GetFlagStatus  

<table><tr><td>函数名</td><td>I2C_GetFlagStatus</td></tr><tr><td>函数原形</td><td>FlagStatus I2C_GetFlagStatus(I2C_TYPEDef* I2Cx, u32 I2C_FLAG)</td></tr><tr><td>功能描述</td><td>检查指定的 I2C 标志位设置与否</td></tr><tr><td>输入参数 1</td><td>I2Cx: x 可以是 1 或者 2 , 来选择 I2C 外设</td></tr><tr><td>输入参数 2</td><td>I2C_FLAG: 待检查的 I2C 标志位参阅 Section: I2C_FLAG 查阅更多该参数允许取值范围</td></tr><tr><td>输出参数</td><td>无</td></tr><tr><td>返回值</td><td>I2C_FLAG 的新状态1.</td></tr><tr><td>先决条件</td><td>无</td></tr><tr><td>被调用函数</td><td>无</td></tr></table>

1. 读取寄存器可能会清除某些标志位

# I2C_FLAG

Table 247. 给出了所有可以被函数 I2C_GetFlagStatus 检查的标志位列表

Table 247. I2C_FLAG 值  

<table><tr><td>I2C_FLAG</td><td>描述</td></tr><tr><td>I2C_FLAG DualF</td><td>双标志位（从模式）</td></tr><tr><td>I2C_FLAG_SMBHOST</td><td>SMBus 主报头（从模式）</td></tr><tr><td>I2C_FLAG_SMBDEFAULT</td><td>SMBus 缺省报头（从模式）</td></tr><tr><td>I2C_FLAG_GENCALL</td><td>广播报头标志位（从模式）</td></tr><tr><td>I2C_FLAG_TRA</td><td>发送/接收标志位</td></tr><tr><td>I2C_FLAG_BUSY</td><td>总线忙标志位</td></tr><tr><td>I2C_FLAG_MSL</td><td>主/从标志位</td></tr><tr><td>I2C_FLAG_SMBALERT</td><td>SMBus 报警标志位</td></tr><tr><td>I2C_FLAG_TIMEOUT</td><td>超时或者 Tlow 错误标志位</td></tr><tr><td>I2C_FLAG_PECERR</td><td>接收 PEC 错误标志位</td></tr><tr><td>I2C_FLAG_OVR</td><td>溢出/不足标志位（从模式）</td></tr><tr><td>I2C_FLAG_AF</td><td>应答错误标志位</td></tr><tr><td>I2C_FLAG_ARLO</td><td>仲裁丢失标志位（主模式）</td></tr><tr><td>I2C_FLAG_BERR</td><td>总线错误标志位</td></tr><tr><td>I2C_FLAG_TXE</td><td>数据寄存器空标志位（发送端）</td></tr><tr><td>I2C_FLAG_RXNE</td><td>数据寄存器非空标志位（接收端）</td></tr><tr><td>I2C_FLAG_STOPF</td><td>停止探测标志位（从模式）</td></tr><tr><td>I2C_FLAG_ADD10</td><td>10 位报头发送（主模式）</td></tr><tr><td>I2C_FLAG_BTF</td><td>字传输完成标志位</td></tr><tr><td>I2C_FLAG_ADDR</td><td>地址发送标志位（主模式）“ADSL”地址匹配标志位（从模式）“ENDAD”</td></tr><tr><td>I2C_FLAG_SB</td><td>起始位标志位（主模式）</td></tr></table>

注意：只有位[27: 0]被函数 I2C_GetFlagStatus 用来返回指定的标志位状态。值对应经计算的寄存器中的

标志位位置，该寄存器包含2个I2C状态寄存器I2C_SR1和I2C_SR2。

例：

```c
/\*Return the I2C_FLAG_AF flag state of I2C2 peripheral \*/ Flagstatus Status;   
Status  $=$  I2C_GetFlagStatus(I2C2，I2C_FLAG_AF);
```

# 11.2.30 函数I2C_ClearFlag

Table 248. 描述了函数 I2C_ClearFlag  
Table 248. 函数 I2C_ClearFlag  

<table><tr><td>函数名</td><td>I2C_ClearFlag</td></tr><tr><td>函数原形</td><td>void I2C_ClearFlag(I2C_TYPEDef* I2Cx, u32 I2C_FLAG)</td></tr><tr><td>功能描述</td><td>清除 I2Cx 的待处理标志位</td></tr><tr><td>输入参数 1</td><td>I2Cx: x 可以是 1 或者 2, 来选择 I2C 外设</td></tr><tr><td>输入参数 2</td><td>I2C_FLAG: 待清除的 I2C 标志位
参阅 Section: I2C_FLAG 查阅更多该参数允许取值范围
注意: 标志位 DUALF, SMBHOST, SMBDEFAULT, GENCALL, TRA, BUSY,MSL, TXE 和 RXNE 不能被本函数清除</td></tr><tr><td>输出参数</td><td>无</td></tr><tr><td>返回值</td><td>无</td></tr><tr><td>先决条件</td><td>无</td></tr><tr><td>被调用函数</td><td>无</td></tr></table>

# I2C_FLAG

Table 249. 给出了所有可以被函数 I2C_ClearFlag 清除的标志位列表

Table 249. I2C_FLAG 值  

<table><tr><td>I2C_FLAG</td><td>描述</td></tr><tr><td>I2C_FLAG_SMBALERT</td><td>SMBus 报警标志位</td></tr><tr><td>I2C_FLAG_TIMEOUT</td><td>超时或者 Tlow 错误标志位</td></tr><tr><td>I2C_FLAG_PECERR</td><td>接收 PEC 错误标志位</td></tr><tr><td>I2C_FLAG_OVR</td><td>溢出/不足标志位（从模式）</td></tr><tr><td>I2C_FLAG_AF</td><td>应答错误标志位</td></tr><tr><td>I2C_FLAG_ARLO</td><td>仲裁丢失标志位（主模式）</td></tr><tr><td>I2C_FLAG_BERR</td><td>总线错误标志位</td></tr><tr><td>I2C_FLAG_STOPF</td><td>停止探测标志位（从模式）</td></tr><tr><td>I2C_FLAG_ADD10</td><td>10 位报头发送（主模式）</td></tr><tr><td>I2C_FLAG_BTF</td><td>字传输完成标志位</td></tr><tr><td>I2C_FLAG_ADDR</td><td>地址发送标志位（主模式）“ADSL”地址匹配标志位（从模式）“ENDAD”</td></tr><tr><td>I2C_FLAG_SB</td><td>起始位标志位（主模式）</td></tr></table>

例：

```c
/* Clear the Stop detection flag on I2C2 */
I2C_ClearFlag(I2C2, I2C_FLAG_STOPF);
```

# 11.2.31 函数I2C_GetITStatus

Table 250. 描述了函数 I2C_GetITStatus

Table 250. 函数 I2C_GetITStatus  

<table><tr><td>函数名</td><td>I2C_GetITStatus</td></tr><tr><td>函数原形</td><td>ITStatus I2C_GetITStatus(I2CTypeDef* I2Cx, u32 I2C_IT)</td></tr><tr><td>功能描述</td><td>检查指定的 I2C 中断发生与否</td></tr><tr><td>输入参数 1</td><td>I2Cx: x 可以是 1 或者 2 , 来选择 I2C 外设</td></tr><tr><td>输入参数 2</td><td>I2C_IT: 待检查的 I2C 中断源
参阅 Section: I2C_IT 查阅更多该参数允许取值范围</td></tr><tr><td>输出参数</td><td>无</td></tr><tr><td>返回值</td><td>I2C_IT 的新状态 (SET 或者 RESET) 1 .</td></tr><tr><td>先决条件</td><td>无</td></tr><tr><td>被调用函数</td><td>无</td></tr></table>

1. 读取寄存器可能会清除某些标志位

# I2C_IT

Table 251. 给出了所有可以被函数 I2C_GetITStatus 检查的中断标志位列表

Table 251. I2C_IT 值  

<table><tr><td>I2C_IT</td><td>描述</td></tr><tr><td>I2C_IT_SMBALERT</td><td>SMBus 报警标志位</td></tr><tr><td>I2C_IT_TIMEOUT</td><td>超时或者 Tlow 错误标志位</td></tr><tr><td>I2C_IT_PECERR</td><td>接收 PEC 错误标志位</td></tr><tr><td>I2C_IT_OVR</td><td>溢出/不足标志位（从模式）</td></tr><tr><td>I2C_IT_AF</td><td>应答错误标志位</td></tr><tr><td>I2C_IT_ARLO</td><td>仲裁丢失标志位（主模式）</td></tr><tr><td>I2C_IT_BERR</td><td>总线错误标志位</td></tr><tr><td>I2C_IT_STOPF</td><td>停止探测标志位（从模式）</td></tr><tr><td>I2C_IT_ADD10</td><td>10 位报头发送（主模式）</td></tr><tr><td>I2C_IT_BTF</td><td>字传输完成标志位</td></tr><tr><td>I2C_IT_ADDR</td><td>地址发送标志位（主模式）“ADSL”地址匹配标志位（从模式）“ENDAD”</td></tr><tr><td>I2C_IT_SB</td><td>起始位标志位（主模式）</td></tr></table>

例：

/* Return the I2C_IT_OVR flag state of I2C1 peripheral */

ITstatus Status;

Status = I2C_GetITStatus(I2C1, I2C_IT_OVR);

# 11.2.32 函数I2C_ClearITPendingBit

Table 252. 描述了函数 I2C_ClearITPendingBit  
Table 252. 函数 I2C_ClearITPendingBit  

<table><tr><td>函数名</td><td>I2C_ClearITPendingBit</td></tr><tr><td>函数原形</td><td>void I2C_ClearITPendingBit(I2C_TYPEDef* I2Cx, u32 I2C_IT)</td></tr><tr><td>功能描述</td><td>清除I2Cx的中断待处理位</td></tr><tr><td>输入参数1</td><td>I2Cx: x可以是1或者2,来选择I2C外设</td></tr><tr><td>输入参数2</td><td>I2C_IT: 待检查的I2C中断源
参阅 Section: I2C_IT 查阅更多该参数允许取值范围</td></tr><tr><td>输出参数</td><td>无</td></tr><tr><td>返回值</td><td>无</td></tr><tr><td>先决条件</td><td>无</td></tr><tr><td>被调用函数</td><td>无</td></tr></table>

# I2C_IT

Table 253. 给出了所有可以被函数 I2C_ClearITPendingBit 清除的中断待处理位列表  
Table 253. I2C_IT 值  

<table><tr><td>I2C_IT</td><td>描述</td></tr><tr><td>I2C_IT_SMBALERT</td><td>SMBus 报警标志位</td></tr><tr><td>I2C_IT_TIMEOUT</td><td>超时或者 Tlow 错误标志位</td></tr><tr><td>I2C_IT_PECERR</td><td>接收 PEC 错误标志位</td></tr><tr><td>I2C_IT_OVR</td><td>溢出/不足标志位（从模式）</td></tr><tr><td>I2C_IT_AF</td><td>应答错误标志位</td></tr><tr><td>I2C_IT_ARLO</td><td>仲裁丢失标志位（主模式）</td></tr><tr><td>I2C_IT_BERR</td><td>总线错误标志位</td></tr><tr><td>I2C_IT_STOPF</td><td>停止探测标志位（从模式）</td></tr><tr><td>I2C_IT_ADD10</td><td>10 位报头发送（主模式）</td></tr><tr><td>I2C_IT_BTF</td><td>字传输完成标志位</td></tr><tr><td>I2C_IT_ADDR</td><td>地址发送标志位（主模式）“ADSL”地址匹配标志位（从模式）“ENDAD”</td></tr><tr><td>I2C_IT_SB</td><td>起始位标志位（主模式）</td></tr></table>

例：  
/* Clear the Timeout interrupt opending bit on I2C2 */  
I2C_ClearITPendingBit(I2C2, I2C_IT_TIMEOUT);

# 12 独立看门狗（IWDG）

独立看门狗（IWDG）用来解决应软件或者硬件引起的处理器故障。它也可以在停止（Stop）模式和待命（Standby）模式下工作。

Section 12.1 IWDG 寄存器结构描述了固件函数库所使用的数据结构，Section 12.2 固件库函数介绍了函数库里的所有函数。

# 12.1 IWDG寄存器结构

IWDG 寄存器结构，IWDG_TypeDeff，在文件“stm32f10x_map.h”中定义如下：

```txt
typedef struct  
{  
vu32 KR;  
vu32 PR;  
vu32 RLR;  
vu32 SR;  
} IWDG_TYPEDef;  
Table 254.例举了IWDG所有寄存器
```

Table 254. IWDG 寄存器  

<table><tr><td>寄存器</td><td>描述</td></tr><tr><td>KR</td><td>IWDG键值寄存器</td></tr><tr><td>PR</td><td>IWDG预分频寄存器</td></tr><tr><td>RLR</td><td>IWDG重装载寄存器</td></tr><tr><td>SR</td><td>IWDG状态寄存器</td></tr></table>

```c
IWDG外设声明于文件"stm32f10x_map.h":  
#define PERIPH_BASE((u32)0x40000000)  
#define APB1PERIPH_BASE PERIPH_BASE  
#define APB2PERIPH_BASE (PERIPH_BASE + 0x10000)  
#define AHBPERIPH_BASE (PERIPH_BASE + 0x20000)  
#define IWDG_BASE (APB1PERIPH_BASE + 0x3000)  
#ifndef DEBUG  
...  
#ifndef_IWDG  
#define IWDG ((IWDGTypeDef *) IWDG_BASE)  
endif /*_IWDG*/  
...  
else /* DEBUG*/  
...  
#ifndef_IWDG  
EXT IWDGTypeDef *IWDG;  
endif /*_IWDG*/  
...  
endif  
使用Debug模式时，初始化指针IWDG于文件"stm32f10x_lib.c":  
#ifdef IWDG  
IWDG = (IWDGTypeDef *) IWDG_BASE;  
#endif /*_IWDG*/  
为了访问IWDG寄存器，_IWDG必须在文件"stm32f10x_conf.h"中定义如下：  
#define IWDG
```

# 12.2 IWDG库函数

Table 255. 例举了 IWDG 的库函数  
Table 255. IWDG 库函数  

<table><tr><td>函数名</td><td>描述</td></tr><tr><td>IWDG_WritesAccessCmd</td><td>使能或者失能对寄存器 IWDG_PR 和 IWDG_RLR 的写操作</td></tr><tr><td>IWDG_SetPrescaler</td><td>设置 IWDG 预分频值</td></tr><tr><td>IWDG_SetReload</td><td>设置 IWDG 重装载值</td></tr><tr><td>IWDG_ReloadCounter</td><td>按照 IWDG 重装载寄存器的值重装载 IWDG 计数器</td></tr><tr><td>IWDG_Enable</td><td>使能 IWDG</td></tr><tr><td>IWDG_GetFlagStatus</td><td>检查指定的 IWDG 标志位被设置与否</td></tr></table>

# 12.2.1 函数IWDG_WriteAccessCmd

Table 256. 描述了函数 IWDG_WritesCmd  
Table 256. 函数 IWDG_WritesAccessCmd  

<table><tr><td>函数名</td><td>IWDG_WritesAccessCmd</td></tr><tr><td>函数原形</td><td>void IWDG_WritesAccessCmd(u16 IWDG_WritesAccess)</td></tr><tr><td>功能描述</td><td>使能或者失能对寄存器 IWDG_PR 和 IWDG_RLR 的写操作</td></tr><tr><td>输入参数</td><td>IWDG_WritesAccess: 对寄存器 IWDG_PR 和 IWDG_RLR 的写操作的新状态参阅 Section: IWDG_WritesAccess 查阅更多该参数允许取值范围</td></tr><tr><td>输出参数</td><td>无</td></tr><tr><td>返回值</td><td>无</td></tr><tr><td>先决条件</td><td>无</td></tr><tr><td>被调用函数</td><td>无</td></tr></table>

# IWDG_WriteAccess

该参数使能或者失能对寄存器 IWDG_PR 和 IWDG_RLR 的写操作（见 Table.257）。

Table 257. IWDG_Writes 值  

<table><tr><td>IWDG_WritesAccess</td><td>描述</td></tr><tr><td>IWDG_WritesAccess_Enable</td><td>使能对寄存器 IWDG_PR 和 IWDG_RLR 的写操作</td></tr><tr><td>IWDG_WritesAccess_Disable</td><td>失能对寄存器 IWDG_PR 和 IWDG_RLR 的写操作</td></tr></table>

例：

/* Enable write access to IWDG_PR and IWDG_RLR registers */
IWDG_WriteAccessCmd(IWDG_WriteAccess_Enable);

# 12.2.2 函数IWDG_SetPrescaler

Table 258. 描述了函数 IWDG_SetPrescaler

Table 258. 函数 IWDG_SetPrescaler  

<table><tr><td>函数名</td><td>IWDG_SetPrescaler</td></tr><tr><td>函数原形</td><td>void IWDG_SetPrescaler(u8 IWDG_Prescaler)</td></tr><tr><td>功能描述</td><td>设置 IWDG 预分频值</td></tr><tr><td>输入参数</td><td>IWDG_Prescaler: IWDG 预分频值
参阅 Section: IWDG_Prescaler 查阅更多该参数允许取值范围</td></tr><tr><td>输出参数</td><td>无</td></tr><tr><td>返回值</td><td>无</td></tr><tr><td>先决条件</td><td>无</td></tr><tr><td>被调用函数</td><td>无</td></tr></table>

# IWDG Prescaler

该参数设置IWDG预分频值（见Table.259）。

Table 259. IWDG_Prescaler 值  

<table><tr><td>IWDG_Prescaler</td><td>描述</td></tr><tr><td>IWDG_Prescaler_4</td><td>设置 IWDG 预分频值为 4</td></tr><tr><td>IWDG_Prescaler_8</td><td>设置 IWDG 预分频值为 8</td></tr><tr><td>IWDG_Prescaler_16</td><td>设置 IWDG 预分频值为 16</td></tr><tr><td>IWDG_Prescaler_32</td><td>设置 IWDG 预分频值为 32</td></tr><tr><td>IWDG_Prescaler_64</td><td>设置 IWDG 预分频值为 64</td></tr><tr><td>IWDG_Prescaler_128</td><td>设置 IWDG 预分频值为 128</td></tr><tr><td>IWDG_Prescaler_256</td><td>设置 IWDG 预分频值为 256</td></tr></table>

例：/\*SetIWDGprescalerto8\*/IWDG_SetPrescaler(IWDG_Prescaler_8);

# 12.2.3 函数IWDG_SetReload

Table 260. 描述了函数 IWDG_SetReload

Table 260. 函数 IWDG_SetReload  

<table><tr><td>函数名</td><td>IWDG_SetReload</td></tr><tr><td>函数原形</td><td>void IWDG_SetReload(u16 Reload)</td></tr><tr><td>功能描述</td><td>设置 IWDG 重装载值</td></tr><tr><td>输入参数</td><td>IWDG_Reload: IWDG 重装载值
该参数允许取值范围为 0 - 0xFFFF</td></tr><tr><td>输出参数</td><td>无</td></tr><tr><td>返回值</td><td>无</td></tr><tr><td>先决条件</td><td>无</td></tr><tr><td>被调用函数</td><td>无</td></tr></table>

例：  
/* Set IWDG reload value to 0xFFFF */  
IWDG_SetReload(0xFFFF);

# 12.2.4 函数IWDG_ReloadCounter

Table 261. 描述了函数 IWDG ReloadCounter

Table 261. 函数 IWDG_ReloadCounter  

<table><tr><td>函数名</td><td>IWDG_ReloadCounter</td></tr><tr><td>函数原形</td><td>void IWDG_ReloadCounter(void)</td></tr><tr><td>功能描述</td><td>按照 IWDG 重装载寄存器的值重装载 IWDG 计数器</td></tr><tr><td>输入参数</td><td>无</td></tr><tr><td>输出参数</td><td>无</td></tr><tr><td>返回值</td><td>无</td></tr><tr><td>先决条件</td><td>无</td></tr><tr><td>被调用函数</td><td>无</td></tr></table>

例：/\*ReloadIWDGcounter\*/IWDG ReloadCounter();

# 12.2.5 函数IWDG_Enable

Table 262. 描述了函数 IWDG_Enable

Table 262. 函数 IWDG_Enable  

<table><tr><td>函数名</td><td>IWDG_Enable</td></tr><tr><td>函数原形</td><td>void IWDG_Enable(void)</td></tr><tr><td>功能描述</td><td>使能 IWDG</td></tr><tr><td>输入参数</td><td>无</td></tr><tr><td>输出参数</td><td>无</td></tr><tr><td>返回值</td><td>无</td></tr><tr><td>先决条件</td><td>无</td></tr><tr><td>被调用函数</td><td>无</td></tr></table>

例：/\*EnableIWDG\*/IWDG_Enable();

# 12.2.6 函数IWDG_GetFlagStatus

Table 263. 描述了函数 IWDG_GetFlagStatus

Table 263. 函数 IWDG_GetFlagStatus  

<table><tr><td>函数名</td><td>IWDG_GetFlagStatus</td></tr><tr><td>函数原形</td><td>FlagStatus IWDG_GetFlagStatus(u16 IWDG_FLAG)</td></tr><tr><td>功能描述</td><td>检查指定的 IWDG 标志位被设置与否</td></tr><tr><td>输入参数</td><td>IWDG_FLAG: 待检查的 I2C 标志位
参阅 Section: IWDG_FLAG 查阅更多该参数允许取值范围</td></tr><tr><td>输出参数</td><td>无</td></tr><tr><td>返回值</td><td>IWDG_FLAG 的新状态 (SET 或者 RESET)</td></tr><tr><td>先决条件</td><td>无</td></tr><tr><td>被调用函数</td><td>无</td></tr></table>

# IWDG FLAG

Table 264. 给出了所有可以被函数 IWDG_GetFlagStatus 清除的标志位列表

Table 264. IWDG_FLAG 值  

<table><tr><td>IWDG_FLAG</td><td>描述</td></tr><tr><td>IWDG_FLAG_PVU</td><td>预分频值更新进行中</td></tr><tr><td>IWDG_FLAG_RVU</td><td>重装载值更新进行中</td></tr></table>

例：

```lisp
/\*Testifapriscalervalueupdateisongoing\*/ FlagStatus Status;   
Status  $\equiv$  IWDG_GetFlagStatus(IWDG_FLAG_PVU);   
if(Status  $= =$  RESET)   
{   
}   
else   
{   
}
```

# 13 嵌套向量中断控制器（NVIC）

NVIC驱动有多种用途：例如使能或者失能IRQ中断，使能或者失能单独的IRQ通道，改变IRQ通道的优先级等等。

Section 13.1 NVIC 寄存器结构描述了固件函数库所使用的数据结构，Section 13.2 固件库函数介绍了函数库里的所有函数。

# 13.1 NVIC寄存器结构

NVIC寄存器结构，NVIC_TYPEDeff，在文件“stm32f10x_map.h”中定义如下：

```c
typedef struct   
{ vu32 Enable[2]; u32 RESERVED0[30]; vu32 Disable[2]; u32 RSERVED1[30]; vu32 Set[2]; u32 RESERVED2[30]; vu32 Clear[2]; u32 RESERVED3[30]; vu32 Active[2]; u32 RESERVED4[62]; vu32 Priority[11]; } NVICTypeDef;/* NVIC Structure */ typedef struct { vu32 CPHID; vu32 IRQControlState; vu32 ExceptionTableOffset; vu32 AIRC; vu32 SysCtrl; vu32 ConfigCtrl; vu32 SystemPriority[3]; vu32 SysHandlerCtrl; vu32 ConfigFaultStatus; vu32 HardFaultStatus; vu32 DebugFaultStatus; vu32 MemoryManageFaultAddr; vu32 BusFaultAddr; } SCBTypeDef;/* System Control Block Structure */
```

Table 265.例举了NVIC所有寄存器  
Table 265. NVIC 寄存器  

<table><tr><td>寄存器</td><td>描述</td></tr><tr><td>Enable</td><td>中断设置使能寄存器</td></tr><tr><td>Disable</td><td>中断清除使能寄存器</td></tr><tr><td>Set</td><td>中断设置待处理寄存器</td></tr><tr><td>Clear</td><td>中断清除待处理寄存器</td></tr><tr><td>Active</td><td>中断活动位寄存器</td></tr><tr><td>Priority</td><td>中断优先级寄存器</td></tr><tr><td>CPUID</td><td>CPU ID 基寄存器</td></tr><tr><td>IRQControlStatus</td><td>中断控制状态寄存器</td></tr><tr><td>ExceptionTableOffset</td><td>向量表移位寄存器</td></tr></table>

# ST

译文英文原版为UM0427 Oct. 2007 Rev 2, 译文仅供参考，与英文版冲突的，以英文版为准

<table><tr><td>AIRC</td><td>应用控制/重置寄存器</td></tr><tr><td>SysCtrl</td><td>系统控制寄存器</td></tr><tr><td>ConfigCtrl</td><td>设置控制寄存器</td></tr><tr><td>SystemPriority</td><td>系统处理优先级寄存器</td></tr><tr><td>SysHandlerCtrl</td><td>系统处理控制和状态寄存器</td></tr><tr><td>ConfigFaultStatus</td><td>设置错误状态寄存器</td></tr><tr><td>HardFaultStatus</td><td>硬件错误状态寄存器</td></tr><tr><td>DebugFaultStatus</td><td>除错错误寄存器</td></tr><tr><td>MemorymanageFaultAddr</td><td>存储器管理错误地址寄存器</td></tr><tr><td>BusFaultAddr</td><td>总线错误地址寄存器</td></tr></table>

NVIC外设声明于文件“stm32f10x_map.h”：

NVIC  
```c
define SCS_BASE((u32)0xE000E000)
#define NVIC_BASE(SCS_BASE + 0x0100)
#define SCB_BASE(SCS_BASE + 0xD00)
...
ifndef DEBUG
...
ifdef NVIC
#define NVIC((NVICTypeDef *) NVIC_BASE)
#define SCB((SCBTypeDef *) SCB_BASE)
endif /*_NVIC */
...
else /* DEBUG */
...
ifdef NVIC
EXT NVICTypeDef *NVIC;
EXT SCB_TYPEDef *SCB;
#endif /*_NVIC */
...
endif
使用Debug模式时，初始化指针NVIC,SCB于文件“stm32f10x_lib.c”:
#ifdef NVIC
NVIC = (NVICTypeDef *) NVIC_BASE;
SCB = (SCB_TYPEDef *) SCB_BASE;
#endif /*_NVIC */
为了访问NVIC寄存器，,_NVIC必须在文件“stm32f10x_conf.h”中定义如下:
#define NVIC
```

# 13.2 NVIC库函数

Table 266. 例举了 NVIC 的库函数  
Table 266. NVIC 库函数  

<table><tr><td>函数名</td><td>描述</td></tr><tr><td>NVIC_DeInit</td><td>将外设NVIC寄存器重设为缺省值</td></tr><tr><td>NVIC_SCBDelInit</td><td>将外设SCB寄存器重设为缺省值</td></tr><tr><td>NVIC_PriorityGroupConfig</td><td>设置优先级分组:先占优先级和从优先级</td></tr><tr><td>NVIC_Init</td><td>根据NVIC_InitStruct中指定的参数初始化外设NVIC寄存器</td></tr><tr><td>NVIC架构Init</td><td>把NVIC架构中的每一个参数按缺省值填入</td></tr><tr><td>NVIC_SETPRIMASK</td><td>使能PRIMASK优先级:提升执行优先级至0</td></tr><tr><td>NVIC_RESETPRIMASK</td><td>失能PRIMASK优先级</td></tr><tr><td>NVIC_SETFAULTMASK</td><td>使能FAULTMASK优先级:提升执行优先级至-1</td></tr><tr><td>NVIC_RESETFAULTMASK</td><td>失能FAULTMASK优先级</td></tr><tr><td>NVIC_BASEPRICONFIG</td><td>改变执行优先级从N(最低可设置优先级)提升至1</td></tr><tr><td>NVIC_GetBASEPRI</td><td>返回BASEPRI屏蔽值</td></tr><tr><td>NVIC_GetCurrentPendingIRQChannel</td><td>返回当前待处理IRQ标识符</td></tr><tr><td>NVIC_GetIRQChannelPendingBitStatus</td><td>检查指定的IRQ通道待处理位设置与否</td></tr><tr><td>NVIC_SetIRQChannelPendingBit</td><td>设置指定的IRQ通道待处理位</td></tr><tr><td>NVIC_ClearIRQChannelPendingBit</td><td>清除指定的IRQ通道待处理位</td></tr><tr><td>NVIC_GetCurrentActiveHandler</td><td>返回当前活动的Handler(IRQ通道和系统Handler)的标识符</td></tr><tr><td>NVIC_GetIRQChannelActiveBitStatus</td><td>检查指定的IRQ通道活动位设置与否</td></tr><tr><td>NVIC_GetCPUID</td><td>返回ID号码,Cortex-M3内核的版本号和实现细节</td></tr><tr><td>NVIC_SetVectorTable</td><td>设置向量表的位置和偏移</td></tr><tr><td>NVIC_GenerateSystemReset</td><td>产生一个系统复位</td></tr><tr><td>NVIC_GenerateCoreReset</td><td>产生一个内核(内核+NVIC)复位</td></tr><tr><td>NVIC_SystemLPConfig</td><td>选择系统进入低功耗模式的条件</td></tr><tr><td>NVIC_SystemHandlerConfig</td><td>使能或者失能指定的系统Handler</td></tr><tr><td>NVIC_SystemHandlerPriorityConfig</td><td>设置指定的系统Handler优先级</td></tr><tr><td>NVIC_GetSystemHandlerPendingBitStatus</td><td>检查指定的系统Handler待处理位设置与否</td></tr><tr><td>NVIC_SetSystemHandlerPendingBit</td><td>设置系统Handler待处理位</td></tr><tr><td>NVIC_ClearSystemHandlerPendingBit</td><td>清除系统Handler待处理位</td></tr><tr><td>NVIC_GetSystemHandlerActiveBitStatus</td><td>检查系统Handler活动位设置与否</td></tr><tr><td>NVIC_GetFaultHandlerSources</td><td>返回表示出错的系统Handler源</td></tr><tr><td>NVIC_GetFaultAddress</td><td>返回产生表示出错的系统Handler所在位置的地址</td></tr></table>

# 13.2.1 函数NVIC_DeInit

Table 267. 描述了函数 NVIC_DeInit  
Table 267. 函数 NVIC_DeInit  

<table><tr><td>函数名</td><td>NVIC_DeInit</td></tr><tr><td>函数原形</td><td>void NVIC_DeInit(void)</td></tr><tr><td>功能描述</td><td>将外设NVIC寄存器重设为缺省值</td></tr><tr><td>输入参数</td><td>无</td></tr><tr><td>输出参数</td><td>无</td></tr><tr><td>返回值</td><td>无</td></tr><tr><td>先决条件</td><td>无</td></tr><tr><td>被调用函数</td><td>无</td></tr></table>

例：  
/* Resets the NVIC registers to their default reset value */ NVIC_DeInit();

# 13.2.2 函数NVIC_SCBDInit

Table 268. 描述了函数NVIC_SCBDeInit  
Table 268. 函数 NVIC_SCBDeInit  

<table><tr><td>函数名</td><td>NVIC_SCBDeInit</td></tr><tr><td>函数原形</td><td>void NVIC_SCBDeInit(void)</td></tr><tr><td>功能描述</td><td>将外设SCB寄存器重设为缺省值</td></tr><tr><td>输入参数</td><td>无</td></tr><tr><td>输出参数</td><td>无</td></tr><tr><td>返回值</td><td>无</td></tr><tr><td>先决条件</td><td>无</td></tr><tr><td>被调用函数</td><td>无</td></tr></table>

例：  
/* Resets the SCB registers to their default reset value */NVIC_SCBDInit();

# 13.2.3 函数NVIC_PriorityGroupConfig

Table 269. 描述了函数 NVIC_PriorityGroupConfig

Table 269. 函数 NVIC_PriorityGroupConfig  

<table><tr><td>函数名</td><td>NVIC_PriorityGroupConfig</td></tr><tr><td>函数原形</td><td>void NVIC_PriorityGroupConfig(u32 NVIC_PriorityGroup)</td></tr><tr><td>功能描述</td><td>设置优先级分组: 先占优先级和从优先级</td></tr><tr><td>输入参数</td><td>NVIC_PriorityGroup: 优先级分组位长度
参阅 Section: NVIC_PriorityGroup 查阅更多该参数允许取值范围</td></tr><tr><td>输出参数</td><td>无</td></tr><tr><td>返回值</td><td>无</td></tr><tr><td>先决条件</td><td>优先级分组只能设置一次</td></tr><tr><td>被调用函数</td><td>无</td></tr></table>

# NVIC_PriorityGroup

该参数设置优先级分组位长度（见Table270.）

Table 270. NVIC_PriorityGroup 值  

<table><tr><td>NVIC_PriorityGroup</td><td>描述</td></tr><tr><td>NVIC_PriorityGroup_0</td><td>先占优先级0位从优先级4位</td></tr><tr><td>NVIC_PriorityGroup_1</td><td>先占优先级1位从优先级3位</td></tr><tr><td>NVIC_PriorityGroup_2</td><td>先占优先级2位从优先级2位</td></tr><tr><td>NVIC_PriorityGroup_3</td><td>先占优先级3位从优先级1位</td></tr><tr><td>NVIC_PriorityGroup_4</td><td>先占优先级4位从优先级0位</td></tr></table>

例：  
/* Configure the Priority Grouping with 1 bit */
NVIC_PriorityGroupConfig(NVIC_PriorityGroup_1);

# 13.2.4 函数NVIC_Init

Table 271. 描述了函数 NVIC_Init  
Table 271. 函数 NVIC_Init  

<table><tr><td>函数名</td><td>NVIC_Init</td></tr><tr><td>函数原形</td><td>void NVIC_Init(NVIC_InitTypeDef* NVIC_InitStruct)</td></tr><tr><td>功能描述</td><td>根据 NVIC_InitStruct 中指定的参数初始化外设 NVIC 寄存器</td></tr><tr><td>输入参数</td><td>NVIC_InitStruct: 指向结构 NVIC_InitTypeDef 的指针, 包含了外设 GPIO 的配置信息参阅 Section: NVIC_InitTypeDef 查阅更多该参数允许取值范围</td></tr><tr><td>输出参数</td><td>无</td></tr><tr><td>返回值</td><td>无</td></tr><tr><td>先决条件</td><td>无</td></tr><tr><td>被调用函数</td><td>无</td></tr></table>

# NVIC_InitTypeDef structure

NVIC_InitTypeDef 定义于文件“stm32f10x_nvic.h”：

```txt
typedef struct   
{   
u8 NVIC_IRQChannel;   
u8 NVIC_IRQChannelPreemptionPriority;   
u8 NVIC_IRQChannelSubPriority;   
FunctionalState NVIC_IRQChannelCmd;   
} NVIC_InitTypeDef;
```

# NVIC_IRQChannel

该参数用以使能或者失能指定的 IRQ 通道。Table 272. 给出了该参数可取的值

Table 272. NVIC_IRQChannel 值  

<table><tr><td>NVIC_IRQChannel</td><td>描述</td></tr><tr><td>WWDG_IRQChannel</td><td>窗口看门狗中断</td></tr><tr><td>PVD_IRQChannel</td><td>PVD 通过EXTI探测中断</td></tr><tr><td>TAMPER_IRQChannel</td><td>篡改中断</td></tr><tr><td>RTC_IRQChannel</td><td>RTC全局中断</td></tr><tr><td>FlashItf_IRQChannel</td><td>FLASH 全局中断</td></tr><tr><td>RCC_IRQChannel</td><td>RCC 全局中断</td></tr><tr><td>EXTI0_IRQChannel</td><td>外部中断线0中断</td></tr><tr><td>EXTI1_IRQChannel</td><td>外部中断线1中断</td></tr><tr><td>EXTI2_IRQChannel</td><td>外部中断线2中断</td></tr><tr><td>EXTI3_IRQChannel</td><td>外部中断线3中断</td></tr><tr><td>EXTI4_IRQChannel</td><td>外部中断线4中断</td></tr><tr><td>DMAChannel1_IRQChannel</td><td>DMA通道1中断</td></tr><tr><td>DMAChannel2_IRQChannel</td><td>DMA通道2中断</td></tr><tr><td>DMAChannel3_IRQChannel</td><td>DMA通道3中断</td></tr><tr><td>DMAChannel4_IRQChannel</td><td>DMA通道4中断</td></tr><tr><td>DMAChannel5_IRQChannel</td><td>DMA通道5中断</td></tr><tr><td>DMAChannel6_IRQChannel</td><td>DMA通道6中断</td></tr><tr><td>DMAChannel7_IRQChannel</td><td>DMA通道7中断</td></tr><tr><td>ADC_IRQChannel</td><td>ADC全局中断</td></tr><tr><td>USB_HP_CANTX_IRQChannel</td><td>USB 高优先级或者CAN发送中断</td></tr><tr><td>USB_LP_CAN_RX0_IRQChannel</td><td>USB低优先级或者CAN接收0中断</td></tr><tr><td>CAN_RX1_IRQChannel</td><td>CAN 接收1中断</td></tr><tr><td>CAN_SCE_IRQChannel</td><td>CAN SCE中断</td></tr></table>

NVIC  

<table><tr><td>EXTI9_5_IRQChannel</td><td>外部中断线 9-5 中断</td></tr><tr><td>TIM1_BRK_IRQChannel</td><td>TIM1 暂停中断</td></tr><tr><td>TIM1_UP_IRQChannel</td><td>TIM1 刷新中断</td></tr><tr><td>TIM1_TRG_COM_IRQChannel</td><td>TIM1 触发和通讯中断</td></tr><tr><td>TIM1_CC_IRQChannel</td><td>TIM1 捕获比较中断</td></tr><tr><td>TIM2_IRQChannel</td><td>TIM2 全局中断</td></tr><tr><td>TIM3_IRQChannel</td><td>TIM3 全局中断</td></tr><tr><td>TIM4_IRQChannel</td><td>TIM4 全局中断</td></tr><tr><td>I2C1_ER_IRQChannel</td><td>I2C1 事件中断</td></tr><tr><td>I2C1_ER_IRQChannel</td><td>I2C1 错误中断</td></tr><tr><td>I2C2_ER_IRQChannel</td><td>I2C2 事件中断</td></tr><tr><td>I2C2_ER_IRQChannel</td><td>I2C2 错误中断</td></tr><tr><td>SPI1_IRQChannel</td><td>SPI1 全局中断</td></tr><tr><td>SPI2_IRQChannel</td><td>SPI2 全局中断</td></tr><tr><td>USART1_IRQChannel</td><td>USART1 全局中断</td></tr><tr><td>USART2_IRQChannel</td><td>USART2 全局中断</td></tr><tr><td>USART3_IRQChannel</td><td>USART3 全局中断</td></tr><tr><td>EXTI15_10_IRQChannel</td><td>外部中断线 15-10 中断</td></tr><tr><td>RTCA Alarm_IRQChannel</td><td>RTC 闹钟通过 EXTI 线中断</td></tr><tr><td>USBWakeUp_IRQChannel</td><td>USB 通过 EXTI 线从悬挂唤醒中断</td></tr></table>

# NVIC_IRQChannelPreemptionPriority

该参数设置了成员NVIC_IRQChannel中的先占优先级，Table.273列举了该参数的取值。

# NVIC_IRQChannelSubPriority

该参数设置了成员NVIC_IRQChannel中的从优先级，Table.273列举了该参数的取值。

Table. 273 给出了由函数 NVIC_PriorityGroupConfig 设置的先占优先级和从优先级可取的值  
Table 273. 先占优先级和从优先级值 (1) (2)  

<table><tr><td>NVIC_PriorityGroup</td><td>NVIC_IRQChannel的先占优先级</td><td>NVIC_IRQChannel的从优先级</td><td>描述</td></tr><tr><td>NVIC_PriorityGroup_0</td><td>0</td><td>0-15</td><td>先占优先级0位从优先级4位</td></tr><tr><td>NVIC_PriorityGroup_1</td><td>0-1</td><td>0-7</td><td>先占优先级1位从优先级3位</td></tr><tr><td>NVIC_PriorityGroup_2</td><td>0-3</td><td>0-3</td><td>先占优先级2位从优先级2位</td></tr><tr><td>NVIC_PriorityGroup_3</td><td>0-7</td><td>0-1</td><td>先占优先级3位从优先级1位</td></tr><tr><td>NVIC_PriorityGroup_4</td><td>0-15</td><td>0</td><td>先占优先级4位从优先级0位</td></tr></table>

1. 选中NVIC_PriorityGroup_0, 则参数NVIC_IRQChannelPreemptionPriority对中断通道的设置不产生影响。  
2. 选中NVIC_PriorityGroup_4，则参数NVIC_IRQChannelSubPriority对中断通道的设置不产生影响。

# NVIC_IRQChannelCmd

该参数指定了在成员NVIC_IRQChannel中定义的IRQ通道被使能还是失能。这个参数取值为ENABLE或者 DISABLE。

例：

```c
NVIC_InitTypeDef NVIC_InitStructure;  
/* Configure the Priority Grouping with 1 bit */  
NVICPriorityGroupConfig(NVICPriorityGroup_1);  
/* Enable TIM3 global interrupt with Preemption Priority 0 and Sub Priority as 2 */  
NVIC_InitStructure.NVIC_IRQChannel = TIM3_IRQChannel;  
NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = 0;
```

# ST

译文英文原版为UM0427 Oct. 2007 Rev 2, 译文仅供参考，与英文版冲突的，以英文版为准

NVIC  
```c
NVIC_InitStructure.NVIC_IRQChannelSubPriority = 2;  
NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE;  
NVIC_InitStructure(&NVIC_InitStructure);  
/* EnableUSART1 global interrupt with Preemption Priority 1 and Sub Priority as 5 */  
NVIC_InitStructure.NVIC_IRQChannel = USART1_IRQChannel;  
NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = 1;  
NVIC_InitStructure.NVIC_IRQChannelSubPriority = 5;  
NVIC_InitStructure(&NVIC_InitStructure);  
/* Enable RTC global interrupt with Preemption Priority 1 and Sub Priority as 7 */  
NVIC_InitStructure.NVIC_IRQChannel = RTC_IRQChannel;  
NVIC_InitStructure.NVIC_IRQChannelSubPriority = 7;  
NVIC_InitStructure(&NVIC_InitStructure);  
/* EnableEXTI4 interrupt with Preemption Priority 1 and Sub Priority as 7 */  
NVIC_InitStructure.NVIC_IRQChannel = EXTI4_IRQChannel;  
NVIC_InitStructure.NVIC_IRQChannelSubPriority = 7;  
NVIC_InitStructure(&NVIC_InitStructure);  
/* TIM3 interrupt priority is higher thanUSART1, RTC andEXTI4 interrupts priorities.USART1 interrupt priority is higher than RTC andEXTI4 interrupts priorities. RTC interrupt priority is higher thanEXTI4 interrupt priority. */
```

# 13.2.5 函数NVICSTRUCTInit

Table 274. 描述了函数 NVICSTRUCTInit  
Table 274. 函数 NVICSTRUCTInit  

<table><tr><td>函数名</td><td>NVICSTRUCTInit</td></tr><tr><td>函数原形</td><td>void NVICSTRUCTInit (NVIC_InitTypeDef* NVIC_InitStruct)</td></tr><tr><td>功能描述</td><td>把 NVIC_InitStruct 中的每一个参数按缺省值填入</td></tr><tr><td>输入参数</td><td>NVIC_InitStruct: 指向结构 NVIC_InitTypeDef 的指针, 待初始化</td></tr><tr><td>输出参数</td><td>无</td></tr><tr><td>返回值</td><td>无</td></tr><tr><td>先决条件</td><td>无</td></tr><tr><td>被调用函数</td><td>无</td></tr></table>

Table 275. 给出了NVIC_InitStruct各个成员的缺省值  
Table 275. NVIC_InitStruct 缺省值  

<table><tr><td>成员</td><td>缺省值</td></tr><tr><td>NVIC_IRQChannel</td><td>0x0</td></tr><tr><td>NVIC_IRQChannelPreemptionPriority</td><td>0</td></tr><tr><td>NVIC_IRQChannelSubPriority</td><td>0</td></tr><tr><td>NVIC_IRQChannelCmd</td><td>DISABLE</td></tr></table>

例：

```c
/\* The following example illustrates how to initialize a NVIC_InitTypeDef structure \*/ NVIC_InitTypeDef NVIC_InitStructure; NVICSTRUCTInit(&NVIC_InitStructure);
```

# 13.2.6 函数NVIC_SETPRIMASK

Table 276. 描述了函数 NVIC_SETPRIMASK

Table 276. 函数 NVIC_SETPRIMASK (1) (2) (3)  

<table><tr><td>函数名</td><td>NVIC_SETPRIMASK</td></tr><tr><td>函数原形</td><td>void NVIC_SETPRIMASK(void)</td></tr><tr><td>功能描述</td><td>使能 PRIMASK 优先级：提升执行优先级至0</td></tr><tr><td>输入参数</td><td>无</td></tr><tr><td>输出参数</td><td>无</td></tr><tr><td>返回值</td><td>无</td></tr><tr><td>先决条件</td><td>无</td></tr><tr><td>被调用函数</td><td>__SETPRIMASK()</td></tr></table>

1. 该函数由汇编语言书写。  
2. 该函数只影响组优先级，不影响从优先级。  
3. 在设置PRIMASK寄存器前，建议在从为了使能一个例外中另一个例外返回时，清除该寄存器例：

/\*Enable the PRIMASK priority \*/ NVIC_SETPRIMASK();

# 13.2.7 函数NVIC_RESETPRIMASK

Table 277. 描述了函数 NVIC_RESETPRIMASK  
Table 277. 函数 NVIC_RESETPRIMASK (1)  

<table><tr><td>函数名</td><td>NVIC_Init</td></tr><tr><td>函数原形</td><td>void NVIC_RESETPRIMASK(void)</td></tr><tr><td>功能描述</td><td>失能 PRIMASK 优先级</td></tr><tr><td>输入参数</td><td>无</td></tr><tr><td>输出参数</td><td>无</td></tr><tr><td>返回值</td><td>无</td></tr><tr><td>先决条件</td><td>无</td></tr><tr><td>被调用函数</td><td>__RESETPRIMASK()</td></tr></table>

1. 该函数由汇编语言书写。

例：

/* Disable the PRIMASK priority */
NVIC_RESETPRIMASK();

# 13.2.8 函数NVIC_SETFAULTMASK

Table 278. 描述了函数 NVIC_SETFAULTMASK

Table 278. 函数 NVIC_SETFAULTMASK (1) (2) (3)  

<table><tr><td>函数名</td><td>NVIC_SETFAULTMASK</td></tr><tr><td>函数原形</td><td>void NVIC_SETFAULTMASK(void)</td></tr><tr><td>功能描述</td><td>使能FAULTMASK优先级：提升执行优先级至-1</td></tr><tr><td>输入参数</td><td>无</td></tr><tr><td>输出参数</td><td>无</td></tr><tr><td>返回值</td><td>无</td></tr><tr><td>先决条件</td><td>无</td></tr><tr><td>被调用函数</td><td>__SETFAULTMASK()</td></tr></table>

1. 该函数由汇编语言书写。  
2. 该函数只影响组优先级，不影响从优先级。  
3. FAULTMASK 只有在执行优先级值小于-1的情况下才能被设置，设置 FAULTMASK 将它的执行优先级提升到 HardFAULT 的级别。每当从除 NMI 之外的例外中返回，FAULTMASK 会被自动清除。

例：

/\*Enable theFAULTMASKpriority \*/ NVIC_SETFAULTMASK();

# 13.2.9 函数NVIC_RESETFAULTMASK

Table 279. 描述了函数 NVIC_RESETFAULTMASK

Table 279. 函数 NVIC_RESETFAULTMASK (1)  

<table><tr><td>函数名</td><td>NVIC_RESETFAULTMASK</td></tr><tr><td>函数原形</td><td>void NVIC_RESETFAULTMASK(void)</td></tr><tr><td>功能描述</td><td>失能FAULTMASK优先级</td></tr><tr><td>输入参数</td><td>无</td></tr><tr><td>输出参数</td><td>无</td></tr><tr><td>返回值</td><td>无</td></tr><tr><td>先决条件</td><td>无</td></tr><tr><td>被调用函数</td><td>__RESETFAULTMASK()</td></tr></table>

1. 该函数由汇编语言书写。

例：

/\*Enable the PRIMASK priority \*/ NVIC_RESETPRIMASK();

# 13.2.10 函数NVIC_BASEPRCONFIG

Table 280. 描述了函数 NVIC_BASEPRICONFIG

Table 280. 函数 NVIC_BASEPRICONFIG (1) (2) (3)  

<table><tr><td>函数名</td><td>NVIC_BASEPRCONFIG</td></tr><tr><td>函数原形</td><td>void NVIC_BASEPRCONFIG(u32 NewPriority)</td></tr><tr><td>功能描述</td><td>改变执行优先级从N（最低可设置优先级）提升至1</td></tr><tr><td>输入参数</td><td>NewPriority: 执行优先级的新优先级值</td></tr><tr><td>输出参数</td><td>无</td></tr><tr><td>返回值</td><td>无</td></tr><tr><td>先决条件</td><td>无</td></tr><tr><td>被调用函数</td><td>__BASEPRCONFIG()</td></tr></table>

1. 该函数由汇编语言书写。  
2. 该函数只影响组优先级，不影响从优先级。  
3. 可以改变执行优先级，从N（最低可设置优先级）提升至1。将该寄存器清除至0不会影响当前的优先级，它的非零值起到优先级屏蔽的作用，执行后当BASEPRI定义的优先级高于当前优先级时，该操作将起作用。例：

/\*Mask the execution priority to 10\*/ BASEPRICONFIG(10);

# 13.2.11 函数NVIC_GetBASEPRI

Table 281. 描述了函数 NVIC_GetBASEPRI  
Table 281. 函数 NVIC_GetBASEPRI (1)  

<table><tr><td>函数名</td><td>NVIC_GetBASEPRI</td></tr><tr><td>函数原形</td><td>u32 NVIC_GetBASEPRI(void)</td></tr><tr><td>功能描述</td><td>返回BASEPRI屏蔽值</td></tr><tr><td>输入参数</td><td>无</td></tr><tr><td>输出参数</td><td>无</td></tr><tr><td>返回值</td><td>BASEPRI屏蔽值</td></tr><tr><td>先决条件</td><td>无</td></tr><tr><td>被调用函数</td><td>_GetBASEPRI()</td></tr></table>

1. 该函数由汇编语言书写。

例：

/\*Get the execution priority to value \*/ u32BASEPRI_Mask  $= 0$  BASEPRI_Mask  $=$  NVIC_GetBASEPRI();

# 13.2.12 函数NVIC_GetCurrentPendingIRQChannel

Table 282. 描述了函数 NVIC_GetCurrentPendingIRQChannel

Table 282. 函数 NVIC_GetCurrentPendingIRQChannel  

<table><tr><td>函数名</td><td>NVIC_GetCurrentPendingIRQChannel</td></tr><tr><td>函数原形</td><td>u16 NVIC_GetCurrentPendingIRQChannel(void)</td></tr><tr><td>功能描述</td><td>返回当前待处理 IRQ 标识符</td></tr><tr><td>输入参数</td><td>无</td></tr><tr><td>输出参数</td><td>无</td></tr><tr><td>返回值</td><td>待处理 IRQ 标识符</td></tr><tr><td>先决条件</td><td>无</td></tr><tr><td>被调用函数</td><td>无</td></tr></table>

例：  
/* Get the current pending IRQ channel identifier */  
ul6 CurrentPendingIRQChannel;  
CurrentPendingIRQChannel = NVIC_GetCurrentPendingIRQChannel();

# 13.2.13 函数NVIC_GetIRQChannelPendingBitStatus

Table 283. 描述了函数 NVIC_GetIRQChannelPendingBitStatus

Table 283. 函数 NVIC_GetIRQChannelPendingBitStatus  

<table><tr><td>函数名</td><td>NVIC_GetIRQChannelPendingBitStatus</td></tr><tr><td>函数原形</td><td>ITStatus NVIC_GetIRQChannelPendingBitStatus(u8 NVIC_IRQChannel)</td></tr><tr><td>功能描述</td><td>检查指定的IRQ通道待处理位设置与否</td></tr><tr><td>输入参数</td><td>NVIC_IRQChannel: 待检查的IRQ通道待处理位
参阅 Section: NVIC_IRQChannel 查阅更多该参数允许取值范围</td></tr><tr><td>输出参数</td><td>无</td></tr><tr><td>返回值</td><td>待检查IRQ待处理位的新状态 (SET或者RESET)</td></tr><tr><td>先决条件</td><td>无</td></tr><tr><td>被调用函数</td><td>无</td></tr></table>

例：  
/* Get the IRQ channel pending bit status of the ADC IRQChannel */  
ITStatus IRQChannelPendingBitStatus;  
IRQChannelPendingBitStatus =  
NVIC_GetIRQChannelPendingBitStatus(ADC_IRQChannel);

# 13.2.14 函数NVIC_SetIRQChannelPendingBit

Table 284. 描述了函数 NVIC_SetIRQChannelPendingBit  
Table 284. 函数 NVIC_SetIRQChannelPendingBit  

<table><tr><td>函数名</td><td>NVIC_SetIRQChannelPendingBit</td></tr><tr><td>函数原形</td><td>void NVIC_SetIRQChannelPendingBit(u8 NVIC_IRQChannel)</td></tr><tr><td>功能描述</td><td>设置指定的IRQ通道待处理位</td></tr><tr><td>输入参数</td><td>NVIC_IRQChannel: 待设置的IRQ通道待处理位
参阅 Section: NVIC_IRQChannel 查阅更多该参数允许取值范围</td></tr><tr><td>输出参数</td><td>无</td></tr><tr><td>返回值</td><td>无</td></tr><tr><td>先决条件</td><td>无</td></tr><tr><td>被调用函数</td><td>无</td></tr></table>

例：  
/* Set SPI1 Global interrupt pending bit */
NVIC_SetIRQChannelPendingBit(SPI1_IRQChannel);

# 13.2.15 函数NVIC_ClearIRQChannelPendingBit

Table 285. 描述了函数 NVIC_ClearIRQChannelPendingBit  
Table 285. 函数 NVIC_ClearIRQChannelPendingBit  

<table><tr><td>函数名</td><td>NVIC_ClearIRQChannelPendingBit</td></tr><tr><td>函数原形</td><td>void NVIC_ClearIRQChannelPendingBit(u8 NVIC_IRQChannel)</td></tr><tr><td>功能描述</td><td>清除指定的IRQ通道待处理位</td></tr><tr><td>输入参数</td><td>NVIC_IRQChannel: 待清除的IRQ通道待处理位
参阅 Section: NVIC_IRQChannel 查阅更多该参数允许取值范围</td></tr><tr><td>输出参数</td><td>无</td></tr><tr><td>返回值</td><td>无</td></tr><tr><td>先决条件</td><td>无</td></tr><tr><td>被调用函数</td><td>无</td></tr></table>

例：  
/\* Clear ADC IRQ Channel Pending bit \*/ NVIC_ClearIRQChannelPendingBit(ADC_IRQChannel);

# 13.2.16 函数NVIC_GetCurrentActiveHandler

Table 286. 描述了函数 NVIC_GetCurrentlyHandler

Table 286. 函数 NVIC_GetCurrentActiveHandler  

<table><tr><td>函数名</td><td>NVIC_GetCurrentActiveHandler</td></tr><tr><td>函数原形</td><td>u16 NVIC_GetCurrentActiveHandler(void)</td></tr><tr><td>功能描述</td><td>返回当前活动的Handler（IRQ通道和系统Handler）的标识符</td></tr><tr><td>输入参数</td><td>无</td></tr><tr><td>输出参数</td><td>无</td></tr><tr><td>返回值</td><td>活动 Handler 的标识符</td></tr><tr><td>先决条件</td><td>无</td></tr><tr><td>被调用函数</td><td>无</td></tr></table>

例：
/* Get the current active Handler identifier */
u16 CurrentActiveHandler;
CurrentActiveHandler = NVIC_GetCurrentActiveHandler();

# 13.2.17 函数NVIC_GetIRQChannelActiveBitStatus

Table 287. 描述了函数 NVIC_GetIRQChannelActiveBitStatus

Table 287. 函数 NVIC_GetIRQChannelActiveBitStatus  

<table><tr><td>函数名</td><td>NVIC_GetIRQChannelActiveBitStatus</td></tr><tr><td>函数原形</td><td>ITStatus NVIC_GetIRQChannelActiveBitStatus(u8 NVIC_IRQChannel)</td></tr><tr><td>功能描述</td><td>检查指定的IRQ通道活动位设置与否</td></tr><tr><td>输入参数</td><td>NVIC_IRQChannel: 待检查的指定中断活动位
参阅 Section: NVIC_IRQChannel 查阅更多该参数允许取值范围</td></tr><tr><td>输出参数</td><td>无</td></tr><tr><td>返回值</td><td>指定中断活动位的新状态 (SET 或者 RESET)</td></tr><tr><td>先决条件</td><td>无</td></tr><tr><td>被调用函数</td><td>无</td></tr></table>

例：
/* Get the active IRQ channel status of the ADC_IRQChannel */
ITStatus IRQChannelActiveBitStatus;
IRQChannelActiveBitStatus = NVIC_GetIRQChannelActiveBitStatus(ADC_IRQChannel);

# 13.2.18 函数NVIC_GetCPUID

Table 288. 描述了函数 NVIC_GetCPUID  
Table 288. 函数 NVIC_GetCPUID  

<table><tr><td>函数名</td><td>NVIC_GetCPUID</td></tr><tr><td>函数原形</td><td>u32 NVIC_GetCPUID(void)</td></tr><tr><td>功能描述</td><td>返回ID号码，Cortex-M3内核的版本号和实现细节</td></tr><tr><td>输入参数</td><td>无</td></tr><tr><td>输出参数</td><td>无</td></tr><tr><td>返回值</td><td>CPU ID</td></tr><tr><td>先决条件</td><td>无</td></tr><tr><td>被调用函数</td><td>无</td></tr></table>

```txt
例：
/* Gets the CPU ID */
u32 CM3_CPUID;
CM3_CPUID = NVIC_GetCPUID();
```

# 13.2.19 函数NVIC_SetVectorTable

Table 289. 描述了函数 NVIC_SetVectorTable  
Table 289. 函数 NVIC_SetVectorTable  

<table><tr><td>函数名</td><td>NVIC_SetVectorTable</td></tr><tr><td>函数原形</td><td>void NVIC_SetVectorTable(u32 NVIC_VectTab, u32 Offset)</td></tr><tr><td>功能描述</td><td>设置向量表的位置和偏移</td></tr><tr><td>输入参数1</td><td>NVIC_VectTab: 指定向量表位置在 RAM 还是在程序存储器
参阅 Section: NVIC_VectTab 查阅更多该参数允许取值范围</td></tr><tr><td>输入参数2</td><td>Offset: 向量表基地址的偏移量
对 FLASH, 该参数值必须高于 0x08000100; 对 RAM 必须高于 0x100。它同时必须是 256 (64×4) 的整数倍</td></tr><tr><td>输出参数</td><td>无</td></tr><tr><td>返回值</td><td>指定中断活动位的新状态 (SET 或者 RESET)</td></tr><tr><td>先决条件</td><td>无</td></tr><tr><td>被调用函数</td><td>无</td></tr></table>

# NVIC_VectTab

该参数设置向量表基地址（见Table290.）

Table 290. NVIC_VectTab 值  

<table><tr><td>NVIC_VectTab</td><td>描述</td></tr><tr><td>NVIC_VectTab_FLASH</td><td>向量表位于 FLASH</td></tr><tr><td>NVIC_VectTab_RAM</td><td>向量表位于 RAM</td></tr></table>

例：

```txt
/\* Vector Table is in FLASH at 0x0 \*/ NVIC_SetVectorTable(NVIC_VectTab_FLASH, 0x0);
```

# 13.2.20 函数NVIC_GenerateSystemReset

Table 291. 描述了函数 NVIC_GenerateSystemReset

Table 291. 函数 NVIC_GenerateSystemReset  

<table><tr><td>函数名</td><td>NVIC_GenerateSystemReset</td></tr><tr><td>函数原形</td><td>void NVIC_GenerateSystemReset(void)</td></tr><tr><td>功能描述</td><td>产生一个系统复位</td></tr><tr><td>输入参数</td><td>无</td></tr><tr><td>输出参数</td><td>无</td></tr><tr><td>返回值</td><td>无</td></tr><tr><td>先决条件</td><td>无</td></tr><tr><td>被调用函数</td><td>无</td></tr></table>

例：/\*Generateasystemreset\*/NVIC_GenerateSystemReset();

# 13.2.21 函数NVICGenerateCoreReset

Table 292. 描述了函数 NVICGenerateCoreReset  
Table 292. 函数 NVICGenerateCoreReset  

<table><tr><td>函数名</td><td>NVICGenerateCoreReset</td></tr><tr><td>函数原形</td><td>void NVICGenerateCoreReset(void)</td></tr><tr><td>功能描述</td><td>产生一个内核（内核+NVIC）复位</td></tr><tr><td>输入参数</td><td>无</td></tr><tr><td>输出参数</td><td>无</td></tr><tr><td>返回值</td><td>无</td></tr><tr><td>先决条件</td><td>无</td></tr><tr><td>被调用函数</td><td>无</td></tr></table>

例：/\*Generateacorereset\*/NVIC_GenerateCoreReset();

# 13.2.22 函数NVIC_SystemLPCfg

Table 293. 描述了函数 NVIC_SystemLPCfg

Table 293. 函数 NVIC_SystemLPCfg  

<table><tr><td>函数名</td><td>NVIC_SystemLPConfig</td></tr><tr><td>函数原形</td><td>void NVIC_SystemLPConfig(u8 LowPowerMode, FunctionalState NewState)</td></tr><tr><td>功能描述</td><td>选择系统进入低功耗模式的条件</td></tr><tr><td>输入参数1</td><td>LowPowerMode: 系统进入低功耗模式的新模式
参阅 Section: LowPowerMode 查阅更多该参数允许取值范围</td></tr><tr><td>输入参数2</td><td>NewState: LP条件的新状态
这个参数可以取: ENABLE 或者 DISABLE</td></tr><tr><td>输出参数</td><td>无</td></tr><tr><td>返回值</td><td>无</td></tr><tr><td>先决条件</td><td>无</td></tr><tr><td>被调用函数</td><td>无</td></tr></table>

# LowPowerMode

该参数设置了设备的低功耗模式（见Table294.）

Table 294. LowPowerMode 值  

<table><tr><td>LowPowerMode</td><td>描述</td></tr><tr><td>NVIC_LP_SEVONPEND</td><td>根据待处理请求唤醒</td></tr><tr><td>NVIC_LP_SLEEPDEEP</td><td>深度睡眠使能</td></tr><tr><td>NVIC_LP_SLEEPONEXIT</td><td>退出ISR后睡眠</td></tr></table>

例：  
/* wakeup the system on interrupt pending */  
NVIC_SystemLPConfig(SEVONPEND, ENABLE);

# 13.2.23 函数NVIC_SystemHandlerConfig

Table 295. 描述了函数 NVIC_SystemHandlerConfig

Table 295. 函数 NVIC_SystemHandlerConfig  

<table><tr><td>函数名</td><td>NVIC_SystemHandlerConfig</td></tr><tr><td>函数原形</td><td>void NVIC_SystemHandlerConfig(u32 SystemHandler, FunctionalState NewState)</td></tr><tr><td>功能描述</td><td>使能或者失能指定的系统 Handler</td></tr><tr><td>输入参数1</td><td>SystemHandler: 待使能或者失能指定的系统 Handler
参阅 Section: LowPowerMode 查阅更多该参数允许取值范围</td></tr><tr><td>输入参数2</td><td>NewState: 指定系统 Handler 的新状态
这个参数可以取: ENABLE 或者 DISABLE</td></tr><tr><td>输出参数</td><td>无</td></tr><tr><td>返回值</td><td>无</td></tr><tr><td>先决条件</td><td>无</td></tr><tr><td>被调用函数</td><td>无</td></tr></table>

# SystemHandler

该参数设置了待使能或者失能指定的系统Handler（见Table296.）

Table 296. SystemHandler 值  

<table><tr><td>SystemHandler</td><td>描述</td></tr><tr><td>SystemHandler_MemoryManage</td><td>存储器管理 Handler</td></tr><tr><td>SystemHandler_BusFault</td><td>总线错误 Handler</td></tr><tr><td>SystemHandler_UsageFault</td><td>使用错误 Handler</td></tr></table>

该参数允许同时设置NVIC寄存器，SCB寄存器和索引位。SystemHandler有23位编码长度，详情参阅Table 297.-Table.306

例：

/\*Enable theMemory Manage Handler \*/ NVIC_SystemHandlerConfig(SystemHandler_MemoryManage，ENABLE);

Table 297. SystemHandler 定义  

<table><tr><td rowspan="2">System Handler</td><td colspan="20">Bits</td><td>Value</td><td></td><td></td><td rowspan="2"></td></tr><tr><td>22</td><td>21</td><td>20</td><td>19</td><td>18</td><td>17</td><td>16</td><td>15</td><td>14</td><td>13</td><td>12</td><td>11</td><td>10</td><td>9</td><td>8</td><td>7</td><td>6</td><td>5</td><td>4</td><td>3</td><td>2</td><td>1</td><td>0</td></tr><tr><td>SystemHandler_NMI (see Table 298)</td><td colspan="18">Reserved</td><td colspan="4">0x1F</td><td>0x1F</td><td></td></tr><tr><td>SystemHandler_HardFault (seeTable 299)</td><td colspan="3">Reserved</td><td colspan="2">0</td><td colspan="17">Reserved</td><td>0x0</td><td></td></tr><tr><td>SystemHandler_MemoryManage(see Table 300)</td><td>0</td><td colspan="2">0</td><td colspan="2">1</td><td colspan="4">0x0</td><td colspan="3">0xD</td><td colspan="2">0</td><td colspan="2">0</td><td>Res</td><td colspan="4">0x10</td><td>0x43430</td><td></td><td></td></tr><tr><td>SystemHandler_BusFault (seeTable 301)</td><td>1</td><td colspan="2">1</td><td colspan="2">1</td><td colspan="4">1</td><td colspan="3">0xE</td><td colspan="2">1</td><td colspan="2">0</td><td>Res</td><td colspan="4">0x11</td><td>0x547931</td><td></td><td></td></tr><tr><td>SystemHandler_UsageFault (seeTable 302)</td><td>-</td><td colspan="2">2</td><td colspan="2">1</td><td colspan="4">0x3</td><td colspan="3">Reserved</td><td colspan="2">2</td><td colspan="2">0</td><td>Res</td><td colspan="4">0x12</td><td>0x24C232</td><td></td><td></td></tr><tr><td>SystemHandler_SVCall (seeTable 303)</td><td colspan="5">Reserved</td><td colspan="4">0x7</td><td colspan="3">0xF</td><td colspan="2">3</td><td colspan="2">1</td><td colspan="5">Reserved</td><td>0x1FF40</td><td></td><td></td></tr><tr><td>SystemHandler_DebugMonitor (seeTable 304)</td><td colspan="3">Reserved</td><td colspan="2">2</td><td colspan="4">0x8</td><td colspan="3">Reserved</td><td colspan="2">0</td><td colspan="2">2</td><td colspan="5">Reserved</td><td>0xA0080</td><td></td><td></td></tr><tr><td>SystemHandler_PSV (see Table 305)</td><td colspan="5">Reserved</td><td colspan="4">0xA</td><td colspan="3">Reserved</td><td colspan="2">2</td><td colspan="2">2</td><td></td><td colspan="4">0x1C</td><td>0x2829C</td><td></td><td></td></tr><tr><td>SystemHandler_SysTick (seeTable 306)</td><td colspan="5">Reserved</td><td colspan="4">0xB</td><td colspan="3">Reserved</td><td colspan="2">3</td><td colspan="2">2</td><td></td><td colspan="4">0x1A</td><td>0x2C39A</td><td></td><td></td></tr></table>

Table 298. SystemHandler_NMI 定义  

<table><tr><td rowspan="2">Bits</td><td colspan="2">NMI</td></tr><tr><td>Registers/Bits</td><td>Functions</td></tr><tr><td>[4:0]</td><td>- IRQControlState
- NMIPENDSET[31]</td><td>NVIC_SetSystemHandlerPendingBit</td></tr><tr><td>5</td><td colspan="2">Not Used</td></tr><tr><td>[7:6]</td><td colspan="2">Not Used</td></tr><tr><td>[9:8]</td><td colspan="2">Not Used</td></tr><tr><td>[13:10]</td><td colspan="2">Not Used</td></tr><tr><td>[17:14]</td><td colspan="2">Not Used</td></tr><tr><td>[19:18]</td><td colspan="2">Not Used</td></tr><tr><td>[21:20]</td><td colspan="2">Not Used</td></tr><tr><td>22</td><td colspan="2">Not Used</td></tr></table>

Table 299. SystemHandler_HardFault 定义  

<table><tr><td rowspan="2">Bits</td><td colspan="2">Hard Fault</td></tr><tr><td>Registers/Bits</td><td>Functions</td></tr><tr><td>[4:0]</td><td colspan="2">Not Used</td></tr><tr><td>5</td><td colspan="2">Not Used</td></tr><tr><td>[7:6]</td><td colspan="2">Not Used</td></tr><tr><td>[9:8]</td><td colspan="2">Not Used</td></tr><tr><td>[13:10]</td><td colspan="2">Not Used</td></tr><tr><td>[17:14]</td><td colspan="2">Not Used</td></tr><tr><td>[19:18]</td><td rowspan="2">- HardFaultStatus</td><td rowspan="2">NVIC_GetFaultHandlerSources</td></tr><tr><td>[21:20]</td></tr><tr><td>22</td><td colspan="2">Not Used</td></tr></table>

Table 300. SystemHandler_MemoryManage 定义  

<table><tr><td rowspan="2">Bits</td><td colspan="2">Memory Manage</td></tr><tr><td>Registers/Bits</td><td>Functions</td></tr><tr><td>[4:0]</td><td>- SysHandlerCtrl
- MEMFAULTENA[16]</td><td>NVIC_SystemHandlerConfig</td></tr><tr><td>5</td><td colspan="2">Not Used</td></tr><tr><td>[7:6]</td><td rowspan="2">- SystemPriority[0]
- PRI_4[7:0]</td><td rowspan="2">NVIC_SystemHandlerPriorityConfig</td></tr><tr><td>[9:8]</td></tr><tr><td>[13:10]</td><td>- SysHandlerCtrl
- MEMFAULTPENDED[13]</td><td>NVIC_GetSystemHandlerPendingBitStatus</td></tr><tr><td>[17:14]</td><td>- SysHandlerCtrl
- MEMFAULTACT[0]</td><td>NVIC_GetSystemHandlerActiveBitStatus</td></tr><tr><td>[19:18]</td><td rowspan="2">- ConfigFaultStatus
- [7:0]</td><td rowspan="2">NVIC_GetFaultHandlerSources</td></tr><tr><td>[21:20]</td></tr><tr><td>22</td><td>- MemoryManageFaultAddr</td><td>NVIC_GetFaultAddress</td></tr></table>

Table 301. SystemHandler_BusFault 定义  

<table><tr><td rowspan="2">Bits</td><td colspan="2">Bus Fault</td></tr><tr><td>Registers/Bits</td><td>Functions</td></tr><tr><td>[4:0]</td><td>- SysHandlerCtrl - BUSFAULTENA[17]</td><td>NVIC_SystemHandlerConfig</td></tr><tr><td>5</td><td colspan="2">Not Used</td></tr><tr><td>[7:6]</td><td rowspan="2">- SystemPriority[0] - PRI_5[15:8]</td><td rowspan="2">NVIC_SystemHandlerPriorityConfig</td></tr><tr><td>[9:8]</td></tr><tr><td>[13:10]</td><td>- SysHandlerCtrl - BUSFAULTPENDED[14]</td><td>NVIC_GetSystemHandlerPendingBitStatus</td></tr><tr><td>[17:14]</td><td>- SysHandlerCtrl - BUSFAULTTACT[1]</td><td>NVIC_GetSystemHandlerActiveBitStatus</td></tr><tr><td>[19:18]</td><td rowspan="2">- ConfigFaultStatus - [15:8]</td><td rowspan="2">NVIC_GetFaultHandlerSources</td></tr><tr><td>[21:20]</td></tr><tr><td>22</td><td>- BusFaultAddr</td><td>NVIC_GetFaultAddress</td></tr></table>

Table 302. SystemHandler_UseageFault 定义  

<table><tr><td rowspan="2">Bits</td><td colspan="2">Usage Fault</td></tr><tr><td>Registers/Bits</td><td>Functions</td></tr><tr><td rowspan="2">[4:0]</td><td>- SysHandlerCtrl</td><td rowspan="2">NVIC_SystemHandlerConfig</td></tr><tr><td>- USGFAULTENA[18]</td></tr><tr><td>5</td><td colspan="2">Not Used</td></tr><tr><td>[7:6]</td><td>- SystemPriority[0]</td><td rowspan="2">NVIC_SystemHandlerPriorityConfig</td></tr><tr><td>[9:8]</td><td>- PRI_6[23:16]</td></tr><tr><td>[13:10]</td><td colspan="2">Not Used</td></tr><tr><td rowspan="2">[17:14]</td><td>- SysHandlerCtrl</td><td rowspan="2">NVIC_GetSystemHandlerActiveBitStatus</td></tr><tr><td>- USGFAULTACT[3]</td></tr><tr><td>[19:18]</td><td>- ConfigFaultStatus</td><td rowspan="2">NVIC_GetFaultHandlerSources</td></tr><tr><td>[21:20]</td><td>- [31:16]</td></tr><tr><td>22</td><td colspan="2">Not Used</td></tr></table>

Table 303. SystemHandler_SVCall 定义  

<table><tr><td rowspan="2">Bits</td><td colspan="2">SVCall</td></tr><tr><td>Registers/Bits</td><td>Functions</td></tr><tr><td>[4:0]</td><td colspan="2">Not Used</td></tr><tr><td>5</td><td colspan="2">Not Used</td></tr><tr><td>[7:6]</td><td>- SystemPriority[1]</td><td rowspan="2">NVIC_SystemHandlerPriorityConfig</td></tr><tr><td>[9:8]</td><td>- PRI_11[31:24]</td></tr><tr><td rowspan="2">[13:10]</td><td>- SysHandlerCtrl</td><td rowspan="2">NVIC_GetSystemHandlerPendingBitStatus</td></tr><tr><td>- SVCALLPENDED[15]</td></tr><tr><td rowspan="2">[17:14]</td><td>- SysHandlerCtrl</td><td rowspan="2">NVIC_GetSystemHandlerActiveBitStatus</td></tr><tr><td>- SVCALLACT[7]</td></tr><tr><td>[19:18]</td><td colspan="2">Not Used</td></tr><tr><td>[21:20]</td><td colspan="2">Not Used</td></tr><tr><td>22</td><td colspan="2">Not Used</td></tr></table>

Table 304. SystemHandler_DisgMonitor 定义  

<table><tr><td rowspan="2">Bits</td><td colspan="2">Debug Monitor</td></tr><tr><td>Registers/Bits</td><td>Functions</td></tr><tr><td>[4:0]</td><td></td><td>Not Used</td></tr><tr><td>5</td><td></td><td>Not Used</td></tr><tr><td>[7:6]</td><td>- SystemPriority[2]</td><td rowspan="2">NVIC_SystemHandlerPriorityConfig</td></tr><tr><td>[9:8]</td><td>- PRI_12[7:0]</td></tr><tr><td>[13:10]</td><td></td><td>Not Used</td></tr><tr><td rowspan="2">[17:14]</td><td>- SysHandlerCtrl</td><td rowspan="2">NVIC_GetSystemHandlerActiveBitStatus</td></tr><tr><td>- MONITORACT[8]</td></tr><tr><td>[19:18]</td><td>- DebugFaultStatus</td><td>NVIC_GetFaultHandlerSources</td></tr><tr><td>[21:20]</td><td></td><td></td></tr><tr><td>22</td><td></td><td>Not Used</td></tr></table>

Table 305. SystemHandler_PSV 定义  

<table><tr><td rowspan="2">Bits</td><td colspan="2">PSV</td></tr><tr><td>Registers/Bits</td><td>Functions</td></tr><tr><td rowspan="2">[4:0]</td><td>- IRQControlState-PENDSVSET[28]</td><td>NVIC_SetSystemHandlerPendingBit</td></tr><tr><td>- IRQControlState-PENDSVCLR[27]</td><td>NVIC_ClearSystemHandlerPendingBit</td></tr><tr><td>5</td><td colspan="2">Not Used</td></tr><tr><td>[7:6]</td><td rowspan="2">- SystemPriority[2]- PRI_14[23:16]</td><td rowspan="2">NVIC_SystemHandlerPriorityConfig</td></tr><tr><td>[9:8]</td></tr><tr><td>[13:10]</td><td colspan="2">Not Used</td></tr><tr><td>[17:14]</td><td>- SysHandlerCtrl-PENDSVACT[10]</td><td>NVIC_GetSystemHandlerActiveBitStatus</td></tr><tr><td>[19:18]</td><td colspan="2">Not Used</td></tr><tr><td>[21:20]</td><td colspan="2">Not Used</td></tr><tr><td>22</td><td colspan="2">Not Used</td></tr></table>

Table 306. SystemHandler_Systick 定义  

<table><tr><td rowspan="2">Bits</td><td colspan="2">SysTick</td></tr><tr><td>Registers/Bits</td><td>Functions</td></tr><tr><td rowspan="2">[4:0]</td><td>- IRQControlState-PENDSTSET[26]</td><td>NVIC_SetSystemHandlerPendingBit</td></tr><tr><td>- IRQControlState-PENDSVCLR[25]</td><td>NVIC_ClearSystemHandlerPendingBit</td></tr><tr><td>5</td><td colspan="2">Not Used</td></tr><tr><td>[7:6]</td><td rowspan="2">- SystemPriority[2]- PRI_15[31:24]</td><td rowspan="2">NVIC_SystemHandlerPriorityConfig</td></tr><tr><td>[9:8]</td></tr><tr><td>[13:10]</td><td colspan="2">Not Used</td></tr><tr><td>[17:14]</td><td>- SysHandlerCtrl-SYSTICKACT[11]</td><td>NVIC_GetSystemHandlerActiveBitStatus</td></tr><tr><td>[19:18]</td><td colspan="2">Not Used</td></tr><tr><td>[21:20]</td><td colspan="2">Not Used</td></tr><tr><td>22</td><td colspan="2">Not Used</td></tr></table>

# 13.2.24 函数NVIC_SystemHandlerPriorityConfig

Table 307. 描述了函数 NVIC_SystemHandlerPriorityConfig

Table 307. 函数 NVIC_SystemHandlerPriorityConfig  

<table><tr><td>函数名</td><td>NVIC_SystemHandlerPriorityConfig</td></tr><tr><td>函数原形</td><td>void NVIC_SystemHandlerPriorityConfig(u32 SystemHandler, u8 SystemHandlerPreemptionPriority, u8 SystemHandlerSubPriority)</td></tr><tr><td>功能描述</td><td>设置指定的系统Handler优先级</td></tr><tr><td>输入参数1</td><td>SystemHandler: 待使能或者失能的指定系统Handler参阅 Section: SystemHandler 查阅更多该参数允许取值范围</td></tr><tr><td>输入参数2</td><td>SystemHandlerPreemptionPriority: 指定系统Handler的新组优先级参阅 Section: SystemHandlerPreemptionPriority 查阅更多该参数允许取值范围</td></tr><tr><td>输入参数3</td><td>SystemHandlerSubPriority: 指定系统Handler的新从优先级参阅 Section: SystemHandlerSubPriority 查阅更多该参数允许取值范围</td></tr><tr><td>输出参数</td><td>无</td></tr><tr><td>返回值</td><td>无</td></tr><tr><td>先决条件</td><td>无</td></tr><tr><td>被调用函数</td><td>无</td></tr></table>

# SystemHandler

该参数指定了待设置的系统Handler（见Table308.）

Table 308. SystemHandler 类型  

<table><tr><td>NVIC_VectTab</td><td>描述</td></tr><tr><td>SystemHandlerMemoryManage</td><td>存储器管理 Handler</td></tr><tr><td>SystemHandler_BusFault</td><td>总线错误 Handler</td></tr><tr><td>SystemHandler_UsageFault</td><td>使用错误 Handler</td></tr><tr><td>SystemHandler_SVCall</td><td>SVCall Handler</td></tr><tr><td>SystemHandler_DisbugMonitor</td><td>除错监控 Handler</td></tr><tr><td>SystemHandler_PSV</td><td>PSV Handler</td></tr><tr><td>SystemHandler_SysTick</td><td>系统滴答定时器 Handler</td></tr></table>

例：

/* Enable the Memory Manage Handler */

NVIC_SystemHandlerPriorityConfig(SystemHandler_MemoryManage, 2, 8);

# 13.2.25 函数NVIC_GetSystemHandlerPendingBitStatus

Table 309. 描述了函数 NVIC_GetSystemHandlerPendingBitStatus

Table 309. 函数 NVIC_GetSystemHandlerPendingBitStatus  

<table><tr><td>函数名</td><td>NVIC_GetSystemHandlerPendingBitStatus</td></tr><tr><td>函数原形</td><td>ITStatus NVIC_GetSystemHandlerPendingBitStatus(u32 SystemHandler)</td></tr><tr><td>功能描述</td><td>检查指定的系统 Handler 待处理位设置与否</td></tr><tr><td>输入参数</td><td>SystemHandler: 待使能或者失能的指定系统 Handler
参阅 Section: SystemHandler 查阅更多该参数允许取值范围</td></tr><tr><td>输出参数</td><td>无</td></tr><tr><td>返回值</td><td>系统 Handler 待处理位的新状态 (SET 或者 RESET)</td></tr><tr><td>先决条件</td><td>无</td></tr><tr><td>被调用函数</td><td>无</td></tr></table>

# SystemHandler

该参数指定系统Handler（见Table310.）

Table 310. SystemHandler 类型  

<table><tr><td>NVIC_VectTab</td><td>描述</td></tr><tr><td>SystemHandlerMemoryManage</td><td>存储器管理 Handler</td></tr><tr><td>SystemHandler_BusFault</td><td>总线错误 Handler</td></tr><tr><td>SystemHandler_SVCall</td><td>SVCall Handler</td></tr></table>

例：

```c
/\* Check if the Memory Manage Fault has occured \*/   
ITStatus MemoryHandlerStatus;   
MemoryHandlerStatus   
=NVIC_GetSystemHandlerPendingBitStatus(SystemHandler_MemoryManage);
```

# 13.2.26 函数NVIC_SetSystemHandlerPendingBit

Table 311. 描述了函数 NVIC_SetSystemHandlerPendingBit

Table 311. 函数 NVIC_SetSystemHandlerPendingBit  

<table><tr><td>函数名</td><td>NVIC_SetSystemHandlerPendingBit</td></tr><tr><td>函数原形</td><td>void NVIC_SetSystemHandlerPendingBit(u32 SystemHandler)</td></tr><tr><td>功能描述</td><td>设置系统 Handler 待处理位</td></tr><tr><td>输入参数</td><td>SystemHandler: 待设置的指定系统 Handler 待处理位
参阅 Section: SystemHandler 查阅更多该参数允许取值范围</td></tr><tr><td>输出参数</td><td>无</td></tr><tr><td>返回值</td><td>无</td></tr><tr><td>先决条件</td><td>无</td></tr><tr><td>被调用函数</td><td>无</td></tr></table>

# SystemHandler

该参数指定系统Handler（见Table312.）

Table 312. SystemHandler 类型  

<table><tr><td>NVIC_VectTab</td><td>描述</td></tr><tr><td>SystemHandler_NMI</td><td>NMI Handler</td></tr><tr><td>SystemHandler_PSV</td><td>PSV Handler</td></tr><tr><td>SystemHandler_SysTick</td><td>系统滴答定时器 Handler</td></tr></table>

例：  
/* Set NMI Pending Bit */  
NVIC_SetSystemHandlerPendingBit(SystemHandler_NMI);

# 13.2.27 函数NVIC_ClearSystemHandlerPendingBit

Table 313. 描述了函数 NVIC_ClearSystemHandlerPendingBit  
Table 313. 函数 NVIC_ClearSystemHandlerPendingBit  

<table><tr><td>函数名</td><td>NVIC_ClearSystemHandlerPendingBit</td></tr><tr><td>函数原形</td><td>void NVIC_ClearSystemHandlerPendingBit(u32 SystemHandler)</td></tr><tr><td>功能描述</td><td>清除系统 Handler 待处理位</td></tr><tr><td>输入参数</td><td>SystemHandler: 待清除的指定系统 Handlerr 待处理位
参阅 Section: SystemHandler 查阅更多该参数允许取值范围</td></tr><tr><td>输出参数</td><td>无</td></tr><tr><td>返回值</td><td>无</td></tr><tr><td>先决条件</td><td>无</td></tr><tr><td>被调用函数</td><td>无</td></tr></table>

# SystemHandler

该参数指定系统Handler（见Table314.）

Table 314. SystemHandler 类型  

<table><tr><td>NVIC_VectTab</td><td>描述</td></tr><tr><td>SystemHandler_PSV</td><td>PSV Handler</td></tr><tr><td>SystemHandler_SysTick</td><td>系统滴答定时器 Handler</td></tr></table>

例：  
/* Clear SysTick Pending Bit */  
NVIC_ClearSystemHandlerPendingBit(SystemHandler_SysTick);

# 13.2.28 函数NVIC_GetSystemHandlerActiveBitStatus

Table 315. 描述了函数 NVIC_GetSystemHandlerActiveBitStatus  
Table 315. 函数 NVIC_GetSystemHandlerActiveBitStatus  

<table><tr><td>函数名</td><td>NVIC_GetSystemHandlerActiveBitStatus</td></tr><tr><td>函数原形</td><td>ITStatus NVIC_GetSystemHandlerActiveBitStatus(u32 SystemHandler)</td></tr><tr><td>功能描述</td><td>检查系统 Handler 活动位设置与否</td></tr><tr><td>输入参数</td><td>SystemHandler: 待检查的系统 Handler 活动位
参阅 Section: SystemHandler 查阅更多该参数允许取值范围</td></tr><tr><td>输出参数</td><td>无</td></tr><tr><td>返回值</td><td>系统 Handler 活动位的新状态 (SET 或者 RESET)</td></tr><tr><td>先决条件</td><td>无</td></tr><tr><td>被调用函数</td><td>无</td></tr></table>

# SystemHandler

该参数指定系统Handler（见Table316.）

Table 316. SystemHandler 类型  

<table><tr><td>NVIC_VectTab</td><td>描述</td></tr><tr><td>SystemHandler_MemoryManage</td><td>存储器管理 Handler</td></tr><tr><td>SystemHandler_BusFault</td><td>总线错误 Handler</td></tr><tr><td>SystemHandler_UsgaFault</td><td>使用错误 Handler</td></tr><tr><td>SystemHandler_DepMonitor</td><td>除错监控 Handler</td></tr><tr><td>SystemHandler_PSV</td><td>PSV Handler</td></tr><tr><td>SystemHandler_SysTick</td><td>系统滴答定时器 Handler</td></tr></table>

例：  
/\* Check if the Bus Fault is active or stacked \*/   
ITStatus BusFaultHandlerStatus;   
BusFaultHandlerStatus  $=$    
NVIC_GetSystemHandlerActiveBitStatus(SystemHandler_BusFault);

# 13.2.29 函数NVIC_GetFaultHandlerSources

Table 317. 描述了函数 NVIC_GetFaultHandlerSources

Table 317. 函数 NVIC_GetFaultHandlerSources  

<table><tr><td>函数名</td><td>NVIC_GetFaultHandlerSources</td></tr><tr><td>函数原形</td><td>u32 NVIC_GetFaultHandlerSources(u32 SystemHandler)</td></tr><tr><td>功能描述</td><td>返回表示出错的系统 Handler 源</td></tr><tr><td>输入参数</td><td>SystemHandler: 待返回表示出错的系统 Handler 源
参阅 Section: SystemHandler 查阅更多该参数允许取值范围</td></tr><tr><td>输出参数</td><td>无</td></tr><tr><td>返回值</td><td>表示出错的系统 Handler 源</td></tr><tr><td>先决条件</td><td>无</td></tr><tr><td>被调用函数</td><td>无</td></tr></table>

# SystemHandler

该参数指定系统Handler（见Table318.）

Table 318. SystemHandler 类型  

<table><tr><td>NVIC_VectTab</td><td>描述</td></tr><tr><td>SystemHandler_HardFault</td><td>硬件错误 Handler</td></tr><tr><td>SystemHandler_MemoryManage</td><td>存储器管理 Handler</td></tr><tr><td>SystemHandler_BusFault</td><td>总线错误 Handler</td></tr><tr><td>SystemHandler_UsageFault</td><td>使用错误 Handler</td></tr><tr><td>SystemHandler_DDebugMonitor</td><td>除错监控 Handler</td></tr></table>

例：  
/\*Gets the sources of the Bus Fault Handler \*/ u32 BusFaultHandlerSource; BusFaultHandlerSource =NVIC_GetFaultHandlerSources(SystemHandler_BusFault);

# 13.2.30 函数NVIC_GetFaultAddress

Table 319. 描述了函数 NVIC_GetFaultAddress  
Table 319. 函数 NVIC_GetFaultAddress  

<table><tr><td>函数名</td><td>NVIC_GetFaultAddress</td></tr><tr><td>函数原形</td><td>u32 NVIC_GetFaultAddress(u32 SystemHandler)</td></tr><tr><td>功能描述</td><td>返回产生表示出错的系统 Handler所在位置的地址</td></tr><tr><td>输入参数</td><td>SystemHandler: 待返回产生表示出错的系统 Handler所在位置的地址
参阅 Section: SystemHandler 查阅更多该参数允许取值范围</td></tr><tr><td>输出参数</td><td>无</td></tr><tr><td>返回值</td><td>表示出错的系统 Handler所在位置的地址</td></tr><tr><td>先决条件</td><td>无</td></tr><tr><td>被调用函数</td><td>无</td></tr></table>

# SystemHandler

该参数指定系统Handler（见Table320.）

Table 320. SystemHandler 类型  

<table><tr><td>NVIC_VectTab</td><td>描述</td></tr><tr><td>SystemHandlerMemoryManage</td><td>存储器管理 Handler</td></tr><tr><td>SystemHandler_BusFault</td><td>总线错误 Handler</td></tr></table>

例：

/\* Gets the address of the Bus Fault Handler \*/ u32 BusFaultHandlerAddress;

BusFaultHandlerAddress =

NVIC_GetFaultAddress(SystemHandler_BusFault);

# 14 功耗控制（PWR）

PWR有多种用途，包括功耗管理和低功耗模式选择。

Section 14.1 PWR 寄存器结构描述了固件函数库所使用的数据结构，Section 14.2 固件库函数介绍了函数库里的所有函数。

# 14.1 PWR寄存器结构

PWR 寄存器结构，PWR_TypeDeff，在文件“stm32f10x_map.h”中定义如下：

```c
typedef struct  
{  
vu32 CR;  
vu32 CSR;  
} PWR_TYPEDef;
```

Table 321.例举了PWR所有寄存器

Table 321. PWR 寄存器  

<table><tr><td>寄存器</td><td>描述</td></tr><tr><td>CR</td><td>功耗控制寄存器</td></tr><tr><td>CSR</td><td>功耗控制状态寄存器</td></tr></table>

PWR外设声明于文件“stm32f10x_map.h”：

```c
define PERIPH_BASE((u32)0x40000000)
#define APB1PERIPH_BASE PERIPH_BASE
#define APB2PERIPH_BASE (PERIPH_BASE + 0x10000)
#define AHBPERIPH_BASE (PERIPH_BASE + 0x20000)
#define PWR_BASE (APB1PERIPH_BASE + 0x7000)
#ifndef DEBUG
...
ifdef_PWR
#define PWR ((PWRTypeDef *) PWR_BASE)
endif /*_PWR */
...
else /* DEBUG */
...
ifdef_PWR
EXT PWRTypeDef *PWR;
endif /*_PWR */
...
endif
使用Debug模式时，初始化指针PWR于文件“stm32f10x_lib.c”:
#ifdef_PWR
PWR = (PWRTypeDef *) PWR_BASE;
#endif /*_PWR */
为了访问PWR寄存器，_,_PWR必须在文件“stm32f10x_conf.h”中定义如下:
#define _PWR
```

# 14.2 PWR库函数

Table 322. 例举了PWR的库函数  
Table 322. PWR 库函数  

<table><tr><td>函数名</td><td>描述</td></tr><tr><td>PWR_DeInit</td><td>将外设PWR寄存器重设为缺省值</td></tr><tr><td>PWR_BackupAccessCmd</td><td>使能或者失能RTC和后备寄存器访问</td></tr><tr><td>PWR_PVDCmd</td><td>使能或者失能可编程电压探测器（PVD）</td></tr><tr><td>PWR_PVDLevelConfig</td><td>设置PVD的探测电压阈值</td></tr><tr><td>PWR_WakeUpPinCmd</td><td>使能或者失能唤醒管脚功能</td></tr><tr><td>PWR_EnterSTOPMode</td><td>进入停止（STOP）模式</td></tr><tr><td>PWR_EnterSTANDBYMode</td><td>进入待命（STANDBY）模式</td></tr><tr><td>PWR_GetFlagStatus</td><td>检查指定PWR标志位设置与否</td></tr><tr><td>PWR_ClearFlag</td><td>清除PWR的待处理标志位</td></tr></table>

# 14.2.1 函数PWR_DeInit

Table 323. 描述了函数 PWR_DeInit  
Table 323. 函数 PWR_DeInit  

<table><tr><td>函数名</td><td>PWR_DeInit</td></tr><tr><td>函数原形</td><td>void PWR_DeInit(void)</td></tr><tr><td>功能描述</td><td>将外设 I2Cx 寄存器重设为缺省值</td></tr><tr><td>输入参数</td><td>无</td></tr><tr><td>输出参数</td><td>无</td></tr><tr><td>返回值</td><td>无</td></tr><tr><td>先决条件</td><td>无</td></tr><tr><td>被调用函数</td><td>RCC_APBIPeriphClockCmd().</td></tr></table>

例：/\*Deinitialize the PWR registers \*/PWR_DeInit();

# 14.2.2 函数PWR_BackupAccessCmd

Table 324. 描述了函数 PWR_BackupAccessCmd  
Table 324. 函数 PWR_BackupAccessCmd  

<table><tr><td>函数名</td><td>PWR_BackupAccessCmd</td></tr><tr><td>函数原形</td><td>void PWR_BackupAccessCmd(FunctionalState NewState)</td></tr><tr><td>功能描述</td><td>使能或者失能 RTC 和后备寄存器访问</td></tr><tr><td>输入参数</td><td>NewState: RTC 和后备寄存器访问的新状态
这个参数可以取: ENABLE 或者 DISABLE</td></tr><tr><td>输出参数</td><td>无</td></tr><tr><td>返回值</td><td>无</td></tr><tr><td>先决条件</td><td>无</td></tr><tr><td>被调用函数</td><td>无</td></tr></table>

例：  
/\* Enable access to the RTC and backup registers \*/ PWR_BackupAccessCmd(ENABLE);

# 14.2.3 函数PWR_PVDCmd

Table 325. 描述了函数 PWR_PVDCmd  
Table 325. 函数 PWR_PVDCmd  

<table><tr><td>函数名</td><td>PWR_PVDCmd</td></tr><tr><td>函数原形</td><td>void PWR_PVDCmd(FunctionalState NewState)</td></tr><tr><td>功能描述</td><td>使能或者失能可编程电压探测器（PVD）</td></tr><tr><td>输入参数</td><td>NewState: PVD 的新状态
这个参数可以取：ENABLE 或者 DISABLE</td></tr><tr><td>输出参数</td><td>无</td></tr><tr><td>返回值</td><td>无</td></tr><tr><td>先决条件</td><td>无</td></tr><tr><td>被调用函数</td><td>无</td></tr></table>

例：  
/* Enable the Power Voltage Detector(PVD) */
PWR_PVDCmd(ENABLE);

# 14.2.4 函数PWR_PVDLevelConfig

Table 326. 描述了 PWR_PVDLevelConfig  
Table 326. 函数 PWR_PVDLevelConfig  

<table><tr><td>函数名</td><td>PWR_PVDLevelConfig</td></tr><tr><td>函数原形</td><td>void PWR_PVDLevelConfig(u32 PWR_PVDLevel)</td></tr><tr><td>功能描述</td><td>设置PVD的探测电压阈值</td></tr><tr><td>输入参数</td><td>PWR_PVDLevel: PVD的探测电压阈值
参阅Section:PWR_PVDLevel 查阅更多该参数允许取值范围</td></tr><tr><td>输出参数</td><td>无</td></tr><tr><td>返回值</td><td>无</td></tr><tr><td>先决条件</td><td>无</td></tr><tr><td>被调用函数</td><td>无</td></tr></table>

# PWR_PVDLevel

该参数设置了PVD的探测电压阈值（见Table327.）

Table 327. PWR_PVDLevel 值  

<table><tr><td>PWR_PVDLevel</td><td>描述</td></tr><tr><td>PWR_PVDLevel_2V2</td><td>PVD探测电压阈值2.2V</td></tr><tr><td>PWR_PVDLevel_2V3</td><td>PVD探测电压阈值2.3V</td></tr><tr><td>PWR_PVDLevel_2V4</td><td>PVD探测电压阈值2.4V</td></tr><tr><td>PWR_PVDLevel_2V5</td><td>PVD探测电压阈值2.5V</td></tr><tr><td>PWR_PVDLevel_2V6</td><td>PVD探测电压阈值2.6V</td></tr><tr><td>PWR_PVDLevel_2V7</td><td>PVD探测电压阈值2.7V</td></tr><tr><td>PWR_PVDLevel_2V8</td><td>PVD探测电压阈值2.8V</td></tr><tr><td>PWR_PVDLevel_2V9</td><td>PVD探测电压阈值2.9V</td></tr></table>

例：  
/* Set PVD detection level to 2.5V */  
PWR_PVDLevelConfig(PWR_PVDLevel_2V5);

# 14.2.5 函数PWR_WakeUpPinCmd

Table 328. 描述了函数 PWR_WakeUpPinCmd  
Table 328. 函数 PWR_WakeUpPinCmd  

<table><tr><td>函数名</td><td>PWR_WakeUpPinCmd</td></tr><tr><td>函数原形</td><td>void PWR_WakeUpPinCmd(FunctionalState NewState)</td></tr><tr><td>功能描述</td><td>使能或者失能唤醒管脚功能</td></tr><tr><td>输入参数</td><td>NewState: 唤醒管脚功能的新状态
这个参数可以取: ENABLE 或者 DISABLE</td></tr><tr><td>输出参数</td><td>无</td></tr><tr><td>返回值</td><td>无</td></tr><tr><td>先决条件</td><td>无</td></tr><tr><td>被调用函数</td><td>无</td></tr></table>

例：
/* WakeUp pin used for wake-up function */
PWR_WakeUpPinCmd(ENABLE);

# 14.2.6 函数PWR_EnterSTOPMode

Table 329. 描述了函数 PWR_EnterSTOPMode

Table 329. 函数 PWR_EnterSTOPMode  

<table><tr><td>函数名</td><td>PWR_EnterSTOPMode</td></tr><tr><td>函数原形</td><td>void PWR_EnterSTOPMode(u32 PWR_Regulator, u8 PWR_STOPEntry)</td></tr><tr><td>功能描述</td><td>进入停止（STOP）模式</td></tr><tr><td>输入参数1</td><td>PWR_Regulator: 电压转换器在停止模式下的状态
参阅 Section: PWR_Regulator 查阅更多该参数允许取值范围</td></tr><tr><td>输入参数2</td><td>PWR_STOPEntry: 选择使用指令 WFE 还是 WFI 来进入停止模式
参阅 Section: PWR_STOPEntry 查阅更多该参数允许取值范围</td></tr><tr><td>输出参数</td><td>无</td></tr><tr><td>返回值</td><td>无</td></tr><tr><td>先决条件</td><td>无</td></tr><tr><td>被调用函数</td><td>__WFI(), __WFE()</td></tr></table>

# PWR_Regulator

该参数设置了电压转换器在停止模式下的状态（见Table330.)

Table 330. PWR_Regulator 值  

<table><tr><td>PWR_Regulator</td><td>描述</td></tr><tr><td>PWR_Regulator_ON</td><td>停止模式下电压转换器 ON</td></tr><tr><td>PWR_Regulator_LowPower</td><td>停止模式下电压转换器进入低功耗模式</td></tr></table>

# PWR_STOPEntry

该参数选择使用指令WFE还是WFI来进入停止模式（见Table331.)

Table 331. PWR_Regulator 值  

<table><tr><td>PWR_STOPEntry</td><td>描述</td></tr><tr><td>PWR_STOPEntry_WFI</td><td>使用指令 WFI 来进入停止模式</td></tr><tr><td>PWR_STOPEntry_WFE</td><td>使用指令 WFE 来进入停止模式</td></tr></table>

例：

```txt
/\*Put the system in STOP mode with regulator on \*/ PWR_EnterSTOPMode(PWR_Regulator_ON，PWR_STOPEntry_WFE);
```

# 14.2.7 函数PWR_EnterSTANDBYMode

Table 332. 描述了函数 PWR_EnterSTANDBYMode

Table 332. 函数 PWR_EnterSTANDBYMode  

<table><tr><td>函数名</td><td>PWR_EnterSTANDBYMode</td></tr><tr><td>函数原形</td><td>void PWR_EnterSTANDBYMode(void)</td></tr><tr><td>功能描述</td><td>进入待命（STANDBY）模式</td></tr><tr><td>输入参数</td><td>无</td></tr><tr><td>输出参数</td><td>无</td></tr><tr><td>返回值</td><td>无</td></tr><tr><td>先决条件</td><td>无</td></tr><tr><td>被调用函数</td><td>__WFI(),</td></tr></table>

例：

```txt
/* Put the system in STANDBY mode */
```

```txt
PWR_EnterSTANDBYMode();
```

# 14.2.8 函数PWR_GetFlagStatus

Table 333. 描述了函数PWR_GetFlagStatus

Table 333. 函数 PWR_GetFlagStatus  

<table><tr><td>函数名</td><td>PWR_GetFlagStatus</td></tr><tr><td>函数原形</td><td>FlagStatus PWR_GetFlagStatus(u32 PWR_FLAG)</td></tr><tr><td>功能描述</td><td>检查指定 PWR 标志位设置与否</td></tr><tr><td>输入参数</td><td>PWR_FLAG: 待检查的 PWR 标志位
参阅 Section: PWR_FLAG 查阅更多该参数允许取值范围</td></tr><tr><td>输出参数</td><td>无</td></tr><tr><td>返回值</td><td>PWR_FLAG 的新状态 (SET 或者 RESET)</td></tr><tr><td>先决条件</td><td>无</td></tr><tr><td>被调用函数</td><td>无</td></tr></table>

# PWR_FLAG

Table 334. 给出了所有可以被函数PWR_GetFlagStatus检查的标志位列表

Table 334. PWR_FLAG 值  

<table><tr><td>PWR_FLAG</td><td>描述</td></tr><tr><td>PWR_FLAG_WU</td><td>唤醒标志位</td></tr><tr><td>PWR_FLAG_SB</td><td>待命（Standby）标志位</td></tr><tr><td>PWR_FLAG_PVDO</td><td>PVD 输出(1)</td></tr></table>

1. 该标志位为只读，不能被清除

例：

```lisp
/\*Testif the StandBy flag is set or not \*/ FlagStatus Status;   
Status  $=$  PWR_GetFlagStatus(PWR_FLAG_SB); if(Status  $= =$  RESET)   
{   
}   
else   
{   
}
```

# 14.2.9 函数PWR_ClearFlag

Table 335. 描述了函数PWR_ClearFlag  
Table 335. 函数 PWR_ClearFlag  

<table><tr><td>函数名</td><td>PWR_ClearFlag</td></tr><tr><td>函数原形</td><td>void PWR_ClearFlag(u32 PWR_FLAG)</td></tr><tr><td>功能描述</td><td>清除PWR的待处理标志位</td></tr><tr><td>输入参数</td><td>PWR_FLAG: 待清除的PWR待处理标志位
参阅Section:PWR_FLAG 查阅更多该参数允许取值范围</td></tr><tr><td>输出参数</td><td>无</td></tr><tr><td>返回值</td><td>无</td></tr><tr><td>先决条件</td><td>无</td></tr><tr><td>被调用函数</td><td>无</td></tr></table>

例：

```txt
/\*Clear the StandBy pending flag \*/ PWR_ClearFlag(PWR_FLAG_SB);
```

# ST

译文英文原版为UM0427 Oct. 2007 Rev 2, 译文仅供参考，与英文版冲突的，以英文版为准

# 15 复位和时钟设置（RCC）

RCC 有多种用途，包括时钟设置，外设复位和时钟管理。

Section 15.1 RCC 寄存器结构描述了固件函数库所使用的数据结构，Section 15.2 固件库函数介绍了函数库里的所有函数。

# 15.1 RCC寄存器结构

RCC 寄存器结构，RCC_TYPEDeff，在文件“stm32f10x_map.h”中定义如下：

```c
typedef struct  
{  
vu32 CR;  
vu32 CFGR;  
vu32 CIR;  
vu32 APB2RSTR;  
vu32 APB1RSTR;  
vu32 AHBENR;  
vu32 APB2ENR;  
vu32 APB1ENR;  
vu32 BDCR;  
vu32 CSR;  
} RCC_TYPEDef;
```

Table 336.例举了RCC所有寄存器

Table 336. RCC 寄存器  

<table><tr><td>寄存器</td><td>描述</td></tr><tr><td>CR</td><td>时钟控制寄存器</td></tr><tr><td>CFGR</td><td>时钟配置寄存器</td></tr><tr><td>CIR</td><td>时钟中断寄存器</td></tr><tr><td>APB2RSTR</td><td>APB2 外设复位寄存器</td></tr><tr><td>APB1RSTR</td><td>APB1 外设复位寄存器</td></tr><tr><td>AHBENR</td><td>AHB 外设时钟使能寄存器</td></tr><tr><td>APB2ENR</td><td>APB2 外设时钟使能寄存器</td></tr><tr><td>APB1ENR</td><td>APB1 外设时钟使能寄存器</td></tr><tr><td>BDCR</td><td>备份域控制寄存器</td></tr><tr><td>CSR</td><td>控制/状态寄存器</td></tr></table>

RCC外设声明于文件“stm32f10x_map.h”：

```c
define PERIPH_BASE((u32)0x40000000)
#define APB1PERIPH_BASE PERIPH_BASE
#define APB2PERIPH_BASE (PERIPH_BASE + 0x10000)
#define AHBPERIPH_BASE (PERIPH_BASE + 0x20000)
#define RCC_BASE (AHBPERIPH_BASE + 0x1000)
#ifndef DEBUG
...
#ifdef_RCC
#define RCC ((RCC_TYPEDef *) RCC_BASE)
#endif /*_RCC */
...
#else /* DEBUG */
...
#ifdef_RCC
EXT RCC_TYPEDef *RCC;
#endif /*_RCC */
...
#endif
```

ST

译文英文原版为UM0427 Oct. 2007 Rev 2, 译文仅供参考，与英文版冲突的，以英文版为准

使用Debug模式时，初始化指针RCC于文件“stm32f10x_lib.c”：

ifdef RCC

RCC = (RCCTypeDef *) RCC_BASE; #endif /* RCC */

为了访问RCC寄存器，_RCC必须在文件“stm32f10x_conf.h”中定义如下：

define _RCC

# 15.2 RCC库函数

Table 337. 例举了RCC的库函数  
Table 337. RCC 库函数  

<table><tr><td>函数名</td><td>描述</td></tr><tr><td>RCC_DeInit</td><td>将外设RCC寄存器重设为缺省值</td></tr><tr><td>RCC_HSECConfig</td><td>设置外部高速晶振（HSE）</td></tr><tr><td>RCC_WaitForHSEStartUp</td><td>等待HSE起振</td></tr><tr><td>RCC_AdjustHSICalibrationValue</td><td>调整内部高速晶振（HSI）校准值</td></tr><tr><td>RCC_HSICmd</td><td>使能或者失能内部高速晶振（HSI）</td></tr><tr><td>RCC_PLLConfig</td><td>设置PLL时钟源及倍频系数</td></tr><tr><td>RCC_PLLCmd</td><td>使能或者失能PLL</td></tr><tr><td>RCC_SYSCLKConfig</td><td>设置系统时钟（SYSCLK）</td></tr><tr><td>RCC_GetSYSCLKSource</td><td>返回用作系统时钟的时钟源</td></tr><tr><td>RCC_HCLKConfig</td><td>设置AHB时钟（HCLK）</td></tr><tr><td>RCC_PCLK1Config</td><td>设置低速AHB时钟（PCLK1）</td></tr><tr><td>RCC_PCLK2Config</td><td>设置高速AHB时钟（PCLK2）</td></tr><tr><td>RCC_ITConfig</td><td>使能或者失能指定的RCC中断</td></tr><tr><td>RCC_USBCLKConfig</td><td>设置USB时钟（USBCLK）</td></tr><tr><td>RCC_ADCCLKConfig</td><td>设置ADC时钟（ADCCLK）</td></tr><tr><td>RCC_LSEConfig</td><td>设置外部低速晶振（LSE）</td></tr><tr><td>RCC_LSICmd</td><td>使能或者失能内部低速晶振（LSI）</td></tr><tr><td>RCC_RTCCLKConfig</td><td>设置RTC时钟（RTCCLK）</td></tr><tr><td>RCC_RTCCLKCmd</td><td>使能或者失能RTC时钟</td></tr><tr><td>RCC_GetClocksFreq</td><td>返回不同片上时钟的频率</td></tr><tr><td>RCC_AHBPeriphClockCmd</td><td>使能或者失能AHB外设时钟</td></tr><tr><td>RCC_APB2PeriphClockCmd</td><td>使能或者失能APB2外设时钟</td></tr><tr><td>RCC_APB1PeriphClockCmd</td><td>使能或者失能APB1外设时钟</td></tr><tr><td>RCC_APB2PeriphResetCmd</td><td>强制或者释放高速APB（APB2）外设复位</td></tr><tr><td>RCC_APB1PeriphResetCmd</td><td>强制或者释放低速APB（APB1）外设复位</td></tr><tr><td>RCC_BackupResetCmd</td><td>强制或者释放后备域复位</td></tr><tr><td>RCC_ClockSecuritySystemCmd</td><td>使能或者失能时钟安全系统</td></tr><tr><td>RCC_MCOConfig</td><td>选择在MCO管脚上输出的时钟源</td></tr><tr><td>RCC_GetFlagStatus</td><td>检查指定的RCC标志位设置与否</td></tr><tr><td>RCC_ClearFlag</td><td>清除RCC的复位标志位</td></tr><tr><td>RCC_GetITStatus</td><td>检查指定的RCC中断发生与否</td></tr><tr><td>RCC_ClearITPendingBit</td><td>清除RCC的中断待处理位</td></tr></table>

# 15.2.1 函数RCC_DeInit

Table 338. 描述了函数 RCC_DeInit  
Table 338. 函数 RCC_DeInit(1)(2)  

<table><tr><td>函数名</td><td>RCC_DeInit</td></tr><tr><td>函数原形</td><td>void RCC_DeInit(void)</td></tr><tr><td>功能描述</td><td>将外设 RCC 寄存器重设为缺省值</td></tr><tr><td>输入参数</td><td>无</td></tr><tr><td>输出参数</td><td>无</td></tr><tr><td>返回值</td><td>无</td></tr><tr><td>先决条件</td><td>无</td></tr><tr><td>被调用函数</td><td>无</td></tr></table>

1. 该函数不改动寄存器 RCC_CR 的 HSITRIM[4:0]位。  
2. 该函数不重置寄存器 RCC_BDCR 和寄存器 RCC_CSR。

例：

/* Deinitialize the RCC registers */

RCC_DeInit();

# 15.2.2 函数RCC_HSEConfig

Table 339. 描述了函数RCC_HSEConfig  
Table 339. 函数 RCC_HSEConfig  

<table><tr><td>函数名</td><td>RCC_HSEConfig</td></tr><tr><td>函数原形</td><td>void RCC_HSEConfig(u32 RCC_HSE)</td></tr><tr><td>功能描述</td><td>设置外部高速晶振（HSE）</td></tr><tr><td>输入参数</td><td>RCC_HSE: HSE 的新状态
参阅 Section: RCC_HSE 查阅更多该参数允许取值范围</td></tr><tr><td>输出参数</td><td>无</td></tr><tr><td>返回值</td><td>无</td></tr><tr><td>先决条件</td><td>如果 HSE 被直接或者通过 PLL 用于系统时钟，那么它不能被停振</td></tr><tr><td>被调用函数</td><td>无</td></tr></table>

# RCC_HSE

该参数设置了HSE的状态（见Table340.）。

Table 340. RCC_HSE 定义  

<table><tr><td>RCC_HSE</td><td>描述</td></tr><tr><td>RCC_HSE_OFF</td><td>HSE 晶振 OFF</td></tr><tr><td>RCC_HSE_ON</td><td>HSE 晶振 ON</td></tr><tr><td>RCC_HSE_Bypass</td><td>HSE 晶振被外部时钟旁路</td></tr></table>

例：

/* Enable the HSE */

RCC_HSEConfig(RCC_HSE_ON);

# 15.2.3 函数RCC_WaitForHSEStartUp

Table 341. 描述了函数 RCC_WaitForHSEStartUp  
Table 341. 函数 RCC_WaitForHSEStartUp  

<table><tr><td>函数名</td><td>RCC_WaitForHSEStartUp</td></tr><tr><td>函数原形</td><td>ErrorStatus RCC_WaitForHSEStartUp(void)</td></tr><tr><td>功能描述</td><td>等待HSE起振
该函数将等待直到HSE就绪，或者在超时的情况下退出</td></tr><tr><td>输入参数</td><td>无</td></tr><tr><td>输出参数</td><td>无</td></tr><tr><td>返回值</td><td>一个 ErrorStatus 枚举值：
SUCCEED: HSE 晶振稳定且就绪
ERROR: HSE 晶振未就绪</td></tr><tr><td>先决条件</td><td>无</td></tr><tr><td>被调用函数</td><td>无</td></tr></table>

```c
例：  
ErrorStatus HSEStartUpStatus;  
/* Enable HSE */  
RCC_HSECConfig(RCC_HSE_ON);  
/* Wait till HSE is ready and if Time out is reached exit */  
HSEStartUpStatus = RCC_WaitForHSEStartUp();  
if (HSEStartUpStatus == SUCCESS)  
{  
/* Add here PLL ans system clock config */  
}  
else  
{  
/* Add here some code to deal with this error */  
}
```

# 15.2.4 函数RCC_AdjustHSICalibrationValue

Table 342. 描述了函数 RCC_AdjustHSICalibrationValue  
Table 342. 函数 RCC_AdjustHSICalibrationValue  

<table><tr><td>函数名</td><td>RCC_AdjustHSICalibrationValue</td></tr><tr><td>函数原形</td><td>void RCC_AdjustHSICalibrationValue(u8 HSICalibrationValue)</td></tr><tr><td>功能描述</td><td>调整内部高速晶振（HSI）校准值</td></tr><tr><td>输入参数</td><td>HSICalibrationValue: 校准补偿值
该参数取值必须在0到0x1F之间</td></tr><tr><td>输出参数</td><td>无</td></tr><tr><td>返回值</td><td>无</td></tr><tr><td>先决条件</td><td>无</td></tr><tr><td>被调用函数</td><td>无</td></tr></table>

```c
例：  
/* Set HSI calibration value to c0x1F (maximum) */  
RCC_AdjustHSICalibrationValue(0x1F);
```

# 15.2.5 函数RCC_HSICmd

Table 343. 描述了函数 RCC_HSICmd  
Table 343. 函数 RCC_HSICmd  

<table><tr><td>函数名</td><td>RCC_HSICmd</td></tr><tr><td>函数原形</td><td>void RCC_HSICmd(FunctionalState NewState)</td></tr><tr><td>功能描述</td><td>使能或者失能内部高速晶振（HSI）</td></tr><tr><td>输入参数</td><td>NewState: HSI 新状态
这个参数可以取: ENABLE 或者 DISABLE</td></tr><tr><td>输出参数</td><td>无</td></tr><tr><td>返回值</td><td>无</td></tr><tr><td>先决条件</td><td>如果 HSI 被直接或者通过 PLL 用于系统时钟，或者 FLASH 编写操作进行中，那么它不能被停振</td></tr><tr><td>被调用函数</td><td>无</td></tr></table>

例：  
/\* Enable Internal High Speed oscillator \*/ RCC_HSICmd(ENABLE);

# 15.2.6 函数RCC_PLLConfig

Table 344. 描述了函数 RCC_PLLConfig  
Table 344. 函数 RCC_PLLConfig  

<table><tr><td>函数名</td><td>RCC_PLLConfig</td></tr><tr><td>函数原形</td><td>void RCC_PLLConfig(u32 RCC_PLLSource, u32 RCC_PLLMul)</td></tr><tr><td>功能描述</td><td>设置PLL时钟源及倍频系数</td></tr><tr><td>输入参数1</td><td>RCC_PLLSource: PLL的输入时钟源
参阅Section: RCC_PLLSource 查阅更多该参数允许取值范围</td></tr><tr><td>输入参数2</td><td>RCC_PLLMul: PLL倍频系数
参阅Section: RCC_PLLMul 查阅更多该参数允许取值范围</td></tr><tr><td>输出参数</td><td>无</td></tr><tr><td>返回值</td><td>无</td></tr><tr><td>先决条件</td><td>无</td></tr><tr><td>被调用函数</td><td>无</td></tr></table>

# RCC_PLLSource

RCC_PLLSource 用以设置 PLL 的输入时钟源。Table 345. 给出了该参数可取的值

Table 345. RCC_PLLSource 值  

<table><tr><td>RCC_PLLSource</td><td>描述</td></tr><tr><td>RCC_PLLSource_HSI_Div2</td><td>PLL的输入时钟 = HSI时钟频率除以2</td></tr><tr><td>RCC_PLLSource_HSE_Div1</td><td>PLL的输入时钟 = HSE时钟频率</td></tr><tr><td>RCC_PLLSource_HSE_Div2</td><td>PLL的输入时钟 = HSE时钟频率除以2</td></tr></table>

# RCC_PLLMul

该参数用以设置PLL的倍频系数。Table346.给出了该参数可取的值

Table 346. RCC_PLLMul 值  

<table><tr><td>RCC_PLLMul</td><td>描述</td></tr><tr><td>RCC_PLLMul_2</td><td>PLL输入时钟 x 2</td></tr><tr><td>RCC_PLLMul_3</td><td>PLL输入时钟 x 3</td></tr><tr><td>RCC_PLLMul_4</td><td>PLL输入时钟 x 4</td></tr><tr><td>RCC_PLLMul_5</td><td>PLL输入时钟 x 5</td></tr><tr><td>RCC_PLLMul_6</td><td>PLL输入时钟 x 6</td></tr><tr><td>RCC_PLLMul_7</td><td>PLL输入时钟 x 7</td></tr><tr><td>RCC_PLLMul_8</td><td>PLL输入时钟 x 8</td></tr><tr><td>RCC_PLLMul_9</td><td>PLL输入时钟 x 9</td></tr><tr><td>RCC_PLLMul_10</td><td>PLL输入时钟 x 10</td></tr><tr><td>RCC_PLLMul_11</td><td>PLL输入时钟 x 11</td></tr><tr><td>RCC_PLLMul_12</td><td>PLL输入时钟 x 12</td></tr><tr><td>RCC_PLLMul_13</td><td>PLL输入时钟 x 13</td></tr><tr><td>RCC_PLLMul_14</td><td>PLL输入时钟 x 14</td></tr><tr><td>RCC_PLLMul_15</td><td>PLL输入时钟 x 15</td></tr><tr><td>RCC_PLLMul_16</td><td>PLL输入时钟 x 16</td></tr></table>

警告：必须正确设置软件，使PLL输出时钟频率不超过72MHz

例：

```txt
/\* Set PLL clock output to 72MHz using HSE (8MHz) as entry clock \*/ RCC_PLLConfig(RCC_PLLSource_HSE_Div1, RCC_PLLMul_9);
```

# 15.2.7 函数RCC_PLLCmd

Table 347. 描述了函数 RCC_PLLCmd  
Table 347. 函数 RCC_PLLCmd  

<table><tr><td>函数名</td><td>RCC_PLLCmd</td></tr><tr><td>函数原形</td><td>void RCC_PLLCmd(FunctionalState NewState)</td></tr><tr><td>功能描述</td><td>使能或者失能 PLL</td></tr><tr><td>输入参数</td><td>NewState: PLL 新状态
这个参数可以取: ENABLE 或者 DISABLE</td></tr><tr><td>输出参数</td><td>无</td></tr><tr><td>返回值</td><td>无</td></tr><tr><td>先决条件</td><td>如果 PLL 被用于系统时钟, , 那么它不能被失能</td></tr><tr><td>被调用函数</td><td>无</td></tr></table>

例：

```txt
/\*Enable the PLL \*/ RCC_PLLCmd(ENABLE);
```

# 15.2.8 函数RCC_SYSCLKConfig

Table 348. 描述了函数RCC_SYSCLKConfig  
Table 348. 函数 RCC_SYSCLKConfig  

<table><tr><td>函数名</td><td>RCC_SYSCLKConfig</td></tr><tr><td>函数原形</td><td>void RCC_SYSCLKConfig(u32 RCC_SYSCLKSource)</td></tr><tr><td>功能描述</td><td>设置系统时钟（SYSCLK）</td></tr><tr><td>输入参数</td><td>RCC_SYSCLKSource: 用作系统时钟的时钟源
参阅 Section: RCC_SYSCLKSource 查阅更多该参数允许取值范围</td></tr><tr><td>输出参数</td><td>无</td></tr><tr><td>返回值</td><td>无</td></tr><tr><td>先决条件</td><td>无</td></tr><tr><td>被调用函数</td><td>无</td></tr></table>

# RCC_SYSCLKSource

该参数设置了系统时钟（见Table349）。

Table 349. RCC_SYSCLKSource 值  

<table><tr><td>RCC_SYSCLKSource</td><td>描述</td></tr><tr><td>RCC_SYSCLKSource_HSI</td><td>选择HSI作为系统时钟</td></tr><tr><td>RCC_SYSCLKSource_HSE</td><td>选择HSE作为系统时钟</td></tr><tr><td>RCC_SYSCLKSource_PLLCLK</td><td>选择PLL作为系统时钟</td></tr></table>

例：

/\* Select the PLL as system clock source \*/

RCC_SYSCLKConfig(RCC_SYSCLKSource_PLLCLK);

# 15.2.9 函数RCC_GetSYSCLKSource

Table 350. 描述了函数 RCC_GetSYSCLKSource  
Table 350. 函数 RCC GetSYCLKSource  

<table><tr><td>函数名</td><td>RCC_GetSYSCLKSource</td></tr><tr><td>函数原形</td><td>u8 RCC_GetSYSCLKSource(void)</td></tr><tr><td>功能描述</td><td>返回用作系统时钟的时钟源</td></tr><tr><td>输入参数</td><td>无</td></tr><tr><td>输出参数</td><td>无</td></tr><tr><td>返回值</td><td>用作系统时钟的时钟源:0x00: HSI 作为系统时钟0x04: HSE 作为系统时钟0x08: PLL 作为系统时钟</td></tr><tr><td>先决条件</td><td>无</td></tr><tr><td>被调用函数</td><td>无</td></tr></table>

例：

```txt
/\*TestifHSEisusedasysstemclock\*/ if(RCC_GetSYSCLKKSource()！  $= 0x04$  1   
}   
else   
{
```

# 15.2.10 函数RCC_HCLKConfig

Table 351. 描述了函数RCC_HCLKConfig  
Table 351. 函数 RCC_HCLKConfig  

<table><tr><td>函数名</td><td>RCC_HCLKConfig</td></tr><tr><td>函数原形</td><td>void RCC_HCLKConfig(u32 RCC_HCLK)</td></tr><tr><td>功能描述</td><td>设置AHB时钟（HCLK）</td></tr><tr><td>输入参数</td><td>RCC_HCLK: 定义HCLK, 该时钟源自系统时钟 (SYSCLK)
参阅 Section: RCC_HCLK 查阅更多该参数允许取值范围</td></tr><tr><td>输出参数</td><td>无</td></tr><tr><td>返回值</td><td>无</td></tr><tr><td>先决条件</td><td>无</td></tr><tr><td>被调用函数</td><td>无</td></tr></table>

# RCC_HCLK

该参数设置了AHB时钟，Table352.给出了该参数可取的值。

Table 352. RCC_HCLK 值  

<table><tr><td>RCC_HCLK</td><td>描述</td></tr><tr><td>RCC_SYSCLK_Div1</td><td>AHB时钟 = 系统时钟</td></tr><tr><td>RCC_SYSCLK_Div2</td><td>AHB时钟 = 系统时钟 / 2</td></tr><tr><td>RCC_SYSCLK_Div4</td><td>AHB时钟 = 系统时钟 / 4</td></tr><tr><td>RCC_SYSCLK_Div8</td><td>AHB时钟 = 系统时钟 / 8</td></tr><tr><td>RCC_SYSCLK_Div16</td><td>AHB时钟 = 系统时钟 / 16</td></tr><tr><td>RCC_SYSCLK_Div64</td><td>AHB时钟 = 系统时钟 / 64</td></tr><tr><td>RCC_SYSCLK_Div128</td><td>AHB时钟 = 系统时钟 / 128</td></tr><tr><td>RCC_SYSCLK_Div256</td><td>AHB时钟 = 系统时钟 / 256</td></tr><tr><td>RCC_SYSCLK_Div512</td><td>AHB时钟 = 系统时钟 / 512</td></tr></table>

例：

```txt
/\* Configure HCLK such as HCLK  $=$  SYSCLK \*/ RCC_HCLKConfig(RCC_SYSCLK_Div1);
```

# 15.2.11 函数RCC_PCLK1Config

Table 353. 描述了函数RCC_PCLK1Config  
Table 353. 函数 RCC_PCLK1Config  

<table><tr><td>函数名</td><td>RCC_PCLK1Config</td></tr><tr><td>函数原形</td><td>void RCC_PCLK1Config(u32 RCC_PCLK1)</td></tr><tr><td>功能描述</td><td>设置低速AHB时钟(PCLK1)</td></tr><tr><td>输入参数</td><td>RCC_PCLK1: 定义PCLK1, 该时钟源自AHB时钟(HCLK)
参阅Section: RCC_PCLK1 查阅更多该参数允许取值范围</td></tr><tr><td>输出参数</td><td>无</td></tr><tr><td>返回值</td><td>无</td></tr><tr><td>先决条件</td><td>无</td></tr><tr><td>被调用函数</td><td>无</td></tr></table>

# RCC PCLK1

该参数设置了低速AHB时钟（PCLK1），Table 354. 给出了该参数可取的值。

# ST

译文英文原版为UM0427 Oct. 2007 Rev 2, 译文仅供参考，与英文版冲突的，以英文版为准

Table 354. RCC_PCLK1值  

<table><tr><td>RCC_PCLK1</td><td>描述</td></tr><tr><td>RCC_HCLK_Div1</td><td>APB1时钟 = HCLK</td></tr><tr><td>RCC_HCLK_Div2</td><td>APB1时钟 = HCLK / 2</td></tr><tr><td>RCC_HCLK_Div4</td><td>APB1时钟 = HCLK / 4</td></tr><tr><td>RCC_HCLK_Div8</td><td>APB1时钟 = HCLK / 8</td></tr><tr><td>RCC_HCLK_Div16</td><td>APB1时钟 = HCLK / 16</td></tr></table>

例：  
/* Configure PCLK1 such as PCLK1 = HCLK/2 */  
RCC_PCLK1Config(RCC_HCLK_Div2);

# 15.2.12 函数RCC_PCLK2Config

Table 355. 描述了函数RCC_PCLK2Config  
Table 355. 函数 RCC_PCLK2Config  

<table><tr><td>函数名</td><td>RCC_PCLK2Config</td></tr><tr><td>函数原形</td><td>void RCC_PCLK2Config(u32 RCC_PCLK2)</td></tr><tr><td>功能描述</td><td>设置高速AHB时钟（PCLK2）</td></tr><tr><td>输入参数</td><td>RCC_PCLK2: 定义PCLK2，该时钟源自AHB时钟（HCLK）
参阅Section：RCC_PCLK2 查阅更多该参数允许取值范围</td></tr><tr><td>输出参数</td><td>无</td></tr><tr><td>返回值</td><td>无</td></tr><tr><td>先决条件</td><td>无</td></tr><tr><td>被调用函数</td><td>无</td></tr></table>

# RCC PCLK2

该参数设置了高速AHB时钟（PCLK2），Table 356. 给出了该参数可取的值。

Table 356. RCC_PCLK1 值  

<table><tr><td>RCC_PCLK2</td><td>描述</td></tr><tr><td>RCC_HCLKDIV1</td><td>APB2时钟 = HCLK</td></tr><tr><td>RCC_HCLKDIV2</td><td>APB2时钟 = HCLK/2</td></tr><tr><td>RCC_HCLKDIV4</td><td>APB2时钟 = HCLK/4</td></tr><tr><td>RCC_HCLKDIV8</td><td>APB2时钟 = HCLK/8</td></tr><tr><td>RCC_HCLKDIV16</td><td>APB2时钟 = HCLK/16</td></tr></table>

例：  
/* Configure PCLK2 such as PCLK2 = HCLK */  
RCC_PCLK2Config(RCC_HCLK_Div1);

# 15.2.13 函数RCC_ITConfig

Table 357. 描述了函数RCC_ITConfig  
Table 357. 函数 RCC_ITConfig  

<table><tr><td>函数名</td><td>RCC_ITConfig</td></tr><tr><td>函数原形</td><td>void RCC_ITConfig(u8 RCC_IT, FunctionalState NewState)</td></tr><tr><td>功能描述</td><td>使能或者失能指定的 RCC 中断</td></tr><tr><td>输入参数 1</td><td>RCC_IT: 待使能或者失能的 RCC 中断源
参阅 Section: RCC_IT 查阅更多该参数允许取值范围</td></tr><tr><td>输入参数 2</td><td>NewState: RCC 中断的新状态
这个参数可以取: ENABLE 或者 DISABLE</td></tr><tr><td>输出参数</td><td>无</td></tr><tr><td>返回值</td><td>无</td></tr><tr><td>先决条件</td><td>无</td></tr><tr><td>被调用函数</td><td>无</td></tr></table>

# RCC_IT

输入参数 RCC_IT 使能或者失能 RCC 的中断。可以取下表的一个或者多个取值的组合作为该参数的值。

Table 358. RCC_IT 值  

<table><tr><td>RCC_IT</td><td>描述</td></tr><tr><td>RCC_IT_LSIRDY</td><td>LSI就绪中断</td></tr><tr><td>RCC_IT_LSERDY</td><td>LSE就绪中断</td></tr><tr><td>RCC_IT_HSIRDY</td><td>HSI就绪中断</td></tr><tr><td>RCC_IT_HSERDY</td><td>HSE就绪中断</td></tr><tr><td>RCC_IT_PLLRDY</td><td>PLL就绪中断</td></tr></table>

例：

/\*EnablePLLReadyinterrupt\*/ RCC_ITConfig(RCC_IT_PLLRDY，ENABLE);

# 15.2.14 函数RCC_USBCLKConfig

Table 359. 描述了函数RCC_USBCLKConfig  
Table 359. 函数 RCC_USBCLKConfig  

<table><tr><td>函数名</td><td>RCC_USBCLKConfig</td></tr><tr><td>函数原形</td><td>void RCC_USBCLKConfig(u32 RCC_USBCLKSource)</td></tr><tr><td>功能描述</td><td>设置USB时钟（USBCLK）</td></tr><tr><td>输入参数</td><td>RCC_USBCLKSource: 定义USBCLK, 该时钟源自PLL 输出
参阅Section: RCC_USBCLKSource 查阅更多该参数允许取值范围</td></tr><tr><td>输出参数</td><td>无</td></tr><tr><td>返回值</td><td>无</td></tr><tr><td>先决条件</td><td>无</td></tr><tr><td>被调用函数</td><td>无</td></tr></table>

# RCC_USBCLKSource

该参数设置了USB时钟（USBCLK），Table 360. 给出了该参数可取的值。

Table 360. RCC_USBCLKSource 值  

<table><tr><td>RCC_USBCLKSource</td><td>描述</td></tr><tr><td>RCC_USBCLKSource_PLLCLK_1Div5</td><td>USB时钟 = PLL时钟除以1.5</td></tr><tr><td>RCC_USBCLKSource_PLLCLK_Div1</td><td>USB时钟 = PLL时钟</td></tr></table>

例：

/* PLL clock divided by 1.5 used as USB clock source */
RCC_USBCLKConfig(RCC_USBCLKSource_PLLCLK_1Div5);

# 15.2.15 函数RCC_ADCCLKConfig

Table 361. 描述了函数RCC_ADCCLKConfig  
Table 361. 函数 RCC_ADCCLKConfig  

<table><tr><td>函数名</td><td>RCC_ADCCLKConfig</td></tr><tr><td>函数原形</td><td>void ADC_ADCCLKConfig(u32 RCC_ADCCLKSource)</td></tr><tr><td>功能描述</td><td>设置ADC时钟（ADCCLK）</td></tr><tr><td>输入参数</td><td>RCC_ADCCLKSource: 定义ADCCLK, 该时钟源自APB2时钟 (PCLK2)参阅Section: RCC_ADCCLKSource 查阅更多该参数允许取值范围</td></tr><tr><td>输出参数</td><td>无</td></tr><tr><td>返回值</td><td>无</td></tr><tr><td>先决条件</td><td>无</td></tr><tr><td>被调用函数</td><td>无</td></tr></table>

# RCC_ADCCLKSource

该参数设置了ADC时钟（ADCCLK），Table362.给出了该参数可取的值。

Table 362. RCC_ADCCLKSource 值  

<table><tr><td>RCC_ADCCLKSource</td><td>描述</td></tr><tr><td>RCC_PCLK2_Div2</td><td>ADC时钟 = PCLK / 2</td></tr><tr><td>RCC_PCLK2_Div4</td><td>ADC时钟 = PCLK / 4</td></tr><tr><td>RCC_PCLK2_Div6</td><td>ADC时钟 = PCLK / 6</td></tr><tr><td>RCC_PCLK2_Div8</td><td>ADC时钟 = PCLK / 8</td></tr></table>

例：

/\* Configure ADCCLK such as ADCCLK  $=$  PCLK2/2 \*/ RCC_ADCCLKConfig(RCC_PCLK2_Div2);

# 15.2.16 函数RCC_LSEConfig

Table 363. 描述了函数RCC_LSEConfig  
Table 363. 函数 RCC_LSEConfig  

<table><tr><td>函数名</td><td>RCC_LSEConfig</td></tr><tr><td>函数原形</td><td>void RCC_LSEConfig(u32 RCC_HSE)</td></tr><tr><td>功能描述</td><td>设置外部低速晶振（LSE）</td></tr><tr><td>输入参数</td><td>RCC_LSE: LSE 的新状态
参阅 Section: RCC_HSE 查阅更多该参数允许取值范围</td></tr><tr><td>输出参数</td><td>无</td></tr><tr><td>返回值</td><td>无</td></tr><tr><td>先决条件</td><td>无</td></tr><tr><td>被调用函数</td><td>无</td></tr></table>

# RCC_LSE

该参数设置了HSE的状态（见Table364.）。

Table 364. RCC_LSE 定义  

<table><tr><td>RCC_LSE</td><td>描述</td></tr><tr><td>RCC_LSE_OFF</td><td>LSE 晶振 OFF</td></tr><tr><td>RCC_LSE_ON</td><td>LSE 晶振 ON</td></tr><tr><td>RCC_LSE_Bypass</td><td>LSE 晶振被外部时钟旁路</td></tr></table>

例：

/\*Enable the LSE \*/

RCC_LSEConfig(RCC_LSE_ON);

# 15.2.17 函数RCC_LSICmd

Table 365. 描述了函数 RCC_LSICmd  
Table 365. 函数 RCC_LSICmd  

<table><tr><td>函数名</td><td>RCC_LSICmd</td></tr><tr><td>函数原形</td><td>void RCC_LSICmd(FunctionalState NewState)</td></tr><tr><td>功能描述</td><td>使能或者失能内部低速晶振（LSI）</td></tr><tr><td>输入参数</td><td>NewState: LSI 新状态
这个参数可以取：ENABLE 或者 DISABLE</td></tr><tr><td>输出参数</td><td>无</td></tr><tr><td>返回值</td><td>无</td></tr><tr><td>先决条件</td><td>如果 IWDG 运行的话，LSI 不能被失能</td></tr><tr><td>被调用函数</td><td>无</td></tr></table>

例：

/\* Enable the Internal Low Speed oscillator \*/ RCC_LSICmd(ENABLE);

# 15.2.18 函数RCC_RTCCLKConfig

Table 366. 描述了函数RCC_RTCCLKConfig

Table 366. 函数 RCC_RTCCLKConfig  

<table><tr><td>函数名</td><td>RCC_RTCCLKConfig</td></tr><tr><td>函数原形</td><td>void RCC_RTCCLKConfig(u32 RCC_RTCCLKSource)</td></tr><tr><td>功能描述</td><td>设置RTC时钟（RTCCLK）</td></tr><tr><td>输入参数</td><td>RCC_RTCCLKSource: 定义RTCCLK
参阅Section: RCC_RTCCLKSource 查阅更多该参数允许取值范围</td></tr><tr><td>输出参数</td><td>无</td></tr><tr><td>返回值</td><td>无</td></tr><tr><td>先决条件</td><td>RTC时钟一经选定即不能更改，除非复位后备域</td></tr><tr><td>被调用函数</td><td>无</td></tr></table>

# RCC_RTCCLKSource

该参数设置了RTC时钟（RTCCLK），Table367.给出了该参数可取的值。

Table 367. RCC_RTCCLKSource 值  

<table><tr><td>RCC_RTCCLKSource</td><td>描述</td></tr><tr><td>RCC_RTCCLKSource_LSE</td><td>选择LSE作为RTC时钟</td></tr><tr><td>RCC_RTCCLKSource_LSI</td><td>选择LSI作为RTC时钟</td></tr><tr><td>RCC_RTCCLKSource_HSE_Div128</td><td>选择HSE时钟频率除以128作为RTC时钟</td></tr></table>

例：

/* Select the LSE as RTC clock source */

RCC_RTCCLKConfig(RCC_RTCCLKSource_LSE);

# 15.2.19 函数RCC_RTCCLKCmd

Table 368. 描述了函数 RCC_RTCCLKCmd

Table 368. 函数 RCC_RTCCLKCmd  

<table><tr><td>函数名</td><td>RCC_RTCCLKCmd</td></tr><tr><td>函数原形</td><td>void RCC_RTCCLKCmd(FunctionalState NewState)</td></tr><tr><td>功能描述</td><td>使能或者失能 RTC 时钟</td></tr><tr><td>输入参数</td><td>NewState: RTC 时钟的新状态
这个参数可以取: ENABLE 或者 DISABLE</td></tr><tr><td>输出参数</td><td>无</td></tr><tr><td>返回值</td><td>无</td></tr><tr><td>先决条件</td><td>该函数只有在通过函数 RCC_RTCCLKConfig 选择 RTC 时钟后, 才能调用</td></tr><tr><td>被调用函数</td><td>无</td></tr></table>

例：

/* Enable the RTC clock */

RCC_RTCCLKCmd (ENABLE)；

# 15.2.20 函数RCC_GetClocksFreq

Table 369. 描述了函数 RCC_GetClocksFreq

Table 369. 函数 RCC_GetClocksFreq  

<table><tr><td>函数名</td><td>RCC_GetClocksFreq</td></tr><tr><td>函数原形</td><td>void RCC_GetClocksFreq(RCC_ClocksTypeDef* RCC_Clocks)</td></tr><tr><td>功能描述</td><td>返回不同片上时钟的频率</td></tr><tr><td>输入参数</td><td>RCC_Clocks: 指向结构 RCC_ClocksTypeDef 的指针, 包含了各个时钟的频率
参阅 Section: RCC_Clocks 查阅更多该参数允许取值范围</td></tr><tr><td>输出参数</td><td>无</td></tr><tr><td>返回值</td><td>无</td></tr><tr><td>先决条件</td><td>无</td></tr><tr><td>被调用函数</td><td>无</td></tr></table>

# RCC_ClocksTypeDef structure

RCC_ClocksTypeDef 定义于文件“stm32f10x_rcc.h”：

typedef struct

u32 SYSCLK Frequency;

u32 HCLK_Frequency;

u32 PCLK1_Frequency;

u32 PCLK2_Frequency;

u32 ADCCLK_Frequency;

}RCC_ClocksTypeDef;

# SYSCLK_Frequency

该成员返回 SYSCLK 的频率，单位 Hz

# HCLK_Frequency

该成员返回 HCLK 的频率，单位 Hz

# PCLK1_Frequency

该成员返回 PCLK1 的频率，单位 Hz

# PCLK2_Frequency

该成员返回 PCLK2 的频率，单位 Hz

# ADCCLK_Frequency

该成员返回ADCCLK的频率，单位  $\mathrm{Hz}$

例：

/* Get the frequencies of different on chip clocks */

RCC_ClocksTypeDef RCC_Clocks;

RCC_GetClocksFreq(&RCC_Clocks);

# 15.2.21 函数RCC_AHBPeriphClockCmd

Table 370. 描述了函数RCC_AHBPeriphClockCmd

Table 370. 函数 RCC_AHBPeriphClockCmd  

<table><tr><td>函数名</td><td>RCC_AHBPeriphClockCmd</td></tr><tr><td>函数原形</td><td>void RCC_AHBPeriphClockCmd(u32 RCC_AHBPeriph, FunctionalState NewState)</td></tr><tr><td>功能描述</td><td>使能或者失能 AHB 外设时钟</td></tr><tr><td>输入参数1</td><td>RCC_AHBPeriph: 门控 AHB 外设时钟
参阅 Section: RCC_AHBPeriph 查阅更多该参数允许取值范围</td></tr><tr><td>输入参数2</td><td>NewState: 指定外设时钟的新状态
这个参数可以取: ENABLE 或者 DISABLE</td></tr><tr><td>输出参数</td><td>无</td></tr><tr><td>返回值</td><td>无</td></tr><tr><td>先决条件</td><td>无</td></tr><tr><td>被调用函数</td><td>无</td></tr></table>

# RCC_AHBPeriph

该参数被门控的AHB外设时钟，可以取下表的一个或者多个取值的组合作为该参数的值。

Table 371. RCC_AHBPeriph值 (1)  

<table><tr><td>RCC_AHBPeriph</td><td>描述</td></tr><tr><td>RCC_AHBPeriph_DMA</td><td>DMA时钟</td></tr><tr><td>RCC_AHBPeriph_SRAM</td><td>SRAM时钟</td></tr><tr><td>RCC_AHBPeriph_FLITF</td><td>FLITF时钟</td></tr></table>

1. SRAM和FLITF时钟只能在睡眠（SLEEP）模式下被失能。

例：

/\*EnableDMAclock\*/ RCC_AHBPeriphClockCmd(RCC_AHBPeriph_DMA);

# 15.2.22 函数RCC_APB2PeriphClockCmd

Table 372. 描述了函数RCC_APB2PeriphClockCmd

Table 372. 函数 RCC_APB2PeriphClockCmd  

<table><tr><td>函数名</td><td>RCC_AP2APB2PeriphClockCmd</td></tr><tr><td>函数原形</td><td>void RCC_AP2APB2PeriphClockCmd(u32 RCC_AP2Periph, FunctionalState NewState)</td></tr><tr><td>功能描述</td><td>使能或者失能 APB2 外设时钟</td></tr><tr><td>输入参数 1</td><td>RCC_AP2Periph: 门控 APB2 外设时钟参阅 Section: RCC_AP2Periph 查阅更多该参数允许取值范围</td></tr><tr><td>输入参数 2</td><td>NewState: 指定外设时钟的新状态这个参数可以取: ENABLE 或者 DISABLE</td></tr><tr><td>输出参数</td><td>无</td></tr><tr><td>返回值</td><td>无</td></tr><tr><td>先决条件</td><td>无</td></tr><tr><td>被调用函数</td><td>无</td></tr></table>

# RCC/APB2Periph

该参数被门控的APB2外设时钟，可以取下表的一个或者多个取值的组合作为该参数的值。

Table 373. RCC_AHB2Periph 值  

<table><tr><td>RCC_AHB2Periph</td><td>描述</td></tr><tr><td>RCC_APB2Periph_AFIO</td><td>功能复用 IO 时钟</td></tr><tr><td>RCC_APB2Periph_GPIOA</td><td>GPIOA 时钟</td></tr><tr><td>RCC_APB2Periph_GPIOB</td><td>GPIOB 时钟</td></tr><tr><td>RCC_APB2Periph_GPIOC</td><td>GPIOC 时钟</td></tr><tr><td>RCC_APB2Periph_GPIOD</td><td>GPIOD 时钟</td></tr><tr><td>RCC_APB2Periph_GPIOE</td><td>GPIOE 时钟</td></tr><tr><td>RCC_APB2Periph_ADC1</td><td>ADC1 时钟</td></tr><tr><td>RCC_APB2Periph_ADC2</td><td>ADC2 时钟</td></tr><tr><td>RCC_APB2Periph_TIM1</td><td>TIM1 时钟</td></tr><tr><td>RCC_APB2Periph_SPI1</td><td>SPI1 时钟</td></tr><tr><td>RCC_APB2Periph_USART1</td><td>USART1 时钟</td></tr><tr><td>RCC_APB2Periph_ALL</td><td>全部 APB2 外设时钟</td></tr></table>

例：  
/\*Enable GPIOA，GPIOB and SPI1 clocks \*/ RCC_APB2PeriphClockCmd(RCC_APB2Periph GPIOA|RCC_APB2Periph_GPIOB | RCC_APB2Periph_SPI1，ENABLE);

# 15.2.23 函数RCC_APB1PeriphClockCmd

Table 374. 描述了函数RCC_APB1PeriphClockCmd  
Table 374. 函数 RCC_APB1PeriphClockCmd  

<table><tr><td>函数名</td><td>RCC_APBCAP1PeriphClockCmd</td></tr><tr><td>函数原形</td><td>void RCC_APBCAP1PeriphClockCmd(u32 RCC_APBCAP1Periph, FunctionalState NewState)</td></tr><tr><td>功能描述</td><td>使能或者失能 APB1 外设时钟</td></tr><tr><td>输入参数 1</td><td>RCC_APBCAP1Periph: 门控 APB1 外设时钟
参阅 Section: RCC_APBCAP1Periph 查阅更多该参数允许取值范围</td></tr><tr><td>输入参数 2</td><td>NewState: 指定外设时钟的新状态
这个参数可以取: ENABLE 或者 DISABLE</td></tr><tr><td>输出参数</td><td>无</td></tr><tr><td>返回值</td><td>无</td></tr><tr><td>先决条件</td><td>无</td></tr><tr><td>被调用函数</td><td>无</td></tr></table>

# RCC/APB1Periph

该参数被门控的APB1外设时钟，可以取下表的一个或者多个取值的组合作为该参数的值。

Table 375. RCC_AHB1Periph 值  

<table><tr><td>RCC_AHB1Periph</td><td>描述</td></tr><tr><td>RCC_AP1Periph_TIM2</td><td>TIM2时钟</td></tr><tr><td>RCC_AP1Periph_TIM3</td><td>TIM3时钟</td></tr><tr><td>RCC_AP1Periph_TIM4</td><td>TIM4时钟</td></tr><tr><td>RCC_AP1Periph_WWDG</td><td>WWDG时钟</td></tr><tr><td>RCC_AP1Periph_SPI2</td><td>SPI2时钟</td></tr><tr><td>RCC_AP1Periph_USART2</td><td>USART2时钟</td></tr><tr><td>RCC_AP1Periph_USART3</td><td>USART3时钟</td></tr><tr><td>RCC_AP1Periph_I2C1</td><td>I2C1时钟</td></tr><tr><td>RCC_AP1Periph_I2C2</td><td>I2C2时钟</td></tr><tr><td>RCC_AP1Periph_USB</td><td>USB时钟</td></tr><tr><td>RCC_AP1Periph_CAN</td><td>CAN时钟</td></tr></table>

ST

译文英文原版为UM0427 Oct. 2007 Rev 2, 译文仅供参考，与英文版冲突的，以英文版为准

RCC  

<table><tr><td>RCC_AP1Periph_BKP</td><td>BKP时钟</td></tr><tr><td>RCC_AP1Periph_PWR</td><td>PWR时钟</td></tr><tr><td>RCC_AP1Periph_ALL</td><td>全部APB1外设时钟</td></tr></table>

例：

/\*EnableBKPandPWRclocks\*/ RCC/APB1PeriphClockCmd(RCC/APB1Periph_BKP|RCC/APB1Periph_PWR, ENABLE);

# 15.2.24 函数RCC_APB2PeriphResetCmd

Table 376. 描述了函数RCC_AP2PeriphResetCmd  
Table 376. 函数 RCC_APB2PeriphResetCmd  

<table><tr><td>函数名</td><td>RCC_AP2PeriphResetCmd</td></tr><tr><td>函数原形</td><td>void RCC_AP2PeriphResetCmd(u32 RCC_AP2Periph, FunctionalState NewState)</td></tr><tr><td>功能描述</td><td>强制或者释放高速 APB (APB2) 外设复位</td></tr><tr><td>输入参数 1</td><td>RCC_AP2Periph: APB2 外设复位
参阅 Section: RCC_AP2Periph 查阅更多该参数允许取值范围</td></tr><tr><td>输入参数 2</td><td>NewState: 指定 APB2 外设复位的新状态
这个参数可以取: ENABLE 或者 DISABLE</td></tr><tr><td>输出参数</td><td>无</td></tr><tr><td>返回值</td><td>无</td></tr><tr><td>先决条件</td><td>无</td></tr><tr><td>被调用函数</td><td>无</td></tr></table>

例：

/\*Enter the SPI1 peripheral to reset \*/ RCC/APB2PeriphResetCmd(RCC/APB2Periph_SPI1，ENABLE); /\*Exit the SPI1 peripheral from reset \*/ RCC/APB2PeriphResetCmd(RCC/APB2Periph_SPI1，DISABLE)；

# 15.2.25 函数RCC_APB1PeriphResetCmd

Table 377. 描述了函数RCC_AP1PeriphResetCmd  
Table 377. 函数 RCC_APB1PeriphResetCmd  

<table><tr><td>函数名</td><td>RCC_APBY1PeriphResetCmd</td></tr><tr><td>函数原形</td><td>void RCC_APBY1PeriphResetCmd(u32 RCC_APBY1Periph, FunctionalState NewState)</td></tr><tr><td>功能描述</td><td>强制或者释放低速 APB (APB1) 外设复位</td></tr><tr><td>输入参数 1</td><td>RCC_APBY1Periph: APB1 外设复位
参阅 Section: RCC_APBY1Periph 查阅更多该参数允许取值范围</td></tr><tr><td>输入参数 2</td><td>NewState: 指定 APB1 外设复位的新状态
这个参数可以取: ENABLE 或者 DISABLE</td></tr><tr><td>输出参数</td><td>无</td></tr><tr><td>返回值</td><td>无</td></tr><tr><td>先决条件</td><td>无</td></tr><tr><td>被调用函数</td><td>无</td></tr></table>

例：

/\*Enter the SPI2 peripheral to reset \*/ RCC_APBlPeriphResetCmd(RCC_APBlPeriph_SPI2，ENABLE); /\*Exit the SPI2 peripheral from reset \*/ RCC_APBlPeriphResetCmd(RCC_APBlPeriph_SPI2，DISABLE);

# 15.2.26 函数RCC_BackupResetCmd

Table 378. 描述了函数RCC_BackupResetCmd  
Table 378. 函数 RCC_BackupResetCmd  

<table><tr><td>函数名</td><td>RCC_BackupResetCmd</td></tr><tr><td>函数原形</td><td>void RCC_BackupResetCmd(FunctionalState NewState)</td></tr><tr><td>功能描述</td><td>强制或者释放后备域复位</td></tr><tr><td>输入参数</td><td>NewState: 后备域复位的新状态
这个参数可以取: ENABLE 或者 DISABLE</td></tr><tr><td>输出参数</td><td>无</td></tr><tr><td>返回值</td><td>无</td></tr><tr><td>先决条件</td><td>无</td></tr><tr><td>被调用函数</td><td>无</td></tr></table>

例：
/* Reset the entire Backup domain */
RCC_BackupResetCmd(ENABLE);

# 15.2.27 函数RCC_ClockSecuritySystemCmd

Table 379. 描述了函数RCC_ClockSecuritySystemCmd  
Table 379. 函数 RCC_ClockSecuritySystemCmd  

<table><tr><td>函数名</td><td>RCC_ClockSecuritySystemCmd</td></tr><tr><td>函数原形</td><td>void RCC_ClockSecuritySystemCmd(FunctionalState NewState)</td></tr><tr><td>功能描述</td><td>使能或者失能时钟安全系统</td></tr><tr><td>输入参数</td><td>NewState: 时钟安全系统的新状态
这个参数可以取: ENABLE 或者 DISABLE</td></tr><tr><td>输出参数</td><td>无</td></tr><tr><td>返回值</td><td>无</td></tr><tr><td>先决条件</td><td>无</td></tr><tr><td>被调用函数</td><td>无</td></tr></table>

例：
/* Enable the Clock Security System */
RCC_ClockSecuritySystemCmd(ENABLE);

# 15.2.28 函数RCC_MCOConfig

Table 380. 描述了函数RCC_MCOConfig  
Table 380. 函数 RCC_MCOConfig  

<table><tr><td>函数名</td><td>RCC_MCOConfig</td></tr><tr><td>函数原形</td><td>void RCC_MCOConfig(u8 RCC_MCO)</td></tr><tr><td>功能描述</td><td>选择在 MCO 管脚上输出的时钟源</td></tr><tr><td>输入参数</td><td>RCC_MCO: 指定输出的时钟源
参阅 Section: RCC_MCO 查阅更多该参数允许取值范围</td></tr><tr><td>输出参数</td><td>无</td></tr><tr><td>返回值</td><td>无</td></tr><tr><td>先决条件</td><td>无</td></tr><tr><td>被调用函数</td><td>无</td></tr></table>

ST  
译文英文原版为UM0427 Oct. 2007 Rev 2, 译文仅供参考，与英文版冲突的，以英文版为准

# RCC MCO

该参数设置了指定输出的时钟源，Table 381. 给出了该参数可取的值。

Table 381. RCC_MCO值  

<table><tr><td>RCC_MCO</td><td>描述</td></tr><tr><td>RCC_MCO_NoClock</td><td>无时钟被选中</td></tr><tr><td>RCC_MCO_SYSCLK</td><td>选中系统时钟</td></tr><tr><td>RCC_MCO_HSI</td><td>选中HSI</td></tr><tr><td>RCC_MCO_HSE</td><td>选中HSE</td></tr><tr><td>RCC_MCO_PLLCLK_Div2</td><td>选中PLL时钟除以2</td></tr></table>

警告：当选中系统时钟作为 MCO 管脚的输出时，注意它的时钟频率不超过 50MHz(最大 I/O 速率)。

例：

```txt
/\* Output PLL clock divided by 2 on MCO pin \*/ RCC_MCOConfig(RCC_MCO_PLLCLK_Div2);
```

# 15.2.29 函数RCC_GetFlagStatus

Table 382. 描述了函数RCC_GetFlagStatus  
Table 382. 函数 RCC_GetFlagStatus  

<table><tr><td>函数名</td><td>RCC_GetFlagStatus</td></tr><tr><td>函数原形</td><td>FlagStatus RCC_GetFlagStatus(u8 RCC_FLAG)</td></tr><tr><td>功能描述</td><td>检查指定的 RCC 标志位设置与否</td></tr><tr><td>输入参数</td><td>RCC_FLAG: 待检查的 RCC 标志位
参阅 Section: RCC_FLAG 查阅更多该参数允许取值范围</td></tr><tr><td>输出参数</td><td>无</td></tr><tr><td>返回值</td><td>RCC_FLAG 的新状态 (SET 或者 RESET)</td></tr><tr><td>先决条件</td><td>无</td></tr><tr><td>被调用函数</td><td>无</td></tr></table>

# RCC_FLAG

Table 383. 给出了所有可以被函数RCC_GetFlagStatus检查的标志位列表

Table 383. RCC_FLAG 值  

<table><tr><td>RCC_FLAG</td><td>描述</td></tr><tr><td>RCC_FLAG_HSIRDY</td><td>HSI 晶振就绪</td></tr><tr><td>RCC_FLAG_HSERDY</td><td>HSE 晶振就绪</td></tr><tr><td>RCC_FLAG_PLLRDY</td><td>PLL 就绪</td></tr><tr><td>RCC_FLAG_LSERDY</td><td>LSI 晶振就绪</td></tr><tr><td>RCC_FLAG_LSIRDY</td><td>LSE 晶振就绪</td></tr><tr><td>RCC_FLAG_PINRST</td><td>管脚复位</td></tr><tr><td>RCC_FLAG_PORRST</td><td>POR/PDR 复位</td></tr><tr><td>RCC_FLAG_SFTRST</td><td>软件复位</td></tr><tr><td>RCC_FLAG_IWDGRST</td><td>IWDG 复位</td></tr><tr><td>RCC_FLAG_WWDGRST</td><td>WWDG 复位</td></tr><tr><td>RCC_FLAG_LPWRRST</td><td>低功耗复位</td></tr></table>

例：

```c
/\*Testif thePLL clock is ready or not \*/ FlagStatus Status;   
Status  $=$  RCC_GetFlagStatus(RCC_FLAG_PLLRDY); if(Status  $= =$  RESET) {   
1   
}   
else
```

ST

译文英文原版为UM0427 Oct. 2007 Rev 2, 译文仅供参考，与英文版冲突的，以英文版为准

# 15.2.30 函数RCC_ClearFlag

Table 384. 描述了函数RCC_ClearFlag  
Table 384. 函数 RCC_ClearFlag  

<table><tr><td>函数名</td><td>RCC_ClearFlag</td></tr><tr><td>函数原形</td><td>void RCC_ClearFlag(void)</td></tr><tr><td>功能描述</td><td>清除RCC的复位标志位</td></tr><tr><td>输入参数</td><td>RCC_FLAG: 清除的RCC复位标志位可以清除的复位标志位有: RCC_FLAG_PINRST, RCC_FLAG_PORRST, RCC_FLAG_SFTRST, RCC_FLAG_IWDGRST, RCC_FLAG_WWDGRST, RCC_FLAG_LPWRRST</td></tr><tr><td>输出参数</td><td>无</td></tr><tr><td>返回值</td><td>无</td></tr><tr><td>先决条件</td><td>无</td></tr><tr><td>被调用函数</td><td>无</td></tr></table>

例：  
/* Clear the reset flags */
RCC_ClearFlag();

# 15.2.31 函数RCC_GetITStatus

Table 385. 描述了函数RCC_GetITStatus  
Table 385. 函数 RCC_GetITStatus  

<table><tr><td>函数名</td><td>RCC_GetITStatus</td></tr><tr><td>函数原形</td><td>ITStatus RCC_GetITStatus(u8 RCC_IT)</td></tr><tr><td>功能描述</td><td>检查指定的 RCC 中断发生与否</td></tr><tr><td>输入参数</td><td>RCC_IT: 待检查的 RCC 中断源
参阅 Section: RCC_IT 查阅更多该参数允许取值范围</td></tr><tr><td>输出参数</td><td>无</td></tr><tr><td>返回值</td><td>RCC_IT 的新状态</td></tr><tr><td>先决条件</td><td>无</td></tr><tr><td>被调用函数</td><td>无</td></tr></table>

# RCC_IT

Table 386. 给出了所有可以被函数RCC_GetITStatus检查的中断标志位列表  
Table 386. RCC_IT 值  

<table><tr><td>RCC_IT</td><td>描述</td></tr><tr><td>RCC_IT_LSIRDY</td><td>LSI 晶振就绪中断</td></tr><tr><td>RCC_IT_LSERDY</td><td>LSE 晶振就绪中断</td></tr><tr><td>RCC_IT_HSIRDY</td><td>HSI 晶振就绪中断</td></tr><tr><td>RCC_IT_HSERDY</td><td>HSE 晶振就绪中断</td></tr><tr><td>RCC_IT_PLLRDY</td><td>PLL 就绪中断</td></tr><tr><td>RCC_IT.CSS</td><td>时钟安全系统中断</td></tr></table>

例：  
/* Test if the PLL Ready interrupt has occurred or not */  
ITStatus Status;  
Status  $=$  RCC_GetITStatus(RCC_IT_PLLRDY);  
ST  
译文英文原版为UM0427 Oct. 2007 Rev 2, 译文仅供参考，与英文版冲突的，以英文版为准

RCC  
```lisp
if(Status == RESET)  
{  
    ...  
} else  
{  
    ...  
}
```

# 15.2.32 函数RCC_ClearITPendingBit

Table 387. 描述了函数RCC_ClearITPendingBit  
Table 387. 函数 RCC_ClearITPendingBit  

<table><tr><td>函数名</td><td>RCC_ClearITPendingBit</td></tr><tr><td>函数原形</td><td>void RCC_ClearITPendingBit(u8 RCC_IT)</td></tr><tr><td>功能描述</td><td>清除 RCC 的中断待处理位</td></tr><tr><td>输入参数</td><td>RCC_IT: 待检查的 RCC 中断源
参阅 Section: RCC_IT 查阅更多该参数允许取值范围</td></tr><tr><td>输出参数</td><td>无</td></tr><tr><td>返回值</td><td>无</td></tr><tr><td>先决条件</td><td>无</td></tr><tr><td>被调用函数</td><td>无</td></tr></table>

# RCC IT

Table 388. 给出了所有可以被函数RCC_ClearITPendingBit清除的中断待处理位列表  
Table 388. RCC_IT 值  

<table><tr><td>RCC_IT</td><td>描述</td></tr><tr><td>RCC_IT_LSIRDY</td><td>LSI 晶振就绪中断</td></tr><tr><td>RCC_IT_LSERDY</td><td>LSE 晶振就绪中断</td></tr><tr><td>RCC_IT_HSIRDY</td><td>HSI 晶振就绪中断</td></tr><tr><td>RCC_IT_HSERDY</td><td>HSE 晶振就绪中断</td></tr><tr><td>RCC_IT_PLLRDY</td><td>PLL 就绪中断</td></tr><tr><td>RCC_IT.CSS</td><td>时钟安全系统中断</td></tr></table>

例：

```c
/\* Clear the PLL Ready interrupt pending bit \*/ RCC_ClearITPendingBit(RCC_IT_PLLRDY);
```

# 16 实时时钟（RTC）

RTC 提供了一系列连续工作的计数器，配合适当的软件，具有提供时钟-日历的功能。写入计数器的值可以设置整个系统的时间/日期。

Section 16.1 RTC 寄存器结构描述了固件函数库所使用的数据结构，Section 16.2 固件库函数介绍了函数库里的所有函数。

# 16.1 RTC寄存器结构

寄存器结构，RTC_TypeDeff，在文件“stm32f10x_map.h”中定义如下：

```txt
typedef struct   
{   
vu16 CRH;   
u16 RESERVED1;   
vu16 CRL;   
u16 RESERVED2;   
vu16 PRLH;   
u16 RESERVED3;   
vu16 PRLL;   
u16 RESERVED4;   
vu16 DIVH;   
u16 RESERVED5;   
vu16 DIVL;   
u16 RESERVED6;   
vu16 CNTH;   
u16 RESERVED7;   
vu16 CNTL;   
u16 RESERVED8;   
vu16 ALRH;   
u16 RESERVED9;   
vu16 ALRL;   
u16 RESERVED10; } RTCTypeDef;
```

Table 389.例举了RTC所有寄存器

Table 389.RTC 寄存器  

<table><tr><td>寄存器</td><td>描述</td></tr><tr><td>CRH</td><td>控制寄存器高位</td></tr><tr><td>CRL</td><td>控制寄存器低位</td></tr><tr><td>PRLH</td><td>预分频装载寄存器高位</td></tr><tr><td>PRLL</td><td>预分频装载寄存器低位</td></tr><tr><td>DIVH</td><td>预分频分频因子寄存器高位</td></tr><tr><td>DIVL</td><td>预分频分频因子寄存器低位</td></tr><tr><td>CNTH</td><td>计数器寄存器高位</td></tr><tr><td>CNTL</td><td>计数器寄存器低位</td></tr><tr><td>ALRH</td><td>闹钟寄存器高位</td></tr><tr><td>ALRL</td><td>闹钟寄存器低位</td></tr></table>

RTC外设声明于文件“stm32f10x_map.h”：

```c
define PERIPH_BASE ((u32)0x40000000)  
#define APB1PERIPH_BASE PERIPH_BASE  
#define APB2PERIPH_BASE (PERIPH_BASE + 0x10000)  
#define AHBPERIPH_BASE (PERIPH_BASE + 0x20000)
```

```txt
中
```

# ST

译文英文原版为UM0427 Oct. 2007 Rev 2, 译文仅供参考，与英文版冲突的，以英文版为准

RTC  
```c
define RTC_BASE (APB1PERIPH_BASE + 0x2800)  
#	define DEBUG  
...  
#	define_RTC  
#	define RTC ((RTC_TYPEDef *) RTC_BASE)  
#endif /*_RTC */  
...  
#else /* DEBUG */  
...  
#	define RTC  
EXT RTC_TYPEDef *RTC;  
#endif /*_RTC */  
...  
#endif
```

使用Debug模式时，初始化指针RTC于文件“stm32f10x_lib.c”：

```c
ifdef RTC  
RTC = (RTCTypeDef *) RTC_BASE;  
#endif /* RTC */
```

为了访问RTC寄存器，,RTC必须在文件“stm32f10x_conf.h”中定义如下：

```txt
define RTC
```

# 16.2 RTC库函数

Table 390. 例举了RTC的库函数  
Table 390. RTC 库函数  

<table><tr><td>函数名</td><td>描述</td></tr><tr><td>RTC_ITConfig</td><td>使能或者失能指定的RTC中断</td></tr><tr><td>RTC_EnterConfigMode</td><td>进入RTC配置模式</td></tr><tr><td>RTC_ExitConfigMode</td><td>退出RTC配置模式</td></tr><tr><td>RTC_GetCounter</td><td>获取RTC计数器的值</td></tr><tr><td>RTC_SetCounter</td><td>设置RTC计数器的值</td></tr><tr><td>RTC_SetPrescaler</td><td>设置RTC预分频的值</td></tr><tr><td>RTC_SetAlarm</td><td>设置RTC闹钟的值</td></tr><tr><td>RTC_GetDivider</td><td>获取RTC预分频分频因子的值</td></tr><tr><td>RTC_WaitForLastTask</td><td>等待最近一次对RTC寄存器的写操作完成</td></tr><tr><td>RTC_WaitForSynchro</td><td>等待RTC寄存器(RTC_CNT, RTC_ALR and RTC_PRL)与RTC的APB时钟同步</td></tr><tr><td>RTC_GetFlagStatus</td><td>检查指定的RTC标志位设置与否</td></tr><tr><td>RTC_ClearFlag</td><td>清除RTC的待处理标志位</td></tr><tr><td>RTC_GetITStatus</td><td>检查指定的RTC中断发生与否</td></tr><tr><td>RTC_ClearITPendingBit</td><td>清除RTC的中断待处理位</td></tr></table>

# 16.2.1 函数RTC_ITConfig

Table 391. 描述了函数RTC_ITConfig  
Table 391. 函数 RTC_ITConfig  

<table><tr><td>函数名</td><td>RTC_ITConfig</td></tr><tr><td>函数原形</td><td>void RTC_ITConfig(u16 RTC_IT, FunctionalState NewState)</td></tr><tr><td>功能描述</td><td>使能或者失能指定的 RTC 中断</td></tr><tr><td>输入参数 1</td><td>RTC_IT: 待使能或者失能的 RTC 中断源
参阅 Section: RTC_IT 查阅更多该参数允许取值范围</td></tr><tr><td>输入参数 2</td><td>NewState: RTC 中断的新状态
这个参数可以取: ENABLE 或者 DISABLE</td></tr><tr><td>输出参数</td><td>无</td></tr><tr><td>返回值</td><td>无</td></tr><tr><td>先决条件</td><td>在使用本函数前必须先调用函数 RTC_WaitForLastTask(), 等待标志位 RTOFF 被设置</td></tr><tr><td>被调用函数</td><td>无</td></tr></table>

# RTC_IT

输入参数RTC_IT使能或者失能RTC的中断。可以取下表的一个或者多个取值的组合作为该参数的值。

Table 392. RTC_IT 值  

<table><tr><td>RTC_IT</td><td>描述</td></tr><tr><td>RTC_IT_OW</td><td>溢出中断使能</td></tr><tr><td>RTC_IT_ALR</td><td>闹钟中断使能</td></tr><tr><td>RTC_IT_SEC</td><td>秒中断使能</td></tr></table>

例：

```c
/* Wait until last write operation on RTC registers is terminated */
RTC_WaitForLastTask();
/* Alarm interrupt enabled */
RTC_ITConfig(RTC_IT_ALR, ENABLE);
```

# 16.2.2 函数RTC_EnterConfigMode

Table 393. 描述了函数RTC_EnterConfigMode  
Table 393. 函数 RTC_EnterConfigMode  

<table><tr><td>函数名</td><td>RTC_EnterConfigMode</td></tr><tr><td>函数原形</td><td>void RTC_EnterConfigMode(void)</td></tr><tr><td>功能描述</td><td>进入RTC配置模式</td></tr><tr><td>输入参数</td><td>无</td></tr><tr><td>输出参数</td><td>无</td></tr><tr><td>返回值</td><td>无</td></tr><tr><td>先决条件</td><td>无</td></tr><tr><td>被调用函数</td><td>无</td></tr></table>

例：

```txt
/\*Enable the configuration mode \*/ RTC_EnterConfigMode();
```

# 16.2.3 函数RTC_ExitConfigMode

Table 394. 描述了函数RTC ExitingConfigMode  
Table 394. 函数 RTC_ExitConfigMode  

<table><tr><td>函数名</td><td>RTC_ExitConfigMode</td></tr><tr><td>函数原形</td><td>void RTC_ExitConfigMode(void)</td></tr><tr><td>功能描述</td><td>退出RTC配置模式</td></tr><tr><td>输入参数</td><td>无</td></tr><tr><td>输出参数</td><td>无</td></tr><tr><td>返回值</td><td>无</td></tr><tr><td>先决条件</td><td>无</td></tr><tr><td>被调用函数</td><td>无</td></tr></table>

例：
/* Exit the configuration mode */
RTC_ExitConfigMode();

# 16.2.4 函数RTC_GetCounter

Table 395. 描述了函数RTC_GetCounter  
Table 395. 函数 RTC_GetCounter  

<table><tr><td>函数名</td><td>RTC_GetCounter</td></tr><tr><td>函数原形</td><td>u32 RTC_GetCounter(void)</td></tr><tr><td>功能描述</td><td>获取RTC计数器的值</td></tr><tr><td>输入参数</td><td>无</td></tr><tr><td>输出参数</td><td>无</td></tr><tr><td>返回值</td><td>RTC计数器的值</td></tr><tr><td>先决条件</td><td>无</td></tr><tr><td>被调用函数</td><td>无</td></tr></table>

例：
/* Gets the counter value */
u32 RTCCounterValue;
RTCCounterValue = RTC_GetCounter();

# 16.2.5 函数RTC_SetCounter

Table 396. 描述了函数RTC_SetCounter  
Table 396. 函数 RTC_SetCounter  

<table><tr><td>函数名</td><td>RTC_SetCounter</td></tr><tr><td>函数原形</td><td>void RTC_SetCounter(u32 CounterValue)</td></tr><tr><td>功能描述</td><td>设置RTC计数器的值</td></tr><tr><td>输入参数</td><td>CounterValue:新的RTC计数器值</td></tr><tr><td>输出参数</td><td>无</td></tr><tr><td>返回值</td><td>无</td></tr><tr><td>先决条件</td><td>在使用本函数前必须先调用函数RTC_WaitForLastTask(),等待标志位RTOFF被设置</td></tr><tr><td>被调用函数</td><td>RTC_EnterConfigMode()
RTC_ExitConfigMode()</td></tr></table>

例：

```c
/* Wait until last write operation on RTC registers is terminated */
RTC_WaitForLastTask();
/* Sets Counter value to 0xFFFF5555 */
RTC_SetCounter(0xFFFF5555);
```

# 16.2.6 函数RTC_SetPrescaler

Table 397. 描述了函数RTC_SetPrescaler  
Table 397. 函数 RTC_SetPrescaler  

<table><tr><td>函数名</td><td>RTC_SetPrescaler</td></tr><tr><td>函数原形</td><td>void RTC_SetPrescaler(u32 PrescalerValue)</td></tr><tr><td>功能描述</td><td>设置RTC预分频的值</td></tr><tr><td>输入参数</td><td>PrescalerValue:新的RTC预分频值</td></tr><tr><td>输出参数</td><td>无</td></tr><tr><td>返回值</td><td>无</td></tr><tr><td>先决条件</td><td>在使用本函数前必须先调用函数RTC_WaitForLastTask(),等待标志位RTOFF被设置</td></tr><tr><td>被调用函数</td><td>RTC_EnterConfigMode()
RTC_ExitConfigMode()</td></tr></table>

例：

```c
/* Wait until last write operation on RTC registers is terminated */
RTC_WaitForLastTask();
/* Sets Prescaler value to 0x7A12 */
RTC_SetPrescaler(0x7A12);
```

# 16.2.7 函数RTC_SetAlarm

Table 398. 描述了函数RTC_SetAlarm  
Table 398. 函数 RTC_SetAlarm  

<table><tr><td>函数名</td><td>RTC_SetAlarm</td></tr><tr><td>函数原形</td><td>void RTC_SetAlarm(u32 AlarmValue)</td></tr><tr><td>功能描述</td><td>设置RTC闹钟的值</td></tr><tr><td>输入参数</td><td>AlarmValue:新的RTC闹钟值</td></tr><tr><td>输出参数</td><td>无</td></tr><tr><td>返回值</td><td>无</td></tr><tr><td>先决条件</td><td>在使用本函数前必须先调用函数RTC_WaitForLastTask(),等待标志位RTOFF被设置</td></tr><tr><td>被调用函数</td><td>RTC_EnterConfigMode()
RTC_ExitConfigMode()</td></tr></table>

例：

```c
/* Wait until last write operation on RTC registers is terminated */
RTC_WaitForLastTask();
/* Sets Alarm value to 0xFFFFFF */
RTC_SetAlarm(0xFFFFFF);
```

# 16.2.8 函数RTC_GetDivider

Table 399. 描述了函数RTC_GetDivider  
Table 399. 函数 RTC_GetDivider  

<table><tr><td>函数名</td><td>RTC_GetDivider</td></tr><tr><td>函数原形</td><td>u32 RTC_GetDivider(void)</td></tr><tr><td>功能描述</td><td>获取RTC预分频分频因子的值</td></tr><tr><td>输入参数</td><td>无</td></tr><tr><td>输出参数</td><td>无</td></tr><tr><td>返回值</td><td>RTC预分频分频因子的值</td></tr><tr><td>先决条件</td><td>无</td></tr><tr><td>被调用函数</td><td>无</td></tr></table>

例：

```javascript
/\*Gets the current RTC Divider value \*/ u32 RTCDividerValue; RTCDividerValue  $=$  RTC_Getdivider();
```

# 16.2.9 函数RTC_WaitForLastTask

Table 400. 描述了函数RTC_WaitForLastTask

Table 400. 函数 RTC_WaitForLastTask  

<table><tr><td>函数名</td><td>RTC_WaitForLastTask</td></tr><tr><td>函数原形</td><td>void RTC_WaitForLastTask(void)</td></tr><tr><td>功能描述</td><td>等待最近一次对RTC寄存器的写操作完成</td></tr><tr><td>输入参数</td><td>无</td></tr><tr><td>输出参数</td><td>无</td></tr><tr><td>返回值</td><td>无</td></tr><tr><td>先决条件</td><td>无</td></tr><tr><td>被调用函数</td><td>无</td></tr></table>

```c
例：
/* Wait until last write operation on RTC registers is terminated */
RTC_WaitForLastTask();
/* Sets Alarm value to 0x10 */
RTC_SetAlarm(0x10);
```

# 16.2.10 函数RTC_WaitForSynchro

Table 401. 描述了函数RTC_WaitForSynchro

Table 401. 函数 RTC_WaitForSynchro  

<table><tr><td>函数名</td><td>RTC_WaitForSynchro</td></tr><tr><td>函数原形</td><td>void RTC_WaitForSynchro(void)</td></tr><tr><td>功能描述</td><td>等待最近一次对RTC寄存器的写操作完成</td></tr><tr><td>输入参数</td><td>无</td></tr><tr><td>输出参数</td><td>无</td></tr><tr><td>返回值</td><td>无</td></tr><tr><td>先决条件</td><td>无</td></tr><tr><td>被调用函数</td><td>无</td></tr></table>

```txt
例：
/* Wait until the RTC registers are synchronized with RTC APB clock */
RTC_WaitForSynchro();
```

# 16.2.11 函数RTC_GetFlagStatus

Table 402. 描述了函数RTC_GetFlagStatus

Table 402. 函数 RTC_GetFlagStatus  

<table><tr><td>函数名</td><td>RTC_GetFlagStatus</td></tr><tr><td>函数原形</td><td>FlagStatus RTC_GetFlagStatus(u16 RTC_FLAG)</td></tr><tr><td>功能描述</td><td>检查指定的 RTC 标志位设置与否</td></tr><tr><td>输入参数 2</td><td>RTC_FLAG: 待检查的 RTC 标志位
参阅 Section: RTC_FLAG 查阅更多该参数允许取值范围</td></tr><tr><td>输出参数</td><td>无</td></tr><tr><td>返回值</td><td>RTC_FLAG 的新状态 (SET 或者 RESET)</td></tr><tr><td>先决条件</td><td>无</td></tr><tr><td>被调用函数</td><td>无</td></tr></table>

# RTC_FLAG

Table 403. 给出了所有可以被函数RTC_GetFlagStatus检查的标志位列表

Table 403. RTC_FLAG 值  

<table><tr><td>RTC_FLAG</td><td>描述</td></tr><tr><td>RTC_FLAG_RTOFF</td><td>RTC操作OFF标志位</td></tr><tr><td>RTC_FLAG_RSF</td><td>寄存器已同步标志位</td></tr><tr><td>RTC_FLAG_OW</td><td>溢出中断标志位</td></tr><tr><td>RTC_FLAG_ALR</td><td>闹钟中断标志位</td></tr><tr><td>RTC_FLAG_SEC</td><td>秒中断标志位</td></tr></table>

例：

/* Gets the RTC overflow interrupt status */

FlagStatus OverrunFlagStatus;

OverrunFlagStatus = RTC_GetFlagStatus(RTC_Flag_OW);

# 16.2.12 函数RTC_ClearFlag

Table 404. 描述了函数RTC_ClearFlag

Table 404. 函数 RTC_ClearFlag  

<table><tr><td>函数名</td><td>RTC_ClearFlag</td></tr><tr><td>函数原形</td><td>void RTC_ClearFlag(u16 RTC_FLAG)</td></tr><tr><td>功能描述</td><td>清除RTC的待处理标志位</td></tr><tr><td>输入参数</td><td>RTC_FLAG: 待清除的RTC标志位参阅Section:I2C_FLAG 查阅更多该参数允许取值范围注意:标志位RTC_FLAG_RTOFF不能用软件清除,标志位RTC_FLAG_RSF只有在APB复位,或者APB时钟停止后,才可以清除</td></tr><tr><td>输出参数</td><td>无</td></tr><tr><td>返回值</td><td>无</td></tr><tr><td>先决条件</td><td>在使用本函数前必须先调用函数RTC_WaitForLastTask(),等待标志位RTOFF被设置</td></tr><tr><td>被调用函数</td><td>无</td></tr></table>

例：

/* Wait until last write operation on RTC registers is terminated */ RTC WaitForLastTask();

/* Clears the RTC overflow flag */

RTC_ClearFlag(RTC_FLAG_OW);

# 16.2.13 函数RTC_GetITStatus

Table 405. 描述了函数RTC_GetITStatus

Table 405. 函数 RTC_GetITStatus  

<table><tr><td>函数名</td><td>RTC_GetITStatus</td></tr><tr><td>函数原形</td><td>ITStatus RTC_GetITStatus(u16 RTC_IT)</td></tr><tr><td>功能描述</td><td>检查指定的 RTC 中断发生与否</td></tr><tr><td>输入参数 2</td><td>RTC_IT: 待检查的 RTC 中断
参阅 Section: RTC_IT 查阅更多该参数允许取值范围</td></tr><tr><td>输出参数</td><td>无</td></tr><tr><td>返回值</td><td>RTC_IT 的新状态 (SET 或者 RESET)</td></tr><tr><td>先决条件</td><td>无</td></tr><tr><td>被调用函数</td><td>无</td></tr></table>

例：  
/\*Gets the RTC Second interrupt status \*/ ITStatus SecondITStatus; SecondITStatus  $=$  RTC_GetITStatus(RTC_IT_SEC);

# 16.2.14 函数RTC_ClearITPendingBit

Table 406. 描述了函数RTC_ClearITPendingBit

Table 406. 函数 RTC_ClearITPendingBit  

<table><tr><td>函数名</td><td>RTC_ClearITPendingBit</td></tr><tr><td>函数原形</td><td>ITStatus RTC_GetITStatus(u16 RTC_IT)</td></tr><tr><td>功能描述</td><td>清除RTC的中断待处理位</td></tr><tr><td>输入参数2</td><td>RTC_IT: 待清除的RTC中断待处理位
参阅Section: RTC_IT查阅更多该参数允许取值范围</td></tr><tr><td>输出参数</td><td>无</td></tr><tr><td>返回值</td><td>无</td></tr><tr><td>先决条件</td><td>在使用本函数前必须先调用函数RTC_WaitForLastTask(),等待标志位RTOFF被设置</td></tr><tr><td>被调用函数</td><td>无</td></tr></table>

例：  
/\*Wait until last write operation on RTC registers is terminated \*/ RTCWaitForLastTask(); /ClearstheRTCSecondinterrupt\*/ RTC_ClearITPendingBit(RTC_IT_SEC);

# 17 串行外设接口（SPI）

串行外设接口（SPI）提供与外部设备进行同步串行通讯的功能。接口可以被设置工作在主模式或者从模式。

Section 17.1 SPI 寄存器结构描述了固件函数库所使用的数据结构，Section 17.2 固件库函数介绍了函数库里的所有函数。

# 17.1 SPI寄存器结构

SPI 寄存器结构，SPI_TypeDeff，在文件“stm32f10x_map.h”中定义如下：

```txt
typedef struct  
{  
vu16 CR1;  
u16 RESERVED0;  
vu16 CR2;  
u16 RESERVED1;  
vu16 SR;  
u16 RESERVED2;  
vu16 DR;  
u16 RESERVED3;  
vu16 CRCPR;  
u16 RESERVED4;  
vu16 RXCRCR;  
u16 RESERVED5;  
vu16 TXCRCR;  
u16 RESERVED6;  
} SPI_TYPEDef;  
Table 407.例举了SPI所有寄存器
```

Table 407. SPI 寄存器  

<table><tr><td>寄存器</td><td>描述</td></tr><tr><td>CR1</td><td>SPI 控制寄存器 1</td></tr><tr><td>CR2</td><td>SPI 控制寄存器 2</td></tr><tr><td>SR</td><td>SPI 状态寄存器</td></tr><tr><td>DR</td><td>SPI 数据寄存器</td></tr><tr><td>CRCPR</td><td>SPI CRC 多项式寄存器</td></tr><tr><td>RxCRCR</td><td>SPI 接收 CRC 寄存器</td></tr><tr><td>TxCRCR</td><td>SPI 发送 CRC 寄存器</td></tr></table>

2个SPI外设声明于文件“stm32f10x_map.h”：

```c
define PERIPH_BASE((u32)0x40000000)  
#define APB1PERIPH_BASE PERIPH_BASE  
#define APB2PERIPH_BASE (PERIPH_BASE + 0x10000)  
#define AHBPERIPH_BASE (PERIPH_BASE + 0x20000)  
...  
#define SPI1_BASE (APB2PERIPH_BASE + 0x3000)  
#define SPI2_BASE (APB1PERIPH_BASE + 0x3800)  
...  
#ifndef DEBUG  
...  
#ifndef_SPI1  
#define_SPI1 ((SPI_TYPEDef *) SPI1_BASE)  
#endif /*_SPI1 */  
#ifndef_SPI2  
#define_SPI2 ((SPI_TYPEDef *) SPI2_BASE)  
#endif /*_SPI2 */
```

ST

译文英文原版为UM0427 Oct. 2007 Rev 2, 译文仅供参考，与英文版冲突的，以英文版为准

SPI  
```c
else/\*DEBUG\*/   
ifdef_SPI1   
EXTSPITypeDef\*SPI1; #endif/\*SPI1\*/   
#ifdef_SPI2   
EXTSPITypeDef\*SPI2; #endif/\*SPI2\*/   
endif   
使用Debug模式时，初始化指针SPI1, SPI2于文件"stm32f10x_lib.c": #ifdef_SPI1   
SPI1  $\equiv$  (SPITypeDef\*) SPI1_BASE; #endif/\*SPI1\*/   
#ifdef SPI2   
SPI2  $\equiv$  (SPITypeDef\*) SPI2_BASE; #endif/\*SPI2\*/
```

为了访问 SPI 寄存器，,_SPI, _SPI1, _SPI2 必须在文件“stm32f10x_conf.h”中定义如下：

```txt
define _SPI  
#define _SPI1  
#define _SPI2  
...
```

# 17.2 SPI库函数

Table 408. 例举了SPI的库函数  
Table 408. SPI 库函数  

<table><tr><td>函数名</td><td>描述</td></tr><tr><td>SPI_DeInit</td><td>将外设SPIx寄存器重设为缺省值</td></tr><tr><td>SPI_Init</td><td>根据SPI_InitStruct中指定的参数初始化外设SPIx寄存器</td></tr><tr><td>SPI架构Init</td><td>把SPI架构InitStruct中的每一个参数按缺省值填入</td></tr><tr><td>SPI_Cmd</td><td>使能或者失能SPI外设</td></tr><tr><td>SPI_ITConfig</td><td>使能或者失能指定的SPI中断</td></tr><tr><td>SPI_DMAcd</td><td>使能或者失能指定SPI的DMA请求</td></tr><tr><td>SPI_SendData</td><td>通过外设SPIx发送一个数据</td></tr><tr><td>SPI_ReceiveData</td><td>返回通过SPIx最近接收的数据</td></tr><tr><td>SPI_DMLastTransferCmd</td><td>使下一次DMA传输为最后一次传输</td></tr><tr><td>SPI_NSSInternalSoftwareConfig</td><td>为选定的SPI软件配置内部NSS管脚</td></tr><tr><td>SPI_SSOutputCmd</td><td>使能或者失能指定的SPISS输出</td></tr><tr><td>SPI_DataSizeConfig</td><td>设置选定的SPI数据大小</td></tr><tr><td>SPI_TransmitCRC</td><td>发送SPIx的CRC值</td></tr><tr><td>SPI CalculateCRC</td><td>使能或者失能指定SPI的传输字CRC值计算</td></tr><tr><td>SPI_GetCRC</td><td>返回指定SPI的发送或者接受CRC寄存器值</td></tr><tr><td>SPI_GetCRCPolynomial</td><td>返回指定SPI的CRC多项式寄存器值</td></tr><tr><td>SPI_BiDirectionalLineConfig</td><td>选择指定SPI在双向模式下的数据传输方向</td></tr><tr><td>SPI_GetFlagStatus</td><td>检查指定的SPI标志位设置与否</td></tr><tr><td>SPI_ClearFlag</td><td>清除SPIx的待处理标志位</td></tr><tr><td>SPI_GetITStatus</td><td>检查指定的SPI中断发生与否</td></tr><tr><td>SPI_ClearITPendingBit</td><td>清除SPIx的中断待处理位</td></tr></table>

# 17.2.1 函数SPI_DeInit

Table 409. 描述了函数 SPI_DeInit  
Table 409. 函数 SPI_DeInit  

<table><tr><td>函数名</td><td>SPI_DeInit</td></tr><tr><td>函数原形</td><td>void SPI_DeInit(SPI_TYPEDef* SPIx)</td></tr><tr><td>功能描述</td><td>将外设SPIx寄存器重设为缺省值</td></tr><tr><td>输入参数</td><td>SPIx: x可以是1或者2,来选择SPI外设</td></tr><tr><td>输出参数</td><td>无</td></tr><tr><td>返回值</td><td>无</td></tr><tr><td>先决条件</td><td>无</td></tr><tr><td>被调用函数</td><td>对SPI1,RCC_APB2PeriphClockCmd().对SPI2,RCC_APB1PeriphClockCmd().</td></tr></table>

```txt
例：  
/* Deinitialize the SPI2 */  
SPI_DeInit(SPI2);
```

# 17.2.2 函数SPI_Init

Table 410. 描述了函数 SPI_Init  
Table 410. 函数 SPI_Init  

<table><tr><td>函数名</td><td>SPI_Init</td></tr><tr><td>函数原形</td><td>void SPI_Init(SPI_TYPEDef* SPIx, SPI_InitTypeDef* SPI_InitStruct)</td></tr><tr><td>功能描述</td><td>根据SPI_InitStruct中指定的参数初始化外设SPIx寄存器</td></tr><tr><td>输入参数1</td><td>SPIx: x可以是1或者2,来选择SPI外设</td></tr><tr><td>输入参数2</td><td>SPI_InitStruct: 指向结构SPI_InitTypeDef的指针,包含了外设SPI的配置信息参阅Section: SPI_InitTypeDef 查阅更多该参数允许取值范围</td></tr><tr><td>输出参数</td><td>无</td></tr><tr><td>返回值</td><td>无</td></tr><tr><td>先决条件</td><td>无</td></tr><tr><td>被调用函数</td><td>无</td></tr></table>

# SPI_InitTypeDef structure

SPI_InitTypeDef 定义于文件“stm32f10xSPI.h”：

```c
typedef struct   
{   
u16 SPI_Direction;   
u16 SPI_Mode;   
u16 SPI_DataSize;   
u16 SPI_CPOL;   
u16 SPI_CPHA;   
u16 SPI_NSS;   
u16 SPI_BaudRatePrescaler;   
u16 SPI_FirstBit;   
u16 SPI_CRCPolynomial; } SPI_InitTypeDef;
```

# SPI_Direction

SPI_Direction 设置了 SPI 单向或者双向的数据模式。见 Table 411. 查阅该参数可取的值。

Table 411. SPI_Mode 值  

<table><tr><td>SPI_Mode</td><td>描述</td></tr><tr><td>SPI_Direction_2Lines_FullDuplex</td><td>SPI设置为双线双向全双工</td></tr><tr><td>SPI_Direction_2Lines_RxOnly</td><td>SPI设置为双线单向接收</td></tr><tr><td>SPI_Direction_1Line_Rx</td><td>SPI设置为单线双向接收</td></tr><tr><td>SPI_Direction_1Line_Tx</td><td>SPI设置为单线双向发送</td></tr></table>

# SPI_Mode

SPI_Mode 设置了 SPI 工作模式。见 Table 412. 查阅该参数可取的值。

Table 412. SPI_Mode 值  

<table><tr><td>SPI_Mode</td><td>描述</td></tr><tr><td>SPI_Mode_Master</td><td>设置为主 SPI</td></tr><tr><td>SPI_Mode_Slave</td><td>设置为从 SPI</td></tr></table>

# SPI_DataSize

SPI_DataSize 设置了 SPI 的数据大小。见 Table 413. 查阅该参数可取的值。

Table 413. SPI_DataSize 值  

<table><tr><td>SPI_DataSize</td><td>描述</td></tr><tr><td>SPI_DataSize_16b</td><td>SPI 发送接收 16 位帧结构</td></tr><tr><td>SPI_DataSize_8b</td><td>SPI 发送接收 8 位帧结构</td></tr></table>

# SPI_CPOL

SPI_CPOL选择了串行时钟的稳态。见Table414.查阅该参数可取的值。

Table 414. SPI_SPI_CPOL 值  

<table><tr><td>SPI_CPOL</td><td>描述</td></tr><tr><td>SPI_CPOL_High</td><td>时钟悬空高</td></tr><tr><td>SPI_CPOL_Low</td><td>时钟悬空低</td></tr></table>

# SPI_CPHA

SPI_CPHA设置了位捕获的时钟活动沿。见Table415.查阅该参数可取的值。

Table 415. SPI_SPI_CPHA 值  

<table><tr><td>SPI_CPHA</td><td>描述</td></tr><tr><td>SPI_CPHA_2Edge</td><td>数据捕获于第二个时钟沿</td></tr><tr><td>SPI_CPHA_1Edge</td><td>数据捕获于第一个时钟沿</td></tr></table>

# SPI_NSS

SPI_NSS 指定了 NSS 信号由硬件（NSS 管脚）还是软件（使用 SSI 位）管理。见 Table 416. 查阅该参数可取的值。

Table 416. SPI_NSS 值  

<table><tr><td>SPI_NSS</td><td>描述</td></tr><tr><td>SPI_NSS_Hard</td><td>NSS由外部管脚管理</td></tr><tr><td>SPI_NSS_Soft</td><td>内部NSS信号有SSI位控制</td></tr></table>

# SPI_BaudRatePrescaler

SPI_BaudRatePrescaler用来定义波特率预分频的值，这个值用以设置发送和接收的SCK时钟。见Table417.查阅该参数可取的值。

Table 417. SPI_BaudRatePrescaler 值  

<table><tr><td>SPI_NSS</td><td>描述</td></tr><tr><td>SPI_BaudRatePrescaler2</td><td>波特率预分频值为2</td></tr><tr><td>SPI_BaudRatePrescaler4</td><td>波特率预分频值为4</td></tr></table>

SPI  

<table><tr><td>SPI_BaudRatePrescaler8</td><td>波特率预分频值为8</td></tr><tr><td>SPI_BaudRatePrescaler16</td><td>波特率预分频值为16</td></tr><tr><td>SPI_BaudRatePrescaler32</td><td>波特率预分频值为32</td></tr><tr><td>SPI_BaudRatePrescaler64</td><td>波特率预分频值为64</td></tr><tr><td>SPI_BaudRatePrescaler128</td><td>波特率预分频值为128</td></tr><tr><td>SPI_BaudRatePrescaler256</td><td>波特率预分频值为256</td></tr></table>

注意：通讯时钟由主SPI的时钟分频而得，不需要设置从SPI的时钟。

# SPI FirstBit

SPI_FirstBit 指定了数据传输从 MSB 位还是 LSB 位开始。见 Table 418. 查阅该参数可取的值。

Table 418. SPI_FirstBit 值  

<table><tr><td>SPI_FirstBit</td><td>描述</td></tr><tr><td>SPI_FisrtBit_MSB</td><td>数据传输从MSB位开始</td></tr><tr><td>SPI_FisrtBit_LSB</td><td>数据传输从LSB位开始</td></tr></table>

# SPI_CRCPolynomial

SPI_CRPCoNomial 定义了用于 CRC 值计算的多项式。

例：

/* Initialize the SPI1 according to the SPI InitStructure members */

SPI InitTypeDef SPI InitStructure;

SPI_InitStructure.SPI_Direction = SPI_Direction_2Lines_FullDuplex;

SPI InitStructure.SPI Mode = SPI Mode Master;

SPI InitStructure.SPI DatSize = SPI DatSize 16b;

SPI InitStructure.SPI CPOL = SPI CPOL Low;

SPI_InitStructure.SPI_CPHA = SPI_CPHA_2Edge;

SPI_InitStructure.SPINSS = SPI_NSS_Soft;

SPI InitStructure.SPI BaudRatePrescaler =

SPI-BaudRatePrescaler128;

SPI_InitStructure.SPI_FirstBit = SPI_FirstBit_MSB;

SPI InitStructure.SPI CRCPolynomial = 7;

SPI Init(SPI1, &SPI InitStructure);

# 17.2.3 函数SPI_ConstructInit

Table 419. 描述了函数SPIStructInit  
Table 419. 函数 SPIStructInit  

<table><tr><td>函数名</td><td>SPI_StructInit</td></tr><tr><td>函数原形</td><td>void SPI_StructInit(SPI_InitTypeDef* SPI_InitStruct)</td></tr><tr><td>功能描述</td><td>把SPI_InitStruct中的每一个参数按缺省值填入</td></tr><tr><td>输入参数</td><td>SPI_InitStruct: 指向结构SPI_InitTypeDef的指针, 待初始化</td></tr><tr><td>输出参数</td><td>无</td></tr><tr><td>返回值</td><td>无</td></tr><tr><td>先决条件</td><td>无</td></tr><tr><td>被调用函数</td><td>无</td></tr></table>

Table 420. 给出了SPI_InitStruct各个成员的缺省值

Table 420. SPI_InitStruct 缺省值  

<table><tr><td>成员</td><td>缺省值</td></tr><tr><td>SPI_Direction</td><td>SPI_Direction_2Lines_FullDuplex</td></tr><tr><td>SPI_Mode</td><td>SPI_Mode_Slave</td></tr><tr><td>SPI_DataSize</td><td>SPI_DataSize_8b</td></tr><tr><td>SPI_CPOL</td><td>SPI_CPOL_Low</td></tr><tr><td>SPI_CPHA</td><td>SPI_CPHA_1Edge</td></tr><tr><td>SPI_NSS</td><td>SPI_NSS_Hard</td></tr><tr><td>SPI_BaudRatePrescaler</td><td>SPI_BaudRatePrescaler_2</td></tr><tr><td>SPI_FirstBit</td><td>SPI_FirstBit_MSB</td></tr><tr><td>SPI_CRCPolynomial</td><td>7</td></tr></table>

例：

```c
/\* Initialize an SPI_InitTypeDef structure \*/ SPI_InitTypeDef SPI_InitStructure; SPISTRUCTInit(&SPI_InitStructure);
```

# 17.2.4 函数SPI_Cmd

Table 421. 描述了函数SPI_Cmd  
Table 421. 函数 SPI_Cmd  

<table><tr><td>函数名</td><td>SPI_Cmd</td></tr><tr><td>函数原形</td><td>void SPI_Cmd(SPI_TYPEDef* SPIx, FunctionalState NewState)</td></tr><tr><td>功能描述</td><td>使能或者失能 SPI 外设</td></tr><tr><td>输入参数 1</td><td>SPIx: x 可以是 1 或者 2 , 来选择 SPI 外设</td></tr><tr><td>输入参数 2</td><td>NewState: 外设 SPIx 的新状态
这个参数可以取: ENABLE 或者 DISABLE</td></tr><tr><td>输出参数</td><td>无</td></tr><tr><td>返回值</td><td>无</td></tr><tr><td>先决条件</td><td>无</td></tr><tr><td>被调用函数</td><td>无</td></tr></table>

例：

```javascript
/\*EnableSPI1\*/ SPI_Cmd(SPI1，ENABLE);
```

# 17.2.5 函数SPI_ITConfig

Table 422. 描述了函数SPI_ITConfig  
Table 422. 函数 SPI_ITConfig  

<table><tr><td>函数名</td><td>SPI_ITConfig</td></tr><tr><td>函数原形</td><td>void SPI_ITConfig(SPI_TYPEDef* SPIx, u16 SPI_IT, FunctionalState NewState)</td></tr><tr><td>功能描述</td><td>使能或者失能指定的 SPI 中断</td></tr><tr><td>输入参数 1</td><td>SPIx: x 可以是 1 或者 2, 来选择 SPI 外设</td></tr><tr><td>输入参数 2</td><td>SPI_IT: 待使能或者失能的 SPI 中断源
参阅 Section: SPI_IT 查阅更多该参数允许取值范围</td></tr><tr><td>输入参数 3</td><td>NewState: SPIx 中断的新状态
这个参数可以取: ENABLE 或者 DISABLE</td></tr><tr><td>输出参数</td><td>无</td></tr><tr><td>返回值</td><td>无</td></tr><tr><td>先决条件</td><td>无</td></tr><tr><td>被调用函数</td><td>无</td></tr></table>

# SPI_IT

输入参数SPI_IT使能或者失能SPI的中断。可以取下表的一个或者多个取值的组合作为该参数的值。

Table 423. SPI_IT 值  

<table><tr><td>SPI_IT</td><td>描述</td></tr><tr><td>SPI_IT_TXE</td><td>发送缓存空中断屏蔽</td></tr><tr><td>SPI_IT_RXNE</td><td>接收缓存非空中断屏蔽</td></tr><tr><td>SPI_IT_ERR</td><td>错误中断屏蔽</td></tr></table>

例：

# ST

译文英文原版为UM0427 Oct. 2007 Rev 2, 译文仅供参考，与英文版冲突的，以英文版为准

/* Enable SPI2 Tx buffer empty interrupt */
SPI_ITConfig(SPI2, SPI_IT_TXE, ENABLE);

# 17.2.6 函数SPI_DMAcmd

Table 424. 描述了函数SPI_DMACmd  
Table 424. 函数 SPI_DMACmd  

<table><tr><td>函数名</td><td>SPI_DMAcmd</td></tr><tr><td>函数原形</td><td>void SPI_DMAcmd(SPI_TYPEDef* SPIx, u16 SPI_DMAReq, FunctionalState NewState)</td></tr><tr><td>功能描述</td><td>使能或者失能指定 SPI 的 DMA 请求</td></tr><tr><td>输入参数 1</td><td>SPIx: x 可以是 1 或者 2, 来选择 SPI 外设</td></tr><tr><td>输入参数 2</td><td>SPI_DMAReq: 待使能或者失能的 SPI DMA 传输请求参阅 Section: SPI_DMAReq 查阅更多该参数允许取值范围</td></tr><tr><td>输入参数 3</td><td>NewState: SPIx DMA 传输的新状态这个参数可以取: ENABLE 或者 DISABLE</td></tr><tr><td>输出参数</td><td>无</td></tr><tr><td>返回值</td><td>无</td></tr><tr><td>先决条件</td><td>无</td></tr><tr><td>被调用函数</td><td>无</td></tr></table>

# SPI_DMAReq

SPI_DMAReq 使能或者失能 SPI Tx 和/或 SPI Rx 的 DMA 传输请求。见 Table 425. 查阅该参数可取的值。

Table 425. SPI_DMAReq 值  

<table><tr><td>SPI_DMAReq</td><td>描述</td></tr><tr><td>SPI_DMAReq_Tx</td><td>选择 Tx 缓存 DMA 传输请求</td></tr><tr><td>SPI_DMAReq_Rx</td><td>选择 Rx 缓存 DMA 传输请求</td></tr></table>

例：

/\*EnableSPI2RxbufferDMAtransferrequest\*/ SPI_DMACmd(SPI2，SPI_DMReq_Rx，ENABLE);

# 17.2.7 函数SPI_SendData

Table 426. 描述了函数SPI_SendData  
Table 426. 函数 SPI_SendData  

<table><tr><td>函数名</td><td>SPI_SendDate</td></tr><tr><td>函数原形</td><td>void SPI_SendDate(SPI_TYPEDef* SPIx, u16 Data)</td></tr><tr><td>功能描述</td><td>通过外设 SPIx 发送一个数据</td></tr><tr><td>输入参数 1</td><td>SPIx: x 可以是 1 或者 2, 来选择 SPI 外设</td></tr><tr><td>输入参数 2</td><td>Data: 待发送的数据</td></tr><tr><td>输出参数</td><td>无</td></tr><tr><td>返回值</td><td>无</td></tr><tr><td>先决条件</td><td>无</td></tr><tr><td>被调用函数</td><td>无</td></tr></table>

例：

/\* Send 0xA5 through the SPI1 peripheral \*/ SPI_SendData(SPI1, 0xA5);

# 17.2.8 函数SPI_ReceiveData

Table 427. 描述了函数SPI_ReceiveData  
Table 427. 函数 SPI_ReceiveData  

<table><tr><td>函数名</td><td>SPI_ReceiveData</td></tr><tr><td>函数原形</td><td>u16 SPI_ReceiveData(SPI_TYPEDef* SPIx)</td></tr><tr><td>功能描述</td><td>返回通过 SPIx 最近接收的数据</td></tr><tr><td>输入参数</td><td>SPIx: x 可以是 1 或者 2, 来选择 SPI 外设</td></tr><tr><td>输出参数</td><td>无</td></tr><tr><td>返回值</td><td>接收到的字</td></tr><tr><td>先决条件</td><td>无</td></tr><tr><td>被调用函数</td><td>无</td></tr></table>

例：
/* Read the most recent data received by the SPI2 peripheral */
u16 ReceivedData;
ReceivedData = SPI_ReceiveData(SPI2);

# 17.2.9 函数SPI_NSSInternalSoftwareConfig

Table 428. 描述了函数SPI_NSSInternalSoftwareConfig  
Table 428. 函数 SPI_NSSInternalSoftwareConfig  

<table><tr><td>函数名</td><td>SPI_NSSInternalSoftwareConfig</td></tr><tr><td>函数原形</td><td>void SPI_NSSInternalSoftwareConfig(SPI_TYPEDef* SPIx, u16 SPI_NSSInternalSoft)</td></tr><tr><td>功能描述</td><td>为选定的 SPI 软件配置内部 NSS 管脚</td></tr><tr><td>输入参数 1</td><td>SPIx: x 可以是 1 或者 2 , 来选择 SPI 外设</td></tr><tr><td>输入参数 2</td><td>SPI_NSSInternalSoft: SPI NSS 内部状态参阅 Section: SPI_NSSInternalSoft 查阅更多该参数允许取值范围</td></tr><tr><td>输出参数</td><td>无</td></tr><tr><td>返回值</td><td>无</td></tr><tr><td>先决条件</td><td>无</td></tr><tr><td>被调用函数</td><td>无</td></tr></table>

# SPI NSSInternalSoft

SPI_NSSInternalSoft 内部设置或者重置 NSS 管脚。见 Table 429. 查阅该参数可取的值。

Table 429. SPI_DMAReq 值  

<table><tr><td>SPI_NSSInternalSoft</td><td>描述</td></tr><tr><td>SPI_NSSInternalSoft_Set</td><td>内部设置 NSS 管脚</td></tr><tr><td>SPI_NSSInternalSoft_Set Reset</td><td>内部重置 NSS 管脚</td></tr></table>

/\* Set internally by software the SPI1 NSS pin \*/ SPI NSSInternalSoftwareConfig(SPI1, SPI_NSSInternalSoft_Set); /\* Reset internally by software the SPI2 NSS pin \*/ SPI_NSSInternalSoftwareConfig(SPI2, SPI_NSSInternalSoft_Set);

例：

# 17.2.10 函数SPI_SSOutputCmd

Table 430. 描述了函数SPI_SSOutputCmd

Table 430. 函数 SPI_SSOutputCmd  

<table><tr><td>函数名</td><td>SPI_SSOutputCmd</td></tr><tr><td>函数原形</td><td>void SPI_SSOutputCmd(SPI_TYPEDef* SPIx, FunctionalState NewState)</td></tr><tr><td>功能描述</td><td>使能或者失能指定的 SPI SS 输出</td></tr><tr><td>输入参数1</td><td>SPIx: x 可以是 1 或者 2 , 来选择 SPI 外设</td></tr><tr><td>输入参数2</td><td>NewState: SPI SS 输出的新状态
这个参数可以取: ENABLE 或者 DISABLE</td></tr><tr><td>输出参数</td><td>无</td></tr><tr><td>返回值</td><td>无</td></tr><tr><td>先决条件</td><td>无</td></tr><tr><td>被调用函数</td><td>无</td></tr></table>

例：
/* Enable the SPI1 SS output: single master mode */
SPI_SSOutputCmd(SPI1, ENABLE);

# 17.2.11 函数SPI_DataSizeConfig

Table 431. 描述了函数SPI_DataSizeConfig

Table 431. 函数 SPI_DataSizeConfig  

<table><tr><td>函数名</td><td>SPI_DataSizeConfig</td></tr><tr><td>函数原形</td><td>void SPI_DataSizeConfig(SPI_TYPEDef* SPIx, u16 SPI_DatSize)</td></tr><tr><td>功能描述</td><td>设置选定的 SPI 数据大小</td></tr><tr><td>输入参数 1</td><td>SPIx: x 可以是 1 或者 2 , 来选择 SPI 外设</td></tr><tr><td>输入参数 2</td><td>SPI_DataSize: SPI 数据大小
参阅 Section: SPI_DataSize 查阅更多该参数允许取值范围</td></tr><tr><td>输出参数</td><td>无</td></tr><tr><td>返回值</td><td>无</td></tr><tr><td>先决条件</td><td>无</td></tr><tr><td>被调用函数</td><td>无</td></tr></table>

# SPI_DataSize

SPI_DataSize 设置 8 位或者 16 位数据帧结构。见 Table 432. 查阅该参数可取的值。

Table 432. SPI_DMAReq 值  

<table><tr><td>SPI_DataSize</td><td>描述</td></tr><tr><td>SPI_DataSize_8b</td><td>设置数据为8位</td></tr><tr><td>SPI_DataSize_16b</td><td>设置数据为16位</td></tr></table>

例：

```javascript
/\*Set8bitdataframeformatforSPI1\*/ SPI_DataSizeConfig(SPI1，SPI_DataSize_8b); /\*Set16bitdataframeformatforSPI2\*/ SPI_DataSizeConfig(SPI2，SPI_DataSize_16b);
```

# 17.2.12 函数SPI_TransmitCRC

Table 433. 描述了函数SPI_TransmitCRC  
Table 433. 函数 SPI_TransmitCRC  

<table><tr><td>函数名</td><td>SPI_TransmitCRC</td></tr><tr><td>函数原形</td><td>SPI_TransmitCRC(SPI_TYPEDef* SPIx, FunctionalState NewState)</td></tr><tr><td>功能描述</td><td>使能或者失能指定 SPI 的 CRC 传输</td></tr><tr><td>输入参数1</td><td>SPIx: x 可以是 1 或者 2 , 来选择 SPI 外设</td></tr><tr><td>输入参数2</td><td>NewState: SPIxCRC 传输的新状态
这个参数可以取: ENABLE 或者 DISABLE</td></tr><tr><td>输出参数</td><td>无</td></tr><tr><td>返回值</td><td>无</td></tr><tr><td>先决条件</td><td>无</td></tr><tr><td>被调用函数</td><td>无</td></tr></table>

例：  
/\* Enable the CRC transfer for SPI1 \*/ SPI_TransmitCRC(SPI1);

# 17.2.13 函数SPI_CalculateCRC

Table 434. 描述了函数SPI_CalculateCRC  
Table 434. 函数 SPI CalculateCRC  

<table><tr><td>函数名</td><td>SPI_CalculateCRC</td></tr><tr><td>函数原形</td><td>void SPI_CalculateCRC(SPI_TYPEDef* SPIx, FunctionalState NewState)</td></tr><tr><td>功能描述</td><td>使能或者失能指定 SPI 的传输字 CRC 值计算</td></tr><tr><td>输入参数 1</td><td>SPIx: x 可以是 1 或者 2, 来选择 SPI 外设</td></tr><tr><td>输入参数 2</td><td>NewState: SPIx 传输字 CRC 值计算的新状态
这个参数可以取: ENABLE 或者 DISABLE</td></tr><tr><td>输出参数</td><td>无</td></tr><tr><td>返回值</td><td>无</td></tr><tr><td>先决条件</td><td>无</td></tr><tr><td>被调用函数</td><td>无</td></tr></table>

例：  
/\* Enable the CRC calculation for the transferred bytes from SPI2 \*/ SPI_CalculatedCRC(SPI2, ENABLE);

# 17.2.14 函数SPI_GetCRC

Table 435. 描述了函数SPI_GetCRC

Table 435. 函数 SPI_GetCRC  

<table><tr><td>函数名</td><td>SPI_GetCRC</td></tr><tr><td>函数原形</td><td>u16 SPI_GetCRC(SPI_TYPEDef* Spix)</td></tr><tr><td>功能描述</td><td>返回指定 SPI 的 CRC 值</td></tr><tr><td>输入参数 1</td><td>SPIx: x 可以是 1 或者 2, 来选择 SPI 外设</td></tr><tr><td>输入参数 2</td><td>SPI_CRC: 待读取的 CRC 寄存器
参阅 Section: SPI_CRC 查阅更多该参数允许取值范围</td></tr><tr><td>输出参数</td><td>无</td></tr><tr><td>返回值</td><td>CRC 值</td></tr><tr><td>先决条件</td><td>无</td></tr><tr><td>被调用函数</td><td>无</td></tr></table>

# SPI_CRC

SPI_CRC 选择 SPI Rx 或者 SPI Tx 的 CRC 寄存器。见 Table 436. 查阅该参数可取的值。

Table 436. SPI_CRC 值  

<table><tr><td>SPI_CRC</td><td>描述</td></tr><tr><td>SPI_CRC_Tx</td><td>选择 Tx CRC 寄存器</td></tr><tr><td>SPI_CRC_Rx</td><td>选择 Rx CRC 寄存器</td></tr></table>

例：

/* Returns the SPI1 transmit CRC register */

u16 CRCValue;

CRCValue = SPI_GetCRC(SPI1, SPI_CRC_Tx);

# 17.2.15 函数SPI_GetCRCPolynomial

Table 437. 描述了函数SPI_GetCRCPolynomial

Table 437. 函数 SPI_GetCRCPolynomial  

<table><tr><td>函数名</td><td>SPI_GetCRCPolynomial</td></tr><tr><td>函数原形</td><td>u16 SPI_GetCRCPolynomial(SPI_TYPEDef* SPIx)</td></tr><tr><td>功能描述</td><td>返回指定 SPI 的 CRC 多项式寄存器值</td></tr><tr><td>输入参数</td><td>SPIx: x 可以是 1 或者 2, 来选择 SPI 外设</td></tr><tr><td>输出参数</td><td>无</td></tr><tr><td>返回值</td><td>CRC 多项式寄存器值</td></tr><tr><td>先决条件</td><td>无</td></tr><tr><td>被调用函数</td><td>无</td></tr></table>

例：

/* Returns the SPI2 CRC polynomial register */

u16 CRCPolyValue;

CRCPolyValue = SPI_GetCRCPolynomial(SPI2);

# 17.2.16 函数SPI_BiDirectionalLineConfig

Table 438. 描述了函数SPI_BiDirectionalLineConfig

Table 438. 函数 SPI_BiDirectionalLineConfig  

<table><tr><td>函数名</td><td>SPI_BiDirectionalLineConfig</td></tr><tr><td>函数原形</td><td>SPI_BiDirectionalLineConfig(SPI_TYPEDef* SPIx, u16 SPI_Direction)</td></tr><tr><td>功能描述</td><td>选择指定 SPI 在双向模式下的数据传输方向</td></tr><tr><td>输入参数 1</td><td>SPIx: x 可以是 1 或者 2 , 来选择 SPI 外设</td></tr><tr><td>输入参数 2</td><td>SPI_Direction: 待读取的 CRC 寄存器
参阅 Section: SPI_CRC 查阅更多该参数允许取值范围</td></tr><tr><td>输出参数</td><td>无</td></tr><tr><td>返回值</td><td>CRC 值</td></tr><tr><td>先决条件</td><td>无</td></tr><tr><td>被调用函数</td><td>无</td></tr></table>

# SPI_Direction

SPI_Direction选择SPI在双向模式下的数据传输方向。见Table 439. 查阅该参数可取的值。

Table 439. SPI CRC 值  

<table><tr><td>SPI_Direction</td><td>描述</td></tr><tr><td>SPI_Direction_Tx</td><td>选择 Tx 发送方向</td></tr><tr><td>SPI_Direction_Rx</td><td>选择 Rx 接受方向</td></tr></table>

例：

/* Set the SPI2 in bidirectional transmit only mode */

SPI_BiDirectionalLineConfig(SPI_Direction_Tx);

# 17.2.17 函数SPI_GetFlagStatus

Table 440. 描述了函数SPI_GetFlagStatus

Table 440. 函数 SPI_GetFlagStatus  

<table><tr><td>函数名</td><td>SPI_GetFlagStatus</td></tr><tr><td>函数原形</td><td>FlagStatus SPI_GetFlagStatus(SPI_TYPEDef* SPIx, u16 SPI_FLAG)</td></tr><tr><td>功能描述</td><td>检查指定的 SPI 标志位设置与否</td></tr><tr><td>输入参数 1</td><td>SPIx: x 可以是 1 或者 2 , 来选择 SPI 外设</td></tr><tr><td>输入参数 2</td><td>SPI_FLAG: 待检查的 SPI 标志位参阅 Section: SPI_FLAG 查阅更多该参数允许取值范围</td></tr><tr><td>输出参数</td><td>无</td></tr><tr><td>返回值</td><td>SPI_FLAG 的新状态 (SET 或者 RESET)</td></tr><tr><td>先决条件</td><td>无</td></tr><tr><td>被调用函数</td><td>无</td></tr></table>

# SPI_FLAG

Table 441. 给出了所有可以被函数SPI_GetFlagStatus检查的标志位列表

Table 441. SPI_FLAG 值  

<table><tr><td>SPI_FLAG</td><td>描述</td></tr><tr><td>SPI_FLAG_BSY</td><td>忙标志位</td></tr><tr><td>SPI_FLAG_OVR</td><td>超出标志位</td></tr><tr><td>SPI_FLAG_MODF</td><td>模式错位标志位</td></tr><tr><td>SPI_FLAGCRCERR</td><td>CRC错误标志位</td></tr><tr><td>SPI_FLAG_TXE</td><td>发送缓存空标志位</td></tr><tr><td>SPI_FLAG_RXNE</td><td>接受缓存非空标志位</td></tr></table>

例：

# 17.2.18 函数SPI_ClearFlag

Table 442. 描述了函数SPI_ClearFlag  
Table 442. 函数 SPI_ClearFlag  

<table><tr><td>函数名</td><td>SPI_ClearFlag</td></tr><tr><td>函数原形</td><td>void SPI_ClearFlag(SPI_TYPEDef* SPIx, u16 SPI_FLAG)</td></tr><tr><td>功能描述</td><td>清除SPIx的待处理标志位</td></tr><tr><td>输入参数1</td><td>SPIx: x可以是1或者2,来选择SPI外设</td></tr><tr><td>输入参数2</td><td>SPI_FLAG: 待清除的SPI标志位
参阅Section: SPI_FLAG 查阅更多该参数允许取值范围
注意: 标志位BSY, TXE和RXNE由硬件重置</td></tr><tr><td>输出参数</td><td>无</td></tr><tr><td>返回值</td><td>无</td></tr><tr><td>先决条件</td><td>无</td></tr><tr><td>被调用函数</td><td>无</td></tr></table>

例：  
/* Clear the SPI2 Overrun pending bit */  
SPI_ClearFlag(SPI2, SPI_FLAG_OVR);

# 17.2.19 函数SPI_GetITStatus

Table 443. 描述了函数SPI_GetITStatus  
Table 443. 函数 SPI_GetITStatus  

<table><tr><td>函数名</td><td>SPI_GetITStatus</td></tr><tr><td>函数原形</td><td>ITStatus SPI_GetITStatus(SPI_TYPEDef* SPIx, u8 SPI_IT)</td></tr><tr><td>功能描述</td><td>检查指定的 SPI 中断发生与否</td></tr><tr><td>输入参数1</td><td>SPIx: x 可以是 1 或者 2 , 来选择 SPI 外设</td></tr><tr><td>输入参数2</td><td>SPI_IT: 待检查的 SPI 中断源
参阅 Section: SPI_IT 查阅更多该参数允许取值范围</td></tr><tr><td>输出参数</td><td>无</td></tr><tr><td>返回值</td><td>SPI_IT 的新状态</td></tr><tr><td>先决条件</td><td>无</td></tr><tr><td>被调用函数</td><td>无</td></tr></table>

# SPI IT

Table 444. 给出了所有可以被函数SPI_GetITStatus检查的中断标志位列表

Table 444. SPI_IT 值  

<table><tr><td>SPI_IT</td><td>描述</td></tr><tr><td>SPI_IT_OVR</td><td>超出中断标志位</td></tr><tr><td>SPI_IT_MODF</td><td>模式错误标志位</td></tr><tr><td>SPI_IT_CRCERR</td><td>CRC 错误标志位</td></tr><tr><td>SPI_IT_TXE</td><td>发送缓存空中断标志位</td></tr><tr><td>SPI_IT_RXNE</td><td>接受缓存非空中断标志位</td></tr></table>

例：  
/* Test if the SPI1 Overrun interrupt has occurred or not */  
ITStatus Status;  
Status = SPI_GetITStatus(SPI1, SPI_IT_OVR);

# 17.2.20 函数SPI_ClearITPendingBit

Table 445. 描述了函数SPI_ClearITPendingBit  
Table 445. 函数 SPI_ClearITPendingBit  

<table><tr><td>函数名</td><td>SPI_ClearITPendingBit</td></tr><tr><td>函数原形</td><td>void SPI_ClearITPendingBit(SPI_TYPEDef* SPIx, u8 SPI_IT)</td></tr><tr><td>功能描述</td><td>清除SPIx的中断待处理位</td></tr><tr><td>输入参数1</td><td>SPIx: x可以是1或者2,来选择SPI外设</td></tr><tr><td>输入参数2</td><td>SPI_IT: 待检查的SPI中断源
参阅Section: SPI_IT查阅更多该参数允许取值范围
注意: 中断标志位BSY, TXE和RXNE由硬件重置</td></tr><tr><td>输出参数</td><td>无</td></tr><tr><td>返回值</td><td>无</td></tr><tr><td>先决条件</td><td>无</td></tr><tr><td>被调用函数</td><td>无</td></tr></table>

例：  
/* Clear the SPI2 CRC error interrupt pending bit */  
SPI_ClearITPendingBit(SPI2, SPI_IT_CRCERR);

# 18 Cortex系统定时器（SysTick）

SysTick 提供 1 个 24 位、降序、零约束、写清除的计数器，具有灵活的控制机制。

Section 18.1 SysTick 寄存器结构描述了固件函数库所使用的数据结构，Section 18.2 固件库函数介绍了函数库里的所有函数。

# 18.1 SysTick寄存器结构

SYSTICK 寄存器结构，SysTick_TypeDeff，在文件“stm32f10x_map.h”中定义如下：

```txt
typedef struct  
{  
vu32 CTRL;  
vu32 LOAD;  
vu32 VAL;  
vuc32 CALIB;  
} SysTickTypeDef;  
Table 446.例举了SysTick所有寄存器
```

Table 446. SysTick 寄存器  

<table><tr><td>寄存器</td><td>描述</td></tr><tr><td>CTRL</td><td>SysTick 控制和状态寄存器</td></tr><tr><td>LOAD</td><td>SysTick 重装载值寄存器</td></tr><tr><td>VAL</td><td>SysTick 当前值寄存器</td></tr><tr><td>CALIB</td><td>SysTick 校准值寄存器</td></tr></table>

```c
SysTick外设声明于文件“stm32f10x_map.h”：  
#define SCS_BASE((u32)0xE000E000）  
#define SysTick_BASE(SCS_BASE + 0x0010)  
#ifndef DEBUG  
...  
#ifndef_SysTick  
#define SysTick((SysTickTypeDef \*) SysTick_BASE)  
#endif /*_SysTick*/  
...  
#else/\*DEBUG\*/  
...  
#ifndef_SysTick  
EXT SysTickTypeDef \*SysTick;  
#include /\*_SysTick\*/  
...  
#endif  
使用Debug模式时，初始化指针SysTick于文件“stm32f10x_lib.c”：  
#ifdef_SysTick  
SysTick  $=$  (SysTickTypeDef \*) SysTick_BASE;  
#include /\*_SysTick\*/  
为了访问SysTick寄存器，,_SysTick必须在文件“stm32f10x_conf.h"中定义如下：  
#define_SysTick
```

# 18.2 SysTick库函数

Table 447. 例举了 SysTick 的库函数  
Table 447. SysTick 库函数  

<table><tr><td>函数名</td><td>描述</td></tr><tr><td>SysTick_CLKSourceConfig</td><td>设置 SysTick 时钟源</td></tr><tr><td>SysTick_SetReload</td><td>设置 SysTick 重装载值</td></tr><tr><td>SysTick CounterCmd</td><td>使能或者失能 SysTick 计数器</td></tr><tr><td>SysTick_ITConfig</td><td>使能或者失能 SysTick 中断</td></tr><tr><td>SysTick_GetCounter</td><td>获取 SysTick 计数器的值</td></tr><tr><td>SysTick_GetFlagStatus</td><td>检查指定的 SysTick 标志位设置与否</td></tr></table>

# 18.2.1 函数SysTick_CLKSourceConfig

Table 448. 描述了函数SysTick_CLKSourceConfig  
Table 448. 函数 SysTick_CLKSourceConfig  

<table><tr><td>函数名</td><td>SysTick_CLKSourceConfig</td></tr><tr><td>函数原形</td><td>void SysTick_CLKSourceConfig(u32 SysTick_CLKSource)</td></tr><tr><td>功能描述</td><td>设置 SysTick 时钟源</td></tr><tr><td>输入参数</td><td>SysTick_CLKSource: SysTick 时钟源
参阅 Section: SysTick_CLKSource 查阅更多该参数允许取值范围</td></tr><tr><td>输出参数</td><td>无</td></tr><tr><td>返回值</td><td>无</td></tr><tr><td>先决条件</td><td>无</td></tr><tr><td>被调用函数</td><td>无</td></tr></table>

# SysTick_CLKSource

SysTick_CLKSource 选择 SysTick 时钟源，见表 449. 查阅更多该参数可取的值。

Table 449. SysTick_CLKSource 值  

<table><tr><td>SysTick_CLKSource</td><td>描述</td></tr><tr><td>SysTick_CLKSource_HCLK_Div8</td><td>SysTick 时钟源为 AHB 时钟除以 8</td></tr><tr><td>SysTick_CLKSource_HCLK</td><td>SysTick 时钟源为 AHB 时钟</td></tr></table>

例：  
/* AHB clock selected as SysTick clock source */ SysTick_CLKSourceConfig(SysTick_CLKSource_HCLK);

# 18.2.2 函数SysTick_SetReload

Table 450. 描述了函数SysTick_SetReload  
Table 450. 函数 SysTick_SetReload  

<table><tr><td>函数名</td><td>SysTick_SetReload</td></tr><tr><td>函数原形</td><td>void SysTick_SetReload(u32 Reload)</td></tr><tr><td>功能描述</td><td>设置 SysTick 重装载值</td></tr><tr><td>输入参数</td><td>Reload: 重装载值
该参数取值必须在1和0x00FFFFFF之间</td></tr><tr><td>输出参数</td><td>无</td></tr><tr><td>返回值</td><td>无</td></tr><tr><td>先决条件</td><td>无</td></tr><tr><td>被调用函数</td><td>无</td></tr></table>

例：  
/\*Set SysTick reload value to 0xFFFF \*/ SysTick_SetReload(0xFFFF);

# 18.2.3 函数SysTick_ComputerCmd

Table 451. 描述了函数SysTick CounterCmd  
Table 451. 函数 SysTick_CounterCmd  

<table><tr><td>函数名</td><td>SysTick CounterCmd</td></tr><tr><td>函数原形</td><td>void SysTick CounterCmd(u32 SysTick Counter)</td></tr><tr><td>功能描述</td><td>使能或者失能 SysTick 计数器</td></tr><tr><td>输入参数</td><td>SysTick Counter: SysTick 计数器新状态
参阅 Section: SysTick Counter 查阅更多该参数允许取值范围</td></tr><tr><td>输出参数</td><td>无</td></tr><tr><td>返回值</td><td>无</td></tr><tr><td>先决条件</td><td>无</td></tr><tr><td>被调用函数</td><td>无</td></tr></table>

# SysTick_Counter

SysTick_Counter 选择 SysTick 计数器的状态，见表 452. 查阅更多该参数可取的值。

Table 452. SysTick Counter 值  

<table><tr><td>SysTick Counter</td><td>描述</td></tr><tr><td>SysTick Counter Disable</td><td>失能计数器</td></tr><tr><td>SysTick Counter Enable</td><td>使能计数器</td></tr><tr><td>SysTick Counter_Clear</td><td>清除计数器值为0</td></tr></table>

例：  
/\*Enable SysTick counter \*/ SysTick CounterCmd(SysTick_Cluster_enable);

# 18.2.4 函数SysTick_ITConfig

Table 453. 描述了函数SysTick_ITConfig  
Table 453. 函数 SysTick_ITConfig  

<table><tr><td>函数名</td><td>SysTick_ITConfig</td></tr><tr><td>函数原形</td><td>void SysTick_ITConfig(FunctionalState NewState)</td></tr><tr><td>功能描述</td><td>使能或者失能 SysTick 中断</td></tr><tr><td>输入参数</td><td>NewState: SysTick 中断的新状态
这个参数可以取: ENABLE 或者 DISABLE</td></tr><tr><td>输出参数</td><td>无</td></tr><tr><td>返回值</td><td>无</td></tr><tr><td>先决条件</td><td>无</td></tr><tr><td>被调用函数</td><td>无</td></tr></table>

例：  
/\*Enable SysTick interrupt \*/ SysTick_ITConfig(ENABLE);

# 18.2.5 函数SysTick_GetCounter

Table 454. 描述了函数SysTick_GetCounter  
Table 454. 函数 SysTick_GetCounter  

<table><tr><td>函数名</td><td>SysTick_GetCounter</td></tr><tr><td>函数原形</td><td>u32 SysTick_GetCounter(void)</td></tr><tr><td>功能描述</td><td>获取 SysTick 计数器的值</td></tr><tr><td>输入参数</td><td>无</td></tr><tr><td>输出参数</td><td>无</td></tr><tr><td>返回值</td><td>SysTick 计数器的值</td></tr><tr><td>先决条件</td><td>无</td></tr><tr><td>被调用函数</td><td>无</td></tr></table>

例：  
/\*Get SysTick current counter value \*/ u32 SysTickCurrentCounterValue; SysTickCurrentCounterValue  $=$  SysTick_GetCounter();

# 18.2.6 函数SysTick_GetFlagStatus

Table 455. 描述了函数SysTick_GetFlagStatus  
Table 455. 函数 SysTick_GetFlagStatus  

<table><tr><td>函数名</td><td>SysTick_GetFlagStatus</td></tr><tr><td>函数原形</td><td>FlagStatus SysTick_GetFlagStatus(u8 SysTick_FLAG)</td></tr><tr><td>功能描述</td><td>检查指定的 SysTick 标志位设置与否</td></tr><tr><td>输入参数 2</td><td>SysTick_FLAG: 待检查的 SysTic 标志位
参阅 Section: SysTick_FLAG 查阅更多该参数允许取值范围</td></tr><tr><td>输出参数</td><td>无</td></tr><tr><td>返回值</td><td>SysTick_FLAG 的新状态</td></tr><tr><td>先决条件</td><td>无</td></tr><tr><td>被调用函数</td><td>无</td></tr></table>

# SysTick_FLAG

Table 456. 给出了所有可以被函数SysTick_GetITStatus检查的中断标志位列表  
Table 456. SysTick_FLAG 值  

<table><tr><td>SysTick_FLAG</td><td>描述</td></tr><tr><td>SysTick_FLAG_COUNT</td><td>自从上一次被读取，计数器计数至0</td></tr><tr><td>SysTick_FLAG_SKEW</td><td>由于时钟频率，校准值不精确等于10ms</td></tr><tr><td>SysTick_FLAG_NOREF</td><td>参考时钟未提供</td></tr></table>

```txt
例：
/* Test if the Count flag is set or not */
FlagStatus Status;
Status = SysTick_GetFlagStatus(SysTick_FLAG_COUNT);
if (Status == RESET)
{
...
} else
{
...
}
```

# 19 通用定时器（TIM）

通用定时器是一个通过可编程预分频器驱动的16位自动装载计数器构成。

它适用于多种场合，包括测量输入信号的脉冲长度(输入采集)或者产生输出波形(输出比较和PWM)。

使用定时器预分频器和RCC时钟控制器预分频器，脉冲长度和波形周期可以在几个微秒到几个毫秒间调整。

Section 19.1 TIM 寄存器结构描述了固件函数库所使用的数据结构，Section 19.2 固件库函数介绍了函数库里的所有函数。

# 19.1 TIM寄存器结构

TIM寄存器结构，TIM_TYPEDeff，在文件“stm32f10x_map.h”中定义如下：

```c
typedef struct  
{  
vu16 CR1;  
u16 RESERVED0;  
vu16 CR2;  
u16 RESERVED1;  
vu16 SMCR;  
u16 RESERVED2;  
vu16 DIER;  
u16 RESERVED3;  
vu16 SR;  
u16 RESERVED4;  
vu16 EGR;  
u16 RESERVED5;  
vu16 CCMR1;  
u16 RESERVED6;  
vu16 CCMR2;  
u16 RESERVED7;  
vu16 CCER;  
u16 RESERVED8;  
vu16 CNT;  
u16 RESERVED9;  
vu16 PSC;  
u16 RESERVED10;  
vu16 ARR;  
u16 RESERVED11[3];  
vu16 CCR1;  
u16 RESERVED12;  
vu16 CCR2;  
u16 RESERVED13;  
vu16 CCR3;  
u16 RESERVED14;  
vu16 CCR4;  
u16 RESERVED15[3];  
vu16 DCR;  
u16 RESERVED16;  
vu16 DMAR;  
u16 RESERVED17;  
} TIM_TYPEDef;
```

Table 457. TIM 寄存器  

<table><tr><td>寄存器</td><td>描述</td></tr><tr><td>CR1</td><td>控制寄存器1</td></tr><tr><td>CR2</td><td>控制寄存器2</td></tr><tr><td>SMCR</td><td>从模式控制寄存器</td></tr><tr><td>DIER</td><td>DMA/中断使能寄存器</td></tr><tr><td>SR</td><td>状态寄存器</td></tr><tr><td>EGR</td><td>事件产生寄存器</td></tr><tr><td>CCMR1</td><td>捕获/比较模式寄存器1</td></tr><tr><td>CCMR2</td><td>捕获/比较模式寄存器2</td></tr><tr><td>CCER</td><td>捕获/比较使能寄存器</td></tr><tr><td>CNT</td><td>计数器寄存器</td></tr><tr><td>PSC</td><td>预分频寄存器</td></tr><tr><td>APR</td><td>自动重装载寄存器</td></tr><tr><td>CCR1</td><td>捕获/比较寄存器1</td></tr><tr><td>CCR2</td><td>捕获/比较寄存器2</td></tr><tr><td>CCR3</td><td>捕获/比较寄存器3</td></tr><tr><td>CCR4</td><td>捕获/比较寄存器4</td></tr><tr><td>DCR</td><td>DMA 控制寄存器</td></tr><tr><td>DMAR</td><td>连续模式的 DMA 地址寄存器</td></tr></table>

三个TIM外设声明于文件“stm32f10x_map.h”：

```c
define PERIPH_BASE ((u32)0x40000000)
#define APB1PERIPH_BASE PERIPH_BASE
#define APB2PERIPH_BASE (PERIPH_BASE + 0x10000)
#define AHBPERIPH_BASE (PERIPH_BASE + 0x20000)
#define TIM2_BASE (APB1PERIPH_BASE + 0x0000)
#define TIM3_BASE (APB1PERIPH_BASE + 0x0400)
#define TIM4_BASE (APB1PERIPH_BASE + 0x0800)
...
ifndef DEBUG
...
ifdef_TIM2
#define_TIM2 ((TIM_TYPEDef *) TIM2_BASE)
endif /*TIM2 */
ifdef_TIM3
#define_TIM3 ((TIM_TYPEDef *) TIM3_BASE)
endif /*TIM3 */
ifdef_TIM4
#define_TIM4 ((TIM_TYPEDef *) TIM4_BASE)
endif /*TIM4 */
...
else /* DEBUG */
...
ifdef_TIM2
EXT_TIM_TYPEDef *TIM2;
endif /*TIM2 */
ifdef_TIM3
EXT_TIM_TYPEDef *TIM3;
endif /*TIM3 */
ifdef_TIM4
EXT_TIM_TYPEDef *TIM4;
endif /*TIM4 */
...
endif
```

使用Debug模式时，初始化指针TIM2, TIM3和TIM4于文件“stm32f10x_lib.c”：

```c
... #ifdef TIM2 TIM2 = (TIMTypeDef *) TIM2_BASE; #endif /*_TIM2*/
```

# ST

译文英文原版为UM0427 Oct. 2007 Rev 2, 译文仅供参考，与英文版冲突的，以英文版为准

TIM  
```c
#ifndef TIM3
TIM3 = (TIMTypeDef *) TIM3_BASE;
#endif /* TIM3 */
#ifndef TIM4
TIM4 = (TIMTypeDef *) TIM4_BASE;
#endif /* TIM4 */
```

为了访问TIM寄存器，,_TIM，_TIM2,_TIM3和_TIM4必须在文件“stm32f10x_conf.h”中定义如下：

```m4
define _TIM  
#define _TIM2  
#define _TIM3  
#define _TIM4
```

```txt
.
```

# 19.2 TIM库函数

Table 458. 例举了TIM的库函数  
Table 458. TIM 库函数  

<table><tr><td>函数名</td><td>描述</td></tr><tr><td>TIM_DeInit</td><td>将外设TIMx寄存器重设为缺省值</td></tr><tr><td>TIM_TimeBaseInit</td><td>根据TIM_TimeBaseInitStruct中指定的参数初始化TIMx的时间基数单位</td></tr><tr><td>TIM_OCInit</td><td>根据TIM_OCInitStruct中指定的参数初始化外设TIMx</td></tr><tr><td>TIM_ICInit</td><td>根据TIM_ICInitStruct中指定的参数初始化外设TIMx</td></tr><tr><td>TIM_TimeBaseStructInit</td><td>把TIM_TimeBaseInitStruct中的每一个参数按缺省值填入</td></tr><tr><td>TIM_OCStructInit</td><td>把TIM_OCInitStruct中的每一个参数按缺省值填入</td></tr><tr><td>TIM_ICStructInit</td><td>把TIM_OCInitStruct中的每一个参数按缺省值填入</td></tr><tr><td>TIM_Cmd</td><td>使能或者失能TIMx外设</td></tr><tr><td>TIM_ITConfig</td><td>使能或者失能指定的TIM中断</td></tr><tr><td>TIM_DMAConfig</td><td>设置TIMx的DMA接口</td></tr><tr><td>TIM_DMAcd</td><td>使能或者失能指定的TIMx的DMA请求</td></tr><tr><td>TIM/InternalClockConfig</td><td>设置TIMx内部时钟</td></tr><tr><td>TIM_ITRxExternalClockConfig</td><td>设置TIMx内部触发为外部时钟模式</td></tr><tr><td>TIM_TIxExternalClockConfig</td><td>设置TIMx触发为外部时钟</td></tr><tr><td>TIM_ETRClockMode1Config</td><td>配置TIMx外部时钟模式1</td></tr><tr><td>TIM_ETRClockMode2Config</td><td>配置TIMx外部时钟模式2</td></tr><tr><td>TIM_ETRConfig</td><td>配置TIMx外部触发</td></tr><tr><td>TIM_SelectionTrigger</td><td>选择TIMx输入触发源</td></tr><tr><td>TIM_PrescalerConfig</td><td>设置TIMx预分频</td></tr><tr><td>TIM CounterModeConfig</td><td>设置TIMx计数器模式</td></tr><tr><td>TIM_ForedC01Config</td><td>置TIMx输出1为活动或者非活动电平</td></tr><tr><td>TIM_ForedC02Config</td><td>置TIMx输出2为活动或者非活动电平</td></tr><tr><td>TIM_ForedC03Config</td><td>置TIMx输出3为活动或者非活动电平</td></tr><tr><td>TIM_ForedC04Config</td><td>置TIMx输出4为活动或者非活动电平</td></tr><tr><td>TIM_ARPreloadConfig</td><td>使能或者失能TIMx在ARR上的预装载寄存器</td></tr><tr><td>TIM_SelectCCDMA</td><td>选择TIMx外设的捕获比较DMA源</td></tr><tr><td>TIM_OC1PreloadConfig</td><td>使能或者失能TIMx在CCR1上的预装载寄存器</td></tr><tr><td>TIM_OC2PreloadConfig</td><td>使能或者失能TIMx在CCR2上的预装载寄存器</td></tr><tr><td>TIM_OC3PreloadConfig</td><td>使能或者失能TIMx在CCR3上的预装载寄存器</td></tr><tr><td>TIM_OC4PreloadConfig</td><td>使能或者失能TIMx在CCR4上的预装载寄存器</td></tr><tr><td>TIM_OC1FastConfig</td><td>设置TIMx捕获比较1快速特征</td></tr></table>

TIM  

<table><tr><td>TIM_OC2FastConfig</td><td>设置TIMx捕获比较2快速特征</td></tr><tr><td>TIM_OC3FastConfig</td><td>设置TIMx捕获比较3快速特征</td></tr><tr><td>TIM_OC4FastConfig</td><td>设置TIMx捕获比较4快速特征</td></tr><tr><td>TIM_ClearOC1Ref</td><td>在一个外部事件时清除或者保持OCREF1信号</td></tr><tr><td>TIM_ClearOC2Ref</td><td>在一个外部事件时清除或者保持OCREF2信号</td></tr><tr><td>TIM_ClearOC3Ref</td><td>在一个外部事件时清除或者保持OCREF3信号</td></tr><tr><td>TIM_ClearOC4Ref</td><td>在一个外部事件时清除或者保持OCREF4信号</td></tr><tr><td>TIM_UpdateDisableConfig</td><td>使能或者失能TIMx更新事件</td></tr><tr><td>TIM EncoderInterfaceConfig</td><td>设置TIMx编码界面</td></tr><tr><td>TIM_GenerateEvent</td><td>设置TIMx事件由软件产生</td></tr><tr><td>TIM_OC1PolarityConfig</td><td>设置TIMx通道1极性</td></tr><tr><td>TIM_OC2PolarityConfig</td><td>设置TIMx通道2极性</td></tr><tr><td>TIM_OC3PolarityConfig</td><td>设置TIMx通道3极性</td></tr><tr><td>TIM_OC4PolarityConfig</td><td>设置TIMx通道4极性</td></tr><tr><td>TIM_UpdateRequestConfig</td><td>设置TIMx更新请求源</td></tr><tr><td>TIM_SelectHallSensor</td><td>使能或者失能TIMx霍尔传感器接口</td></tr><tr><td>TIM_SELECTOnePulseMode</td><td>设置TIMx单脉冲模式</td></tr><tr><td>TIM_SELECTOutputTrigger</td><td>选择TIMx触发输出模式</td></tr><tr><td>TIM_SELECTSlaveMode</td><td>选择TIMx从模式</td></tr><tr><td>TIM_SELECTMasterSlaveMode</td><td>设置或者重置TIMx主/从模式</td></tr><tr><td>TIM_SetCounter</td><td>设置TIMx计数器寄存器值</td></tr><tr><td>TIM_SetAutoreload</td><td>设置TIMx自动重装载寄存器值</td></tr><tr><td>TIM_SetCompare1</td><td>设置TIMx捕获比较1寄存器值</td></tr><tr><td>TIM_SetCompare2</td><td>设置TIMx捕获比较2寄存器值</td></tr><tr><td>TIM_SetCompare3</td><td>设置TIMx捕获比较3寄存器值</td></tr><tr><td>TIM_SetCompare4</td><td>设置TIMx捕获比较4寄存器值</td></tr><tr><td>TIM_SetIC1Prescaler</td><td>设置TIMx输入捕获1预分频</td></tr><tr><td>TIM_SetIC2Prescaler</td><td>设置TIMx输入捕获2预分频</td></tr><tr><td>TIM_SetIC3Prescaler</td><td>设置TIMx输入捕获3预分频</td></tr><tr><td>TIM_SetIC4Prescaler</td><td>设置TIMx输入捕获4预分频</td></tr><tr><td>TIM_SetClockDivision</td><td>设置TIMx的时钟分割值</td></tr><tr><td>TIM_GetCapture1</td><td>获得TIMx输入捕获1的值</td></tr><tr><td>TIM_GetCapture2</td><td>获得TIMx输入捕获2的值</td></tr><tr><td>TIM_GetCapture3</td><td>获得TIMx输入捕获3的值</td></tr><tr><td>TIM_GetCapture4</td><td>获得TIMx输入捕获4的值</td></tr><tr><td>TIM_GetCounter</td><td>获得TIMx计数器的值</td></tr><tr><td>TIM_GetPrescaler</td><td>获得TIMx预分频值</td></tr><tr><td>TIM_GetFlagStatus</td><td>检查指定的TIM标志位设置与否</td></tr><tr><td>TIM_ClearFlag</td><td>清除TIMx的待处理标志位</td></tr><tr><td>TIM_GetITStatus</td><td>检查指定的TIM中断发生与否</td></tr><tr><td>TIM_ClearITPendingBit</td><td>清除TIMx的中断待处理位</td></tr></table>

# 19.2.1 函数TIM_DeInit

Table 459. 描述了函数 TIM_DeInit

Table 459. 函数 TIM_DeInit  

<table><tr><td>函数名</td><td>TIM_DeInit</td></tr><tr><td>函数原形</td><td>void TIM_DeInit(TIMTypeDef* TIMx)</td></tr><tr><td>功能描述</td><td>将外设TIMx寄存器重设为缺省值</td></tr><tr><td>输入参数</td><td>TIMx: x可以是2,3或者4,来选择TIM外设</td></tr><tr><td>输出参数</td><td>无</td></tr><tr><td>返回值</td><td>无</td></tr><tr><td>先决条件</td><td>无</td></tr><tr><td>被调用函数</td><td>RCC_APB1PeriphClockCmd().</td></tr></table>

例：/\* Resets the TIM2 \*/TIM_DeInit(TIM2);

# 19.2.2 函数TIM_TimeBaseInit

Table 460. 描述了函数 TIM_TimeBaseInit  
Table 460. 函数 TIM_TimeBaseInit  

<table><tr><td>函数名</td><td>TIM_TimeBaseInit</td></tr><tr><td>函数原形</td><td>void TIM_TimeBaseInit(TIMTypeDef* TIMx, TIM_TimeBaseInitTypeDef*TIM_TimeBaseInitStruct)</td></tr><tr><td>功能描述</td><td>根据TIM_TimeBaseInitStruct中指定的参数初始化TIMx的时间基数单位</td></tr><tr><td>输入参数1</td><td>TIMx: x可以是2,3或者4,来选择TIM外设</td></tr><tr><td>输入参数2</td><td>TIMTimeBase_InitStruct: 指向结构TIM_TimeBaseInitTypeDef的指针,包含了TIMx时间基数单位的配置信息参阅Section: TIM_TimeBaseInitTypeDef 查阅更多该参数允许取值范围</td></tr><tr><td>输出参数</td><td>无</td></tr><tr><td>返回值</td><td>无</td></tr><tr><td>先决条件</td><td>无</td></tr><tr><td>被调用函数</td><td>无</td></tr></table>

# TIM_TimeBaseInitTypeDef structure

TIM_TimeBaseInitTypeDef 定义于文件“stm32f10x(TIM.h”：

```c
typedef struct   
{   
u16 TIM_Period;   
u16 TIM_Prescaler;   
u8 TIM_ClockDivision;   
u16 TIM CounterMode;   
}TIM_TimeBaseInitTypeDef;
```

# TIM Period

TIM_Period设置了在下一个更新事件装入活动的自动重装载寄存器周期的值。它的取值必须在0x0000和0xFFFF之间。

# TIM_Prescaler

TIM_Prescaler 设置了用来作为 TIMx 时钟频率除数的预分频值。它的取值必须在 0x0000 和 0xFFFF 之间。

# TIM_ClockDivision

TIM_ClockDivision 设置了时钟分割。该参数取值见下表。

Table 461. TIM_ClockDivision 值  

<table><tr><td>TIM_ClockDivision</td><td>描述</td></tr><tr><td>TIM_CKD_DIV1</td><td>TDDS = Tck(TIM)</td></tr><tr><td>TIM_CKD_DIV2</td><td>TDDS = 2Tck(TIM)</td></tr><tr><td>TIM_CKD_DIV4</td><td>TDDS = 4Tck(TIM)</td></tr></table>

# TIM CounterMode

TIM CounterMode 选择了计数器模式。该参数取值见下表。

Table 462. TIM CounterMode 值  

<table><tr><td>TIMDDDMode</td><td>描述</td></tr><tr><td>TIMDDDMode_Up</td><td>TIM向上计数模式</td></tr><tr><td>TIMDDDMode_Down</td><td>TIM向下计数模式</td></tr><tr><td>TIMDDDMode_CenterAligned1</td><td>TIM中央对齐模式1计数模式</td></tr><tr><td>TIMDDDMode_CenterAligned2</td><td>TIM中央对齐模式2计数模式</td></tr><tr><td>TIMDDDMode_CenterAligned3</td><td>TIM中央对齐模式3计数模式</td></tr></table>

例：

```matlab
TIM_TimeBaseInitTypeDef TIM_TimeBaseStructure;  
TIM_TimeBaseStructure.TIM_Period = 0xFFFF;  
TIM_TimeBaseStructure.TIM_Prescaler = 0xF;  
TIM_TimeBaseStructure.TIM_ClockDivision = 0x0;  
TIM_TimeBaseStructure.TIM CounterMode = TIM CounterMode_Up;  
TIM_TimeBaseInit(TIM2, & TIM_TimeBaseStructure);
```

# 19.2.3 函数TIM_OCInit

Table 463. 描述了函数 TIM_OCInit  
Table 463. 函数 TIM_OCInit  

<table><tr><td>函数名</td><td>TIM_OCInit</td></tr><tr><td>函数原形</td><td>void TIM_OCInit(TIMTypeDef* TIMx, TIM_OCInitTypeDef*TIM_OCInitStruct)</td></tr><tr><td>功能描述</td><td>根据TIM_OCInitStruct中指定的参数初始化外设TIMx</td></tr><tr><td>输入参数1</td><td>TIMx: x可以是2,3或者4,来选择TIM外设</td></tr><tr><td>输入参数2</td><td>TIM_OCInitStruct: 指向结构TIM_OCInitTypeDef的指针,包含了TIMx时间基数单位的配置信息参阅Section: TIM_OCInitTypeDef 查阅更多该参数允许取值范围</td></tr><tr><td>输出参数</td><td>无</td></tr><tr><td>返回值</td><td>无</td></tr><tr><td>先决条件</td><td>无</td></tr><tr><td>被调用函数</td><td>无</td></tr></table>

# TIM_OCInitTypeDef structure

TIM_OCInitTypeDef 定义于文件“stm32f10x(TIM.h”：

```c
typedef struct   
{   
u16 TIM_OCMode;   
u16 TIM_Channel;   
u16 TIM_Pulse;   
u16 TIM_OCPolarity;   
}TIM_OCInitTypeDef;
```

# TIM_OCMode

TIM_OCMode 选择定时器模式。该参数取值见下表。

Table 464. TIM_OCMode 定义  

<table><tr><td>TIM_OCMode</td><td>描述</td></tr><tr><td>TIM_OCMode_Timing</td><td>TIM 输出比较时间模式</td></tr><tr><td>TIM_OCMode_Active</td><td>TIM 输出比较主动模式</td></tr><tr><td>TIM_OCMode_Inactive</td><td>TIM 输出比较非主动模式</td></tr><tr><td>TIM_OCMode_Toggle</td><td>TIM 输出比较触发模式</td></tr><tr><td>TIM_OCMode_PWM1</td><td>TIM 脉冲宽度调制模式 1</td></tr><tr><td>TIM_OCMode_PWM2</td><td>TIM 脉冲宽度调制模式 2</td></tr></table>

# TIM Channel

TIM_Channel 选择通道。该参数取值见下表。

Table 465. TIM_Channel 值  

<table><tr><td>TIM_Channel</td><td>描述</td></tr><tr><td>TIM_Channel_1</td><td>使用TIM通道1</td></tr><tr><td>TIM_Channel_2</td><td>使用TIM通道2</td></tr><tr><td>TIM_Channel_3</td><td>使用TIM通道3</td></tr><tr><td>TIM_Channel_4</td><td>使用TIM通道4</td></tr></table>

# TIM_Pulse

TIM_Pulse设置了待装入捕获比较寄存器的脉冲值。它的取值必须在0x0000和0xFFFF之间。

# TIM_OCPolarity

TIM_OCPolarity输出极性。该参数取值见下表。

Table 466. TIM_OCPolarity 值  

<table><tr><td>TIM_OCPolarity</td><td>描述</td></tr><tr><td>TIM_OCPolarity_High</td><td>TIM 输出比较极性高</td></tr><tr><td>TIM_OCPolarity_Low</td><td>TIM 输出比较极性低</td></tr></table>

例：

```txt
/\* Configures the TIM2 Channel1 in PWM Mode \*/   
TIM_OCInitTypeDef TIM_OCInitStructure;   
TIM_OCInitStructure.TIM_OCMode  $=$  TIM_OCMode_PWM1;   
TIM_OCInitStructure.TIM_Channel  $=$  TIM_Channel_1;   
TIM_OCInitStructure.TIM_Pulse  $= 0\mathrm{x}3\overline{\mathrm{FFF}}$  .   
TIM_OCInitStructure.TIM_OCPolarity  $=$  TIM_OCPolarity_High;   
TIM_OCInit(TIM2, & TIM_OCInitStructure);
```

# 19.2.4 函数TIM_ICInit

Table 467. 描述了函数 TIM_ICInit

Table 467. 函数 TIM_ICInit  

<table><tr><td>函数名</td><td>TIM_OCInit</td></tr><tr><td>函数原形</td><td>void TIM_ICInit(TIM_TYPEDef* TIMx, TIM_ICInitTypeDef* TIM_ICInitStruct)</td></tr><tr><td>功能描述</td><td>根据TIM_ICInitStruct中指定的参数初始化外设TIMx</td></tr><tr><td>输入参数1</td><td>TIMx: x可以是2,3或者4,来选择TIM外设</td></tr><tr><td>输入参数2</td><td>TIM_ICInitStruct: 指向结构TIM_ICInitTypeDef的指针,包含了TIMx的配置信息参阅Section: TIM_ICInitTypeDef查阅更多该参数允许取值范围</td></tr><tr><td>输出参数</td><td>无</td></tr><tr><td>返回值</td><td>无</td></tr><tr><td>先决条件</td><td>无</td></tr><tr><td>被调用函数</td><td>无</td></tr></table>

# TIM_ICInitTypeDef structure

TIM_ICInitTypeDef 定义于文件“stm32f10x(TIM.h”：

```c
typedef struct   
{   
u16 TIM_ICMode;   
u16 TIM_Channel;   
u16 TIM_ICPolarity;   
u16 TIM_ICSelection;   
u16 TIM_ICPrescaler;   
u16 TIM_ICFilter;   
}TIM_ICInitTypeDef;
```

# TIM_ICMode

TIM_ICMode选择了TIM输入捕获模式。该参数取值见下表。

Table 468. TIM_ICMode 定义  

<table><tr><td>TIM_ICMode</td><td>描述</td></tr><tr><td>TIM_ICMode_ICAP</td><td>TIM 使用输入捕获模式</td></tr><tr><td>TIM_ICMode_PWMI</td><td>TIM 使用输入 PWM 模式</td></tr></table>

# TIM_Channel

TIM_Channel 选择通道。该参数取值见下表。

Table 469. TIM_Channel 值  

<table><tr><td>TIM_Channel</td><td>描述</td></tr><tr><td>TIM_Channel_1</td><td>使用TIM通道1</td></tr><tr><td>TIM_Channel_2</td><td>使用TIM通道2</td></tr><tr><td>TIM_Channel_3</td><td>使用TIM通道3</td></tr><tr><td>TIM_Channel_4</td><td>使用TIM通道4</td></tr></table>

# TIM_ICPolarity

TIM_ICPolarity输入活动沿。该参数取值见下表。

Table 470. TIM_Channel 值  

<table><tr><td>TIM_OCPolarity</td><td>描述</td></tr><tr><td>TIM_ICPolarity_Rising</td><td>TIM 输入捕获上升沿</td></tr><tr><td>TIM_ICPolarity_Falling</td><td>TIM 输入捕获下降沿</td></tr></table>

# TIM_ICSelection

TIM_ICSelection选择输入。该参数取值见下表。

Table 471. TIM_ICSelection 值  

<table><tr><td>TIM_ICSelection</td><td>描述</td></tr><tr><td>TIM_ICSelection_DirectTI</td><td>TIM输入2,3或4选择对应地与IC1或IC2或IC3或IC4相连</td></tr><tr><td>TIM_ICSelection_IndirectTI</td><td>TIM输入2,3或4选择对应地与IC2或IC1或IC4或IC3相连</td></tr><tr><td>TIM_ICSelection_TRC</td><td>TIM输入2,3或4选择与TRC相连</td></tr></table>

# TIM_ICPrescaler

TIM_ICPrescaler设置输入捕获预分频器。该参数取值见下表。

Table 472. TIM_ICPrescaler 值  

<table><tr><td>TIM_ICPrescaler</td><td>描述</td></tr><tr><td>TIM_ICPSC_DIV1</td><td>TIM 捕获在捕获输入上每探测到一个边沿执行一次</td></tr><tr><td>TIM_ICPSC_DIV2</td><td>TIM 捕获每 2 个事件执行一次</td></tr><tr><td>TIM_ICPSC_DIV3</td><td>TIM 捕获每 3 个事件执行一次</td></tr><tr><td>TIM_ICPSC_DIV4</td><td>TIM 捕获每 4 个事件执行一次</td></tr></table>

# TIM_ICFilter

TIM_ICFilter选择输入比较滤波器。该参数取值在0x0和0xF之间。

例：

```txt
/\* The following example illustrates how to configure the TIM2 in PWM Input mode : The external signal is connected to TIM2 CH1 pin, the Rising edge is used as active edge, the TIM2 CCR1 is used to compute the frequency value the TIM2 CCR2 is used to compute the duty cycle value \*/   
TIM_DeInit(TIM2);   
TIM_ICStructInit(&TIM_ICInitStructure);   
TIM_ICInitStructure.TIM_ICMode  $=$  TIM_ICMode_PWMI;   
TIM_ICInitStructure.TIM_Channel  $=$  TIM_Channel1;   
TIM_ICInitStructure.TIM_ICPolarity  $=$  TIM_ICPolarity_Rising;   
TIM_ICInitStructure.TIM_ICSelection  $=$  TIM_ICSelection_DirectTI;   
TIM_ICInitStructure.TIM_ICPrescaler  $=$  TIM_ICPSC_DIV1;   
TIM_ICInitStructure.TIM_ICFilter  $= 0\mathrm{x}0$  .   
TIM_ICInit(TIM2，&TIM_ICInitStructure);
```

# 19.2.5 函数TIM_TimeBaseStructInit

Table 473. 描述了函数TIM_TimeBaseStructInit  
Table 473. 函数 TIM_TimeBaseStructInit  

<table><tr><td>函数名</td><td>TIM_TimeBaseStructInit</td></tr><tr><td>函数原形</td><td>void TIM_TimeBaseStructInit(TIM_TimeBaseInitTypeDef* TIM_TimeBaseInitStruct)</td></tr><tr><td>功能描述</td><td>把TIM_TimeBaseInitStruct中的每一个参数按缺省值填入</td></tr><tr><td>输入参数</td><td>TIM_TimeBaseInitStruct: 指向结构TIM_TimeBaseInitTypeDef的指针, 待初始化</td></tr><tr><td>输出参数</td><td>无</td></tr><tr><td>返回值</td><td>无</td></tr><tr><td>先决条件</td><td>无</td></tr><tr><td>被调用函数</td><td>无</td></tr></table>

Table 474. 给出了TIM_TimeBaseInitStruct各个成员的缺省值  
Table 474. TIM_TimeBaseInitStruct 缺省值  

<table><tr><td>成员</td><td>缺省值</td></tr><tr><td>TIM_Period</td><td>TIM_Period Reset_Mask</td></tr><tr><td>TIM_Prescaler</td><td>TIM_Prescaler Reset_Mask</td></tr><tr><td>TIM_CKD</td><td>TIM_CKD_DIV1</td></tr><tr><td>TIM CounterMode</td><td>TIM CounterMode_Up</td></tr></table>

例：
/* The following example illustrates how to initialize a TIM_BaseInitTypeDef structure */
TIM_TimeBaseInitTypeDef TIM_TimeBaseInitStructure;
TIM_TimeBaseStructInit(& TIM_TimeBaseInitStructure);

# 19.2.6 函数TIM_OCStructInit

Table 475. 描述了函数TIM_OCStructInit  
Table 475. 函数 TIM_TimeBaseStructInit  

<table><tr><td>函数名</td><td>TIM_TimeBaseStructInit</td></tr><tr><td>函数原形</td><td>void TIM_OCStructInit(TIM_OCInitTypeDef* TIM_OCInitStruct)</td></tr><tr><td>功能描述</td><td>把TIM_OCInitStruct中的每一个参数按缺省值填入</td></tr><tr><td>输入参数</td><td>TIM_OCInitStruct: 指向结构TIM_OCInitTypeDef的指针, 待初始化</td></tr><tr><td>输出参数</td><td>无</td></tr><tr><td>返回值</td><td>无</td></tr><tr><td>先决条件</td><td>无</td></tr><tr><td>被调用函数</td><td>无</td></tr></table>

Table 476. 给出了TIM_OCInitStruct各个成员的缺省值  
Table 476. TIM_OCInitStruct 缺省值  

<table><tr><td>成员</td><td>缺省值</td></tr><tr><td>TIM_OCMode</td><td>TIM_OCMode_Timing</td></tr><tr><td>TIM_Channel</td><td>TIM_Channel_1</td></tr><tr><td>TIM_Pulse</td><td>TIM_Pulse_Sett_Mask</td></tr><tr><td>TIM_OC Polarity</td><td>TIM_OC Polarity_High</td></tr></table>

例：
/* The following example illustrates how to initialize a TIM_OCInitTypeDef structure */
TIM_OCInitTypeDef TIM_OCInitStructure;
TIM_OCStructInit(& TIM_OCInitStructure);  
译文英文原版为UM0427Oct.2007Rev2，译文仅供参考，与英文版冲突的，以英文版为准 251/368

# 19.2.7 函数TIM_ICStructInit

Table 477. 描述了函数TIM_ICStructInit  
Table 477. 函数 TIM_ICStructInit  

<table><tr><td>函数名</td><td>TIM_ICStructInit</td></tr><tr><td>函数原形</td><td>void TIM_ICStructInit(TIM_ICInitTypeDef*TIM_ICInitStruct)</td></tr><tr><td>功能描述</td><td>把TIM_ICInitStruct中的每一个参数按缺省值填入</td></tr><tr><td>输入参数</td><td>TIM_ICInitStruct: 指向结构TIM_ICInitTypeDef的指针, 待初始化</td></tr><tr><td>输出参数</td><td>无</td></tr><tr><td>返回值</td><td>无</td></tr><tr><td>先决条件</td><td>无</td></tr><tr><td>被调用函数</td><td>无</td></tr></table>

Table 478. 给出了TIM_ICInitStruct各个成员的缺省值  
Table 478. TIM_ICInitStruct 缺省值  

<table><tr><td>成员</td><td>缺省值</td></tr><tr><td>TIM_ICMode</td><td>TIM_ICMode_ICAP</td></tr><tr><td>TIM_Channel</td><td>TIM_Channel_1</td></tr><tr><td>TIM_ICPolarity</td><td>TIM_ICPolarity_Rising</td></tr><tr><td>TIM_ICSelection</td><td>TIM_ICSelection_DirectTI</td></tr><tr><td>TIM_ICPrescaler</td><td>TIM_ICPSC_DIV1</td></tr><tr><td>TIM_ICFilter</td><td>TIM_ICFilter_Mask</td></tr></table>

例：

```c
/\* The following example illustrates how to initialize a TIM_ICInitTypeDef structure \*/   
TIM_ICInitTypeDef TIM_ICInitStructure;   
TIM_ICStructInit(& TIM_ICInitStructure);
```

# 19.2.8 函数TIM_Cmd

Table 479. 描述了函数TIM_Cmd  
Table 479. 函数 TIM_Cmd  

<table><tr><td>函数名</td><td>TIM_Cmd</td></tr><tr><td>函数原形</td><td>void TIM_Cmd(TIMTypeDef* TIMx, FunctionalState NewState)</td></tr><tr><td>功能描述</td><td>使能或者失能 TIMx 外设</td></tr><tr><td>输入参数1</td><td>TIMx: x 可以是 2, 3 或者 4, 来选择 TIM 外设</td></tr><tr><td>输入参数2</td><td>NewState: 外设 TIMx 的新状态
这个参数可以取: ENABLE 或者 DISABLE</td></tr><tr><td>输出参数</td><td>无</td></tr><tr><td>返回值</td><td>无</td></tr><tr><td>先决条件</td><td>无</td></tr><tr><td>被调用函数</td><td>无</td></tr></table>

例：

```javascript
/\*Enables the TIM2 counter \*/TIM_Cmd(TIM2，ENABLE);
```

# 19.2.9 函数TIM_ITConfig

Table 480. 描述了函数TIM_ITConfig

Table 480. 函数 TIM_ITConfig  

<table><tr><td>函数名</td><td>TIM_ITConfig</td></tr><tr><td>函数原形</td><td>void TIM_ITConfig(TIM_TYPEDef* TIMx, u16 TIM_IT, FunctionalState NewState)</td></tr><tr><td>功能描述</td><td>使能或者失能指定的TIM中断</td></tr><tr><td>输入参数1</td><td>TIMx: x可以是2,3或者4,来选择TIM外设</td></tr><tr><td>输入参数2</td><td>TIM_IT: 待使能或者失能的TIM中断源
参阅Section: TIM_IT 查阅更多该参数允许取值范围</td></tr><tr><td>输入参数3</td><td>NewState: TIMx中断的新状态
这个参数可以取: ENABLE或者 DISABLE</td></tr><tr><td>输出参数</td><td>无</td></tr><tr><td>返回值</td><td>无</td></tr><tr><td>先决条件</td><td>无</td></tr><tr><td>被调用函数</td><td>无</td></tr></table>

# TIM_IT

输入参数TIM_IT使能或者失能TIM的中断。可以取下表的一个或者多个取值的组合作为该参数的值。

Table 481. TIM IT 值  

<table><tr><td>TIM_IT</td><td>描述</td></tr><tr><td>TIM_IT_Update</td><td>TIM中断源</td></tr><tr><td>TIM_IT_CC1</td><td>TIM捕获/比较1中断源</td></tr><tr><td>TIM_IT_CC2</td><td>TIM捕获/比较2中断源</td></tr><tr><td>TIM_IT_CC3</td><td>TIM捕获/比较3中断源</td></tr><tr><td>TIM_IT_CC4</td><td>TIM捕获/比较4中断源</td></tr><tr><td>TIM_IT_Trigger</td><td>TIM触发中断源</td></tr></table>

例：

/\*Enables the TIM2 Capture Compare channel 1 Interrupt source \*/TIM_ITConfig(TIM2，TIM_IT_CC1,ENABLE）;

# 19.2.10 函数TIM_DMAConfig

Table 482. 描述了函数TIM_DMAConfig

Table 482. 函数 TIM_DMAConfig  

<table><tr><td>函数名</td><td>TIM_DMAConfig</td></tr><tr><td>函数原形</td><td>void TIM_DMAConfig(TIMTypeDef* TIMx,u8 TIM_DMABase, u16 TIM_DMA BurstLength)</td></tr><tr><td>功能描述</td><td>设置TIMx的DMA接口</td></tr><tr><td>输入参数1</td><td>TIMx: x可以是2,3或者4,来选择TIM外设</td></tr><tr><td>输入参数2</td><td>TIM_DMABase: DMA传输起始地址
参阅Section: TIM_DMABase 查阅更多该参数允许取值范围</td></tr><tr><td>输入参数3</td><td>TIM_DMA BurstLength: DMA连续传送长度
参阅Section: TIM_DMA BurstLength 查阅更多该参数允许取值范围</td></tr><tr><td>输出参数</td><td>无</td></tr><tr><td>返回值</td><td>无</td></tr><tr><td>先决条件</td><td>无</td></tr><tr><td>被调用函数</td><td>无</td></tr></table>

# TIM DMABase

TIM_DMABase 设置 DMA 传输起始地址。可以取下表的值。

Table 483. TIM_DMBase 值  

<table><tr><td>TIM_DMABase</td><td>描述</td></tr><tr><td>TIM_DMABase_CR1</td><td>TIM CR1 寄存器作为 DMA 传输起始</td></tr><tr><td>TIM_DMABase_CR2</td><td>TIM CR2 寄存器作为 DMA 传输起始</td></tr><tr><td>TIM_DMABase_SMCR</td><td>TIM SMCR 寄存器作为 DMA 传输起始</td></tr><tr><td>TIM_DMABase_DIER</td><td>TIM DIER 寄存器作为 DMA 传输起始</td></tr><tr><td>TIM_DMABase_SR</td><td>TIM SR 寄存器作为 DMA 传输起始</td></tr><tr><td>TIM_DMABase_EGR</td><td>TIM EGR 寄存器作为 DMA 传输起始</td></tr><tr><td>TIM_DMABase_CCMR1</td><td>TIM CCMR1 寄存器作为 DMA 传输起始</td></tr><tr><td>TIM_DMABase_CCMR2</td><td>TIM CCMR2 寄存器作为 DMA 传输起始</td></tr><tr><td>TIM_DMABase_CCER</td><td>TIM CCER 寄存器作为 DMA 传输起始</td></tr><tr><td>TIM_DMABase_CNT</td><td>TIM CNT 寄存器作为 DMA 传输起始</td></tr><tr><td>TIM_DMABase_PSC</td><td>TIM PSC 寄存器作为 DMA 传输起始</td></tr><tr><td>TIM_DMABase_ERR</td><td>TIM APR 寄存器作为 DMA 传输起始</td></tr><tr><td>TIM_DMABase_CCR1</td><td>TIM CCR1 寄存器作为 DMA 传输起始</td></tr><tr><td>TIM_DMABase_CCR2</td><td>TIM CCR2 寄存器作为 DMA 传输起始</td></tr><tr><td>TIM_DMABase_CCR3</td><td>TIM CCR3 寄存器作为 DMA 传输起始</td></tr><tr><td>TIM_DMABase_CCR4</td><td>TIM CCR4 寄存器作为 DMA 传输起始</td></tr><tr><td>TIM_DMABase_DCR</td><td>TIM DCR 寄存器作为 DMA 传输起始</td></tr></table>

# TIM_DMA BurstLength

TIM_DMA BurstLength 设置 DMA 连续传送长度。可以取下表的值。

Table 484. TIM_DMA BurstLength 值  

<table><tr><td>TIM_DMABurstLength</td><td>描述</td></tr><tr><td>TIM_DMABurstLength_1Byte</td><td>TIM DMA 连续传送长度 1 字</td></tr><tr><td>TIM_DMABurstLength_2Bytes</td><td>TIM DMA 连续传送长度 2 字</td></tr><tr><td>TIM_DMABurstLength_3Bytes</td><td>TIM DMA 连续传送长度 3 字</td></tr><tr><td>TIM_DMABurstLength_4Bytes</td><td>TIM DMA 连续传送长度 4 字</td></tr><tr><td>TIM_DMABurstLength_5Bytes</td><td>TIM DMA 连续传送长度 5 字</td></tr><tr><td>TIM_DMABurstLength_6Bytes</td><td>TIM DMA 连续传送长度 6 字</td></tr><tr><td>TIM_DMABurstLength_7Bytes</td><td>TIM DMA 连续传送长度 7 字</td></tr><tr><td>TIM_DMABurstLength_8Bytes</td><td>TIM DMA 连续传送长度 8 字</td></tr><tr><td>TIM_DMABurstLength_9Bytes</td><td>TIM DMA 连续传送长度 9 字</td></tr><tr><td>TIM_DMABurstLength_10Bytes</td><td>TIM DMA 连续传送长度 10 字</td></tr><tr><td>TIM_DMABurstLength_11Bytes</td><td>TIM DMA 连续传送长度 11 字</td></tr><tr><td>TIM_DMABurstLength_12Bytes</td><td>TIM DMA 连续传送长度 12 字</td></tr><tr><td>TIM_DMABurstLength_13Bytes</td><td>TIM DMA 连续传送长度 13 字</td></tr><tr><td>TIM_DMABurstLength_14Bytes</td><td>TIM DMA 连续传送长度 14 字</td></tr><tr><td>TIM_DMABurstLength_15Bytes</td><td>TIM DMA 连续传送长度 15 字</td></tr><tr><td>TIM_DMABurstLength_16Bytes</td><td>TIM DMA 连续传送长度 16 字</td></tr><tr><td>TIM_DMABurstLength_17Bytes</td><td>TIM DMA 连续传送长度 17 字</td></tr><tr><td>TIM_DMABurstLength_18Bytes</td><td>TIM DMA 连续传送长度 18 字</td></tr></table>

例：  
/\* Configures the TIM2 DMA Interface to transfer 1 byte and to use the CCR1 as base address \*/  
TIM_DMAConfig(TIM2，TIM_DMABase_CCR1，TIM_DMABurstLength_1Byte)

# 19.2.11 函数TIM_DMAcmd

Table 485. 描述了函数TIM_DMACmd  
Table 485. 函数 TIM_DMAcmd  

<table><tr><td>函数名</td><td>TIM_DMAcmd</td></tr><tr><td>函数原形</td><td>void TIM_DMAcmd(TIMTypeDef* TIMx, u16 TIM_DMASource, FunctionalState Newstate)</td></tr><tr><td>功能描述</td><td>使能或者失能指定的TIMx的DMA请求</td></tr><tr><td>输入参数1</td><td>TIMx: x可以是2,3或者4,来选择TIM外设</td></tr><tr><td>输入参数2</td><td>TIM_DMASource: 待使能或者失能的TIM中断源
参阅Section: TIM_DMASource 查阅更多该参数允许取值范围</td></tr><tr><td>输入参数3</td><td>NewState: DMA请求的新状态
这个参数可以取: ENABLE或者 DISABLE</td></tr><tr><td>输出参数</td><td>无</td></tr><tr><td>返回值</td><td>无</td></tr><tr><td>先决条件</td><td>无</td></tr><tr><td>被调用函数</td><td>无</td></tr></table>

# TIM_DMASource

输入参数TIM_DMASource使能或者失能TIM的中断。可以取下表的值。

Table 486. TIM_DMASource 值  

<table><tr><td>TIM_DMASource</td><td>描述</td></tr><tr><td>TIM_DMA_Update</td><td>TIM 更新 DMA 源</td></tr><tr><td>TIM_DMA_CC1</td><td>TIM 捕获/比较 1DMA 源</td></tr><tr><td>TIM_DMA_CC2</td><td>TIM 捕获/比较 2DMA 源</td></tr><tr><td>TIM_DMA_CC3</td><td>TIM 捕获/比较 3DMA 源</td></tr><tr><td>TIM_DMA_CC4</td><td>TIM 捕获/比较 4DMA 源</td></tr><tr><td>TIM_DMA_Trigger</td><td>TIM 触发 DMA 源</td></tr></table>

例：  
/* TIM2 Capture Compare 1 DMA Request Configuration */
TIM_DMAcmd(TIM2, TIM_DMA_CC1, ENABLE);

# 19.2.12 函数TIM/InternalClockConfig

Table 487. 描述了函数TIM/InternalClockConfig  
Table 487. 函数 TIM/InternalClockConfig  

<table><tr><td>函数名</td><td>TIM/InternalClockConfig</td></tr><tr><td>函数原形</td><td>void TIM_DMAcd(TIMTypeDef* TIMx, u16 TIM_DMASource, FunctionalState Newstate)</td></tr><tr><td>功能描述</td><td>设置TIMx内部时钟</td></tr><tr><td>输入参数</td><td>TIMx: x可以是2,3或者4,来选择TIM外设</td></tr><tr><td>输出参数</td><td>无</td></tr><tr><td>返回值</td><td>无</td></tr><tr><td>先决条件</td><td>无</td></tr><tr><td>被调用函数</td><td>无</td></tr></table>

例：  
/\* Selects the internal clock for TIM2 \*/TIM/InternalClockConfig(TIM2);

# 19.2.13 函数TIM_ITRxExternalClockConfig

Table 488. 描述了函数TIM_ITRxExternalClockConfig  
Table 488. 函数 TIM_ITRxExternalClockConfig  

<table><tr><td>函数名</td><td>TIM_ITRxExternalClockConfig</td></tr><tr><td>函数原形</td><td>void TIM_ITRxExternalClockConfig(TIMTypeDef* TIMx, u16 TIM_InputTriggerSource)</td></tr><tr><td>功能描述</td><td>设置TIMx内部触发为外部时钟模式</td></tr><tr><td>输入参数1</td><td>TIMx: x可以是2,3或者4,来选择TIM外设</td></tr><tr><td>输入参数2</td><td>TIM_InputTriggerSource: 输入触发源
参阅Section: TIM_InputTriggerSource 查阅更多该参数允许取值范围</td></tr><tr><td>输出参数</td><td>无</td></tr><tr><td>返回值</td><td>无</td></tr><tr><td>先决条件</td><td>无</td></tr><tr><td>被调用函数</td><td>无</td></tr></table>

# TIM_InputTriggerSource

TIM_InputTriggerSource 选择 TIM 输入触发。见 Table 489. 参阅该参数的取值。

Table 489. TIM_InputTriggerSource 值  

<table><tr><td>TIM_InputTriggerSource</td><td>描述</td></tr><tr><td>TIM_TS_ITR0</td><td>TIM 内部触发 0</td></tr><tr><td>TIM_TS_ITR1</td><td>TIM 内部触发 1</td></tr><tr><td>TIM_TS_ITR2</td><td>TIM 内部触发 2</td></tr><tr><td>TIM_TS_ITR3</td><td>TIM 内部触发 3</td></tr></table>

例：  
/* TIM2 internal trigger 3 used as clock source */  
TIM_ITRxExternalClockConfig(TIM2，TIM_TS_ITR3);

# 19.2.14 函数TIM_TIxExternalClockConfig

Table 490. 描述了函数TIM_TIxExternalClockConfig  
Table 490. 函数 TIM_TIxExternalClockConfig  

<table><tr><td>函数名</td><td>TIM_TIxExternalClockConfig</td></tr><tr><td>函数原形</td><td>void TIM_TIxExternalClockConfig(TIMTypeDef* TIMx, u16TIM_TIxExternalCLKSource, u8 TIM_ICPolarity, u8 ICFilter)</td></tr><tr><td>功能描述</td><td>设置TIMx触发为外部时钟</td></tr><tr><td>输入参数1</td><td>TIMx: x可以是2,3或者4,来选择TIM外设</td></tr><tr><td>输入参数2</td><td>TIM_TIxExternalCLKSource: 触发源参阅Section: TIM_TIxExternalCLKSource 查阅更多该参数允许取值范围</td></tr><tr><td>输入参数3</td><td>TIM_ICPolarity: 指定的TI极性参阅Section: TIM_ICPolarity 查阅更多该参数允许取值范围</td></tr><tr><td>输入参数4</td><td>ICFilter: 指定的输入比较滤波器。该参数取值在0x0和0xF之间。</td></tr><tr><td>输出参数</td><td>无</td></tr><tr><td>返回值</td><td>无</td></tr><tr><td>先决条件</td><td>无</td></tr><tr><td>被调用函数</td><td>无</td></tr></table>

# TIM_TXExternalCLKSource

TIM_TXExternalCLKSource选择TIMx外部时钟源。见Table491.参阅该参数的取值。

Table 491. TIM_TIxExternalCLKSource 值  

<table><tr><td>TIM_TIxExternalCLKSource</td><td>描述</td></tr><tr><td>TIM_TS_TI1FP1</td><td>TIM IC1 连接到 TI1</td></tr><tr><td>TIM_TS_TI1FP2</td><td>TIM IC2 连接到 TI2</td></tr><tr><td>TIM_TS_TI1F_ED</td><td>TIM IC1 连接到 TI1: 使用边沿探测</td></tr></table>

例：  
/\* Selects the TI1 as clock for TIM2: the external clock is connected to TI1 input pin, the rising edge is the active edge and no filter sampling is done (ICFilter  $= 0$  \*/TIM_TXExternalClockConfig(TIM2, TIM_TS_TI1FP1, TIM_ICPolarity_Rising, 0);

# 19.2.15 函数TIM_ETRClockMode1Config

Table 492. 描述了函数TIM_ETRClockMode1Config  
Table 492. 函数 TIM_ETRClockMode1Config  

<table><tr><td>函数名</td><td>TIM_ETRClockMode1Config</td></tr><tr><td>函数原形</td><td>void TIM_ETRClockMode1Config(TIMTypeDef* TIMx, u16 TIM_ExtTRGPrescaler, u16 TIM_ExtTRGPolarity, u16 ExtTRGFilter)</td></tr><tr><td>功能描述</td><td>配置TIMx外部时钟模式1</td></tr><tr><td>输入参数1</td><td>TIMx: x可以是2,3或者4,来选择TIM外设</td></tr><tr><td>输入参数2</td><td>TIM_ExtTRGPrescaler: 外部触发预分频
参阅Section: TIM_ExtTRGPrescaler 查阅更多该参数允许取值范围</td></tr><tr><td>输入参数3</td><td>TIM_ExtTRGPolarity: 外部时钟极性
参阅Section: TIM_ExtTRGPolarity 查阅更多该参数允许取值范围</td></tr><tr><td>输入参数4</td><td>ExtTRGFilter: 外部触发滤波器。该参数取值在0x0和0xF之间。</td></tr><tr><td>输出参数</td><td>无</td></tr><tr><td>返回值</td><td>无</td></tr><tr><td>先决条件</td><td>无</td></tr><tr><td>被调用函数</td><td>无</td></tr></table>

# TIM_ExtTRGPrescaler

TIM_ExtTRGPrescaler设置TIMx外部触发预分频。见Table493.参阅该参数的取值。

Table 493. TIM_ExtTRGPrescaler 值  

<table><tr><td>TIM_ExtTRGPrescaler</td><td>描述</td></tr><tr><td>TIM_ExtTRGPSC_OFF</td><td>TIMETRP预分频OFF</td></tr><tr><td>TIM_ExtTRGPSC_DIV2</td><td>TIMETRP频率除以2</td></tr><tr><td>TIM_ExtTRGPSC_DIV4</td><td>TIMETRP频率除以4</td></tr><tr><td>TIM_ExtTRGPSC_DIV8</td><td>TIMETRP频率除以8</td></tr></table>

# TIM_ExtTRGPolarity

TIM_ExtTRGPolarity设置TIMx外部触发极性。见Table494.参阅该参数的取值。

Table 494. TIM_ExtTRGPolarity 值  

<table><tr><td>TIM_ExtTRGPolarity</td><td>描述</td></tr><tr><td>TIM_ExtTRGPolarity_Inverted</td><td>TIM外部触发极性翻转：低电平或下降沿有效</td></tr><tr><td>TIM_ExtTRGPolarity_NonInverted</td><td>TIM外部触发极性非翻转：高电平或上升沿有效</td></tr></table>

例：  
/\* Selects the external clock Mode 1 for TIM2: the external clock is connected to ETR input pin, the rising edge is the active edge, no filter sampling is done (ExtTRGFilter  $= 0$  ) and the prescaler is fixed to TIM_ExtTRGPSC_DIV2 \*/TIM_ExternalCLK1Config(TIM2,TIM_ExtTRGPSC_DIV2,

TIM_ExtTRGPolarity_NonInverted, 0x0);

# 19.2.16 函数TIM_ETRClockMode2Config

Table 495. 描述了函数TIM_ETRClockMode2Config

Table 495. 函数 TIM_ETRClockMode2Config  

<table><tr><td>函数名</td><td>TIM_ETRClockMode2Config</td></tr><tr><td>函数原形</td><td>void TIM_ETRClockMode2Config(TIMTypeDef* TIMx, u16TIM_ExtTRGPrescaler, u16 TIM_ExtTRGPolarity, u16 ExtTRGFilter)</td></tr><tr><td>功能描述</td><td>配置TIMx外部时钟模式2</td></tr><tr><td>输入参数1</td><td>TIMx: x可以是2, 3或者4, 来选择TIM外设</td></tr><tr><td>输入参数2</td><td>TIM_ExtTRGPrescaler: 外部触发预分频参阅Section: TIM_ExtTRGPrescaler查阅更多该参数允许取值范围</td></tr><tr><td>输入参数3</td><td>TIM_ExtTRGPolarity: 外部时钟极性参阅Section: TIM_ExtTRGPolarity查看更多该参数允许取值范围</td></tr><tr><td>输入参数4</td><td>ExtTRGFilter: 外部触发滤波器。该参数取值在0x0和0xF之间。</td></tr><tr><td>输出参数</td><td>无</td></tr><tr><td>返回值</td><td>无</td></tr><tr><td>先决条件</td><td>无</td></tr><tr><td>被调用函数</td><td>无</td></tr></table>

例：

/\* Selects the external clock Mode 2 for TIM2: the external clock is connected to ETR input pin, the rising edge is the active edge, no filter sampling is done (ExtTRGFilter  $= 0$  ) and the prescaler is fixed to TIM_ExtTRGPSC_DIV2 \*/   
TIM_ExternalCLK2Config(TIM2,TIM_ExtTRGPSC_DIV2,   
TIM_ExtTRGPolarity_NonInverted,0x0);

# 19.2.17 函数TIM_ETRConfig

Table 496. 描述了函数TIM_ETRConfig

Table 496. 函数 TIM_ETRConfig  

<table><tr><td>函数名</td><td>TIM_ETRConfig</td></tr><tr><td>函数原形</td><td>void TIM_ETRConfig(TIMTypeDef* TIMx, u16 TIM_ExtTRGPrescaler, u16 TIM_ExtTRGPolarity, u8 ExtTRGFilter)</td></tr><tr><td>功能描述</td><td>配置TIMx外部触发</td></tr><tr><td>输入参数1</td><td>TIMx: x可以是2,3或者4,来选择TIM外设</td></tr><tr><td>输入参数2</td><td>TIM_ExtTRGPrescaler: 外部触发预分频
参阅Section: TIM_ExtTRGPrescaler 查阅更多该参数允许取值范围</td></tr><tr><td>输入参数3</td><td>TIM_ExtTRGPolarity: 外部时钟极性
参阅Section: TIM_ExtTRGPolarity 查阅更多该参数允许取值范围</td></tr><tr><td>输入参数4</td><td>ExtTRGFilter: 外部触发滤波器。该参数取值在0x0和0xF之间。</td></tr><tr><td>输出参数</td><td>无</td></tr><tr><td>返回值</td><td>无</td></tr><tr><td>先决条件</td><td>无</td></tr><tr><td>被调用函数</td><td>无</td></tr></table>

例：

/\* Configure the External Trigger (ETR) for TIM2: the rising edge is the active edge, no filter sampling is done (ExtTRGFilter  $= 0$  ) and the prescaler is fixed to TIM_ExtTRGPSC_DIV2 \*/TIM_ExternalCLK2Config(TIM2, TIM_ExtTRGPSC_DIV2, TIM_ExtTRGPolarity_NonInverted, 0x0);

# 19.2.18 函数TIM_SelectInputTrigger

Table 497. 描述了函数TIM_SelectInputTrigger

Table 497. 函数 TIM_SelectInputTrigger  

<table><tr><td>函数名</td><td>TIM_SelectInputTrigger</td></tr><tr><td>函数原形</td><td>void TIM_SelectInputTrigger(TIMTypeDef* TIMx, u16 TIM_InputTriggerSource)</td></tr><tr><td>功能描述</td><td>选择TIMx输入触发源</td></tr><tr><td>输入参数1</td><td>TIMx: x可以是2,3或者4,来选择TIM外设</td></tr><tr><td>输入参数2</td><td>TIM_InputTriggerSource: 输入触发源
参阅Section: TIM_InputTriggerSource 查阅更多该参数允许取值范围</td></tr><tr><td>输出参数</td><td>无</td></tr><tr><td>返回值</td><td>无</td></tr><tr><td>先决条件</td><td>无</td></tr><tr><td>被调用函数</td><td>无</td></tr></table>

# TIM_InputTriggerSource

TIM_InputTriggerSource选择TIMx输入触发源。见Table498.参阅该参数的取值。

Table 498. TIM_InputTriggerSource 值  

<table><tr><td>TIM_InputTriggerSource</td><td>描述</td></tr><tr><td>TIM_TS_ITR0</td><td>TIM 内部触发 0</td></tr><tr><td>TIM_TS_ITR1</td><td>TIM 内部触发 1</td></tr><tr><td>TIM_TS_ITR2</td><td>TIM 内部触发 2</td></tr><tr><td>TIM_TS_ITR3</td><td>TIM 内部触发 3</td></tr><tr><td>TIM_TS_TI1F_ED</td><td>TIM TL1 边沿探测器</td></tr><tr><td>TIM_TS_TI1FP1</td><td>TIM 经滤波定时器输入 1</td></tr><tr><td>TIM_TS_TI2FP2</td><td>TIM 经滤波定时器输入 2</td></tr><tr><td>TIM_TS_ETRF</td><td>TIM 外部触发输入</td></tr></table>

例：

/\* Selects the Internal Trigger 3 as input trigger fot TIM2 \*/ void TIM_SelectInputTrigger(TIM2，TIM_TS_ITR3);

# 19.2.19 函数TIM_PrescalerConfig

Table 499. 描述了函数TIM_PrescalerConfig  
Table 499. 函数 TIM_PrescalerConfig  

<table><tr><td>函数名</td><td>TIM_PrescalerConfig</td></tr><tr><td>函数原形</td><td>void TIM_PrescalerConfig(TIMTypeDef* TIMx, u16 Prescaler,u16TIM_PSCReloadMode)</td></tr><tr><td>功能描述</td><td>设置TIMx预分频</td></tr><tr><td>输入参数1</td><td>TIMx: x可以是2,3或者4,来选择TIM外设</td></tr><tr><td>输入参数2</td><td>TIM_PSCReloadMode: 预分频重载模式
参阅Section: TIM_PSCReloadMode 查阅更多该参数允许取值范围</td></tr><tr><td>输出参数</td><td>无</td></tr><tr><td>返回值</td><td>无</td></tr><tr><td>先决条件</td><td>无</td></tr><tr><td>被调用函数</td><td>无</td></tr></table>

# TIM_PSCReloadMode

TIM_PSCReloadMode选择预分频重载模式。见Table 500.参阅该参数的取值。

Table 500. TIM_PSCReloadMode 值  

<table><tr><td>TIM_PSCReloadMode</td><td>描述</td></tr><tr><td>TIM_PSCReloadMode_Update</td><td>TIM 预分值在更新事件装入</td></tr><tr><td>TIM_PSCReloadMode_Immediate</td><td>TIM 预分值即时装入</td></tr></table>

例：

```javascript
/\* Configures the TIM2 new Prescaler value \*/ u16 TIMPrescaler  $=$  0xFF00; TIM_PrescalerConfig(TIM2，TIMPrescaler, TIM_PSCReloadMode_Immediate);
```

# 19.2.20 函数TIM_ModeConfig

Table 501. 描述了函数TIM_ModeConfig  
Table 501. 函数 TIM_ModeConfig  

<table><tr><td>函数名</td><td>TIM_CounterModeConfig</td></tr><tr><td>函数原形</td><td>void TIM_CounterModeConfig(TIMTypeDef* TIMx, u16 TIM_CounterMode)</td></tr><tr><td>功能描述</td><td>设置TIMx计数器模式</td></tr><tr><td>输入参数1</td><td>TIMx: x可以是2,3或者4,来选择TIM外设</td></tr><tr><td>输入参数2</td><td>TIM_CounterMode: 待使用的计数器模式
参阅Section: TIM_CounterMode 查阅更多该参数允许取值范围</td></tr><tr><td>输出参数</td><td>无</td></tr><tr><td>返回值</td><td>无</td></tr><tr><td>先决条件</td><td>无</td></tr><tr><td>被调用函数</td><td>无</td></tr></table>

例：

```javascript
/\* Selects the Center Aligned counter Mode 1 for the TIM2 \*/TIM CounterModeConfig(TIM2，TIM CounterCenterAligned1);
```

# 19.2.21 函数TIM_ForcedOC1Config

Table 502. 描述了函数TIM_ForcedOC1Config

Table 502. 函数 TIM_ForcedOC1Config  

<table><tr><td>函数名</td><td>TIM_ForcedOC1Config</td></tr><tr><td>函数原形</td><td>void TIM_ForcedOC1Config(TIMTypeDef* TIMx, u16 TIM_ForcedAction)</td></tr><tr><td>功能描述</td><td>置TIMx输出1为活动或者非活动电平</td></tr><tr><td>输入参数1</td><td>TIMx: x可以是2,3或者4,来选择TIM外设</td></tr><tr><td>输入参数2</td><td>TIM_ForcedAction: 输出信号的设置动作
参阅Section: TIM_ForcedAction 查阅更多该参数允许取值范围</td></tr><tr><td>输出参数</td><td>无</td></tr><tr><td>返回值</td><td>无</td></tr><tr><td>先决条件</td><td>无</td></tr><tr><td>被调用函数</td><td>无</td></tr></table>

# TIM ForcedAction

输出信号的设置动作取值见下表。

Table 503. TIM_ForcedAction 值  

<table><tr><td>TIM_ForcedAction</td><td>描述</td></tr><tr><td>TIM_ForcedAction_Active</td><td>置为 OCxREF 上的活动电平</td></tr><tr><td>TIM_ForcedAction_InActive</td><td>置为 OCxREF 上的非活动电平</td></tr></table>

例：

/* Forces the TIM2 Output Compare 1 signal to the active level */
TIM ForcedOC1Config(TIM2, TIM_ForcedAction_Active);

# 19.2.22 函数TIM_ForcedOC2Config

Table 504. 描述了函数TIM_ForceDC2Config

Table 504. 函数 TIM_ForcedOC2Config  

<table><tr><td>函数名</td><td>TIM_ForcedOC2Config</td></tr><tr><td>函数原形</td><td>void TIM_ForcedOC2Config(TIMTypeDef* TIMx, u16 TIM_ForcedAction)</td></tr><tr><td>功能描述</td><td>置TIMx输出2为活动或者非活动电平</td></tr><tr><td>输入参数1</td><td>TIMx: x可以是2, 3或者4, 来选择TIM外设</td></tr><tr><td>输入参数2</td><td>TIM_ForcedAction: 输出信号的设置动作
参阅Section: TIM_ForcedAction 查阅更多该参数允许取值范围</td></tr><tr><td>输出参数</td><td>无</td></tr><tr><td>返回值</td><td>无</td></tr><tr><td>先决条件</td><td>无</td></tr><tr><td>被调用函数</td><td>无</td></tr></table>

例：

/* Forces the TIM2 Output Compare 2 signal to the active level */
TIM ForcedOC2Config(TIM2, TIM_ForcedAction_Active);

# 19.2.23 函数TIM_ForcedOC3Config

Table 505. 描述了函数TIM_ForcedOC3Config

Table 505. 函数 TIM_ForceDC3Config  

<table><tr><td>函数名</td><td>TIM_ForcedOC3Config</td></tr><tr><td>函数原形</td><td>void TIM_ForcedOC3Config(TIMTypeDef* TIMx, u16 TIM_ForcedAction)</td></tr><tr><td>功能描述</td><td>置TIMx输出3为活动或者非活动电平</td></tr><tr><td>输入参数1</td><td>TIMx: x可以是2, 3或者4, 来选择TIM外设</td></tr><tr><td>输入参数2</td><td>TIM_ForcedAction: 输出信号的设置动作
参阅Section: TIM_ForcedAction 查阅更多该参数允许取值范围</td></tr><tr><td>输出参数</td><td>无</td></tr><tr><td>返回值</td><td>无</td></tr><tr><td>先决条件</td><td>无</td></tr><tr><td>被调用函数</td><td>无</td></tr></table>

例：

```txt
/\* Forces the TIM2 Output Compare 3 signal to the active level \*/TIM_ForcedOC3Config(TIM2，TIM_ForcedAction_Active);
```

# 19.2.24 函数TIM_ForcedOC4Config

Table 506. 描述了函数TIM_ForcedOC4Config

Table 506. 函数 TIM_ForceDC4Config  

<table><tr><td>函数名</td><td>TIM_ForcedOC4Config</td></tr><tr><td>函数原形</td><td>void TIM_ForcedOC4Config(TIM_TYPEDef* TIMx, u16 TIM_ForcedAction)</td></tr><tr><td>功能描述</td><td>置TIMx输出4为活动或者非活动电平</td></tr><tr><td>输入参数1</td><td>TIMx: x可以是2, 3或者4, 来选择TIM外设</td></tr><tr><td>输入参数2</td><td>TIM_ForcedAction: 输出信号的设置动作
参阅Section: TIM_ForcedAction 查阅更多该参数允许取值范围</td></tr><tr><td>输出参数</td><td>无</td></tr><tr><td>返回值</td><td>无</td></tr><tr><td>先决条件</td><td>无</td></tr><tr><td>被调用函数</td><td>无</td></tr></table>

例：

```javascript
/\*Forces the TIM2 Output Compare 4 signal to the active level \*/TIM_ForcedOC4Config(TIM2，TIM_ForcedAction_Active);
```

# 19.2.25 函数TIM_ARRPreloadConfig

Table 507. 描述了函数TIMARRPreloadConfig

Table 507. 函数 TIM_ARRPreloadConfig  

<table><tr><td>函数名</td><td>TIM_ARRPreloadConfig</td></tr><tr><td>函数原形</td><td>void TIM_ARRPreloadConfig(TIMTypeDef* TIMx, FunctionalState Newstate)</td></tr><tr><td>功能描述</td><td>使能或者失能TIMx在ARR上的预装载寄存器</td></tr><tr><td>输入参数1</td><td>TIMx: x可以是2,3或者4,来选择TIM外设</td></tr><tr><td>输入参数2</td><td>NewState: TIM_CR1 寄存器 ARPE位的新状态
这个参数可以取: ENABLE或者 DISABLE</td></tr><tr><td>输出参数</td><td>无</td></tr><tr><td>返回值</td><td>无</td></tr><tr><td>先决条件</td><td>无</td></tr><tr><td>被调用函数</td><td>无</td></tr></table>

例：  
/\*Enables the TIM2 Preload on ARR Register \*/TIM_ARRPreloadConfig(TIM2，ENABLE);

# 19.2.26 函数TIM_SelectCCDMA

Table 508. 描述了函数TIM_SelectCCDMA

Table 508. 函数 TIM_SelectCCDMA  

<table><tr><td>函数名</td><td>TIM_SelectCCDMA</td></tr><tr><td>函数原形</td><td>void TIM_SelectCCDMA(TIM_TYPEDef* TIMx, FunctionalState Newstate)</td></tr><tr><td>功能描述</td><td>选择TIMx外设的捕获比较DMA源</td></tr><tr><td>输入参数1</td><td>TIMx: x可以是2,3或者4,来选择TIM外设</td></tr><tr><td>输入参数2</td><td>NewState: 捕获比较DMA源的新状态
这个参数可以取: ENABLE或者 DISABLE</td></tr><tr><td>输出参数</td><td>无</td></tr><tr><td>返回值</td><td>无</td></tr><tr><td>先决条件</td><td>无</td></tr><tr><td>被调用函数</td><td>无</td></tr></table>

例：  
/\* Selects the TIM2 Capture Compare DMA source \*/TIM_SelectCCDMA(TIM2，ENABLE);

# 19.2.27 函数TIM_OC1PreloadConfig

Table 509. 描述了函数TIM_OC1PreloadConfig

Table 509. 函数 TIM_OC1PreloadConfig  

<table><tr><td>函数名</td><td>TIM_OC1PreloadConfig</td></tr><tr><td>函数原形</td><td>void TIM_OC1PreloadConfig(TIMTypeDef* TIMx, u16 TIM_OCPreload)</td></tr><tr><td>功能描述</td><td>使能或者失能TIMx在CCR1上的预装载寄存器</td></tr><tr><td>输入参数1</td><td>TIMx: x可以是2,3或者4,来选择TIM外设</td></tr><tr><td>输入参数2</td><td>TIM_OCPreload: 输出比较预装载状态
参阅Section: TIM_OCPreload 查阅更多该参数允许取值范围</td></tr><tr><td>输出参数</td><td>无</td></tr><tr><td>返回值</td><td>无</td></tr><tr><td>先决条件</td><td>无</td></tr><tr><td>被调用函数</td><td>无</td></tr></table>

# TIM OCPreload

输出比较预装载状态可以使能或者失能如下表。

Table 510. TIM_OCPreload 值  

<table><tr><td>TIM_OCPreload</td><td>描述</td></tr><tr><td>TIM_OCPreload_Enable</td><td>TIMx 在 CCR1 上的预装载寄存器使能</td></tr><tr><td>TIM_OCPreload_Disable</td><td>TIMx 在 CCR1 上的预装载寄存器失能</td></tr></table>

例：

```javascript
/\*Enables the TIM2 Preload on CC1 Register \*/TIM_OC1PreloadConfig(TIM2，TIM_OCPreload_Enable);
```

# 19.2.28 函数TIM_OC2PreloadConfig

Table 511. 描述了函数TIM_OC2PreloadConfig

Table 511. 函数 TIM_OC2PreloadConfig  

<table><tr><td>函数名</td><td>TIM_OC2PreloadConfig</td></tr><tr><td>函数原形</td><td>void TIM_OC2PreloadConfig(TIMTypeDef* TIMx, u16 TIM_OCPreload)</td></tr><tr><td>功能描述</td><td>使能或者失能TIMx在CCR2上的预装载寄存器</td></tr><tr><td>输入参数1</td><td>TIMx: x可以是2,3或者4,来选择TIM外设</td></tr><tr><td>输入参数2</td><td>TIM_OCPreload: 输出比较预装载状态
参阅Section: TIM_OCPreload 查阅更多该参数允许取值范围</td></tr><tr><td>输出参数</td><td>无</td></tr><tr><td>返回值</td><td>无</td></tr><tr><td>先决条件</td><td>无</td></tr><tr><td>被调用函数</td><td>无</td></tr></table>

例：

```javascript
/\*Enables the TIM2 Preload on CC2 Register \*/TIM_OC2PreloadConfig(TIM2，TIM_OCPreload_Enable);
```

# 19.2.29 函数TIM_OC3PreloadConfig

Table 512. 描述了函数TIM_OC3PreloadConfig  
Table 512. 函数 TIM_OC3PreloadConfig  

<table><tr><td>函数名</td><td>TIM_OC3PreloadConfig</td></tr><tr><td>函数原形</td><td>void TIM_OC3PreloadConfig(TIMTypeDef* TIMx, u16 TIM_OCPreload)</td></tr><tr><td>功能描述</td><td>使能或者失能TIMx在CCR3上的预装载寄存器</td></tr><tr><td>输入参数1</td><td>TIMx: x可以是2, 3或者4, 来选择TIM外设</td></tr><tr><td>输入参数2</td><td>TIM_OCPreload: 输出比较预装载状态
参阅Section: TIM_OCPreload 查阅更多该参数允许取值范围</td></tr><tr><td>输出参数</td><td>无</td></tr><tr><td>返回值</td><td>无</td></tr><tr><td>先决条件</td><td>无</td></tr><tr><td>被调用函数</td><td>无</td></tr></table>

例：  
/\*Enables the TIM2 Preload on CC3 Register \*/TIM_OC3PreloadConfig(TIM2，TIM_OCPreload_Enable);

# 19.2.30 函数TIM_OC4PreloadConfig

Table 513. 描述了函数TIM_OC4PreloadConfig  
Table 513. 函数 TIM_OC4PreloadConfig  

<table><tr><td>函数名</td><td>TIM_OC4PreloadConfig</td></tr><tr><td>函数原形</td><td>void TIM_OC4PreloadConfig(TIMTypeDef* TIMx, u16 TIM_OCPreload)</td></tr><tr><td>功能描述</td><td>使能或者失能TIMx在CCR4上的预装载寄存器</td></tr><tr><td>输入参数1</td><td>TIMx: x可以是2,3或者4,来选择TIM外设</td></tr><tr><td>输入参数2</td><td>TIM_OCPreload: 输出比较预装载状态
参阅Section: TIM_OCPreload 查阅更多该参数允许取值范围</td></tr><tr><td>输出参数</td><td>无</td></tr><tr><td>返回值</td><td>无</td></tr><tr><td>先决条件</td><td>无</td></tr><tr><td>被调用函数</td><td>无</td></tr></table>

例：  
/\*Enables the TIM2 Preload on CC4 Register \*/TIM_OC4PreloadConfig(TIM2，TIM_OCPreload_Enable);

# 19.2.31 函数TIM_OC1FastConfig

Table 514. 描述了函数TIM_OC1FastConfig  
Table 514. 函数 TIM_OC1FastConfig  

<table><tr><td>函数名</td><td>TIM_OC1FastConfig</td></tr><tr><td>函数原形</td><td>void TIM_OC1FastConfig(TIMTypeDef* TIMx, u16 TIM_OCFast)</td></tr><tr><td>功能描述</td><td>设置TIMx捕获比较1快速特征</td></tr><tr><td>输入参数1</td><td>TIMx: x可以是2,3或者4,来选择TIM外设</td></tr><tr><td>输入参数2</td><td>TIM_OCFast: 输出比较快速特征状态
参阅Section: TIM_OCFast 查阅更多该参数允许取值范围</td></tr><tr><td>输出参数</td><td>无</td></tr><tr><td>返回值</td><td>无</td></tr><tr><td>先决条件</td><td>无</td></tr><tr><td>被调用函数</td><td>无</td></tr></table>

# TIM OCFast

输出比较快速特征性能可以使能或者失能如下表。

Table 515. TIM_OCPreload 值  

<table><tr><td>TIM_OCFast</td><td>描述</td></tr><tr><td>TIM_OCFast_Enable</td><td>TIMx输出比较快速特征性能使能</td></tr><tr><td>TIM_OCFast_Disable</td><td>TIMx输出比较快速特征性能失能</td></tr></table>

例：

```txt
/\*Use theTIM2OC1in fastMode\*/ TIM_OC1FastConfig(TIM2，TIM_OCFast_Enable);
```

# 19.2.32 函数TIM_OC2FastConfig

Table 516. 描述了函数TIM_OC2FastConfig  
Table 516. 函数 TIM_OC2FastConfig  

<table><tr><td>函数名</td><td>TIM_OC2FastConfig</td></tr><tr><td>函数原形</td><td>void TIM_OC2FastConfig(TIMTypeDef* TIMx, u16 TIM_OCFast)</td></tr><tr><td>功能描述</td><td>设置TIMx捕获比较2快速特征</td></tr><tr><td>输入参数1</td><td>TIMx: x可以是2,3或者4,来选择TIM外设</td></tr><tr><td>输入参数2</td><td>TIM_OCFast: 输出比较快速特征状态
参阅Section: TIM_OCFast 查阅更多该参数允许取值范围</td></tr><tr><td>输出参数</td><td>无</td></tr><tr><td>返回值</td><td>无</td></tr><tr><td>先决条件</td><td>无</td></tr><tr><td>被调用函数</td><td>无</td></tr></table>

例：

```txt
/\*Use theTIM2OC2in fastMode\*/ TIM_OC2FastConfig(TIM2，TIM_OCFast_Enable);
```

# 19.2.33 函数TIM_OC3FastConfig

Table 517. 描述了函数TIM_OC3FastConfig  
Table 517. 函数 TIM_OC3FastConfig  

<table><tr><td>函数名</td><td>TIM_OC3FastConfig</td></tr><tr><td>函数原形</td><td>void TIM_OC3FastConfig(TIMTypeDef* TIMx, u16 TIM_OCFast)</td></tr><tr><td>功能描述</td><td>设置TIMx捕获比较3快速特征</td></tr><tr><td>输入参数1</td><td>TIMx: x可以是2, 3或者4, 来选择TIM外设</td></tr><tr><td>输入参数2</td><td>TIM_OCFast: 输出比较快速特征状态
参阅Section: TIM_OCFast 查阅更多该参数允许取值范围</td></tr><tr><td>输出参数</td><td>无</td></tr><tr><td>返回值</td><td>无</td></tr><tr><td>先决条件</td><td>无</td></tr><tr><td>被调用函数</td><td>无</td></tr></table>

例：
/* Use the TIM2 OC3 in fast Mode */
TIM_OC3FastConfig(TIM2, TIM_OCFast_Enable);

# 19.2.34 函数TIM_OC4FastConfig

Table 518. 描述了函数TIM_OC4FastConfig  
Table 518. 函数 TIM_OC4FastConfig  

<table><tr><td>函数名</td><td>TIM_OC4FastConfig</td></tr><tr><td>函数原形</td><td>void TIM_OC4FastConfig(TIMTypeDef* TIMx, u16 TIM_OCFast)</td></tr><tr><td>功能描述</td><td>设置TIMx捕获比较4快速特征</td></tr><tr><td>输入参数1</td><td>TIMx: x可以是2,3或者4,来选择TIM外设</td></tr><tr><td>输入参数2</td><td>TIM_OCFast: 输出比较快速特征状态
参阅Section: TIM_OCFast 查阅更多该参数允许取值范围</td></tr><tr><td>输出参数</td><td>无</td></tr><tr><td>返回值</td><td>无</td></tr><tr><td>先决条件</td><td>无</td></tr><tr><td>被调用函数</td><td>无</td></tr></table>

例：
/* Use the TIM2 OC4 in fast Mode */
TIM_OC4FastConfig(TIM2, TIM_OCFast_Enable);

# 19.2.35 函数TIM_ClearOC1Ref

Table 519. 描述了函数TIM_ClearOC1Ref  
Table 519. 函数 TIM_ClearOC1Ref  

<table><tr><td>函数名</td><td>TIM_ClearOC1Ref</td></tr><tr><td>函数原形</td><td>void TIM_ClearOC1Ref(TIM_TYPEDef* TIMx, u16 TIM_OCClear)</td></tr><tr><td>功能描述</td><td>在一个外部事件时清除或者保持OCREF1信号</td></tr><tr><td>输入参数1</td><td>TIMx: x可以是2,3或者4,来选择TIM外设</td></tr><tr><td>输入参数2</td><td>TIM_OCClear: 输出比较清除使能位状态
参阅Section: TIM_OCClear 查阅更多该参数允许取值范围</td></tr><tr><td>输出参数</td><td>无</td></tr><tr><td>返回值</td><td>无</td></tr><tr><td>先决条件</td><td>无</td></tr><tr><td>被调用函数</td><td>无</td></tr></table>

# TIM_OCClear

输出比较清除使能位的值列举如下表。

Table 520. TIM_OCClear 值  

<table><tr><td>TIM_OClear</td><td>描述</td></tr><tr><td>TIM_OClear_Enable</td><td>TIMx 输出比较清除使能</td></tr><tr><td>TIM_OClear_Disable</td><td>TIMx 输出比较清除失能</td></tr></table>

例：

```txt
/\* Enable the TIM2 Channel1 Output Compare Refence clear bit \*/TIM_ClearOC1Ref(TIM2，TIM_OCClear_Enable);
```

# 19.2.36 函数TIM_ClearOC2Ref

Table 521. 描述了函数TIM_ClearOC2Ref  
Table 521. 函数 TIM_ClearOC2Ref  

<table><tr><td>函数名</td><td>TIM_ClearOC2Ref</td></tr><tr><td>函数原形</td><td>void TIM_ClearOC2Ref(TIM_TYPEDef* TIMx, u16 TIM_OCClear)</td></tr><tr><td>功能描述</td><td>在一个外部事件时清除或者保持 OCREF2 信号</td></tr><tr><td>输入参数 1</td><td>TIMx: x 可以是 2, 3 或者 4, 来选择 TIM 外设</td></tr><tr><td>输入参数 2</td><td>TIM_OCClear: 输出比较清除使能位状态
参阅 Section: TIM_OCClear 查阅更多该参数允许取值范围</td></tr><tr><td>输出参数</td><td>无</td></tr><tr><td>返回值</td><td>无</td></tr><tr><td>先决条件</td><td>无</td></tr><tr><td>被调用函数</td><td>无</td></tr></table>

例：

```c
/* Enable the TIM2 Channel2 Output Compare Refence clear bit */
TIM_ClearOC2Ref(TIM2, TIM_OCClear_Enable);
```

# 19.2.37 函数TIM_ClearOC3Ref

Table 522. 描述了函数TIM_ClearOC3Ref  
Table 522. 函数 TIM_ClearOC3Ref  

<table><tr><td>函数名</td><td>TIM_ClearOC3Ref</td></tr><tr><td>函数原形</td><td>void TIM_ClearOC3Ref(TIM_TYPEDef* TIMx, u16 TIM_OCClear)</td></tr><tr><td>功能描述</td><td>在一个外部事件时清除或者保持OCREF3信号</td></tr><tr><td>输入参数1</td><td>TIMx: x可以是2, 3或者4, 来选择TIM外设</td></tr><tr><td>输入参数2</td><td>TIM_OCClear: 输出比较清除使能位状态
参阅Section: TIM_OCClear 查阅更多该参数允许取值范围</td></tr><tr><td>输出参数</td><td>无</td></tr><tr><td>返回值</td><td>无</td></tr><tr><td>先决条件</td><td>无</td></tr><tr><td>被调用函数</td><td>无</td></tr></table>

例：  
/\* Enable the TIM2 Channel3 Output Compare Refence clear bit \*/TIM_ClearOC3Ref(TIM2，TIM_OCClear_Enable);

# 19.2.38 函数TIM_ClearOC4Ref

Table 523. 描述了函数TIM_ClearOC4Ref  
Table 523. 函数 TIM_ClearOC4Ref  

<table><tr><td>函数名</td><td>TIM_ClearOC4Ref</td></tr><tr><td>函数原形</td><td>void TIM_ClearOC4Ref(TIM_TYPEDef* TIMx, u16 TIM_OCClear)</td></tr><tr><td>功能描述</td><td>在一个外部事件时清除或者保持OCREF4信号</td></tr><tr><td>输入参数1</td><td>TIMx: x可以是2,3或者4,来选择TIM外设</td></tr><tr><td>输入参数2</td><td>TIM_OCClear: 输出比较清除使能位状态
参阅Section: TIM_OCClear 查阅更多该参数允许取值范围</td></tr><tr><td>输出参数</td><td>无</td></tr><tr><td>返回值</td><td>无</td></tr><tr><td>先决条件</td><td>无</td></tr><tr><td>被调用函数</td><td>无</td></tr></table>

例：  
/\* Enable the TIM2 Channel4 Output Compare Refence clear bit \*/TIM_ClearOC4Ref(TIM2，TIM_OCClear_Enable);

# 19.2.39 函数TIM_UpdateDisableConfig

Table 524. 描述了函数TIM_UpdateDisableConfig  
Table 524. 函数 TIM_UpdateDisableConfig  

<table><tr><td>函数名</td><td>TIM_UpdateDisableConfig</td></tr><tr><td>函数原形</td><td>void TIM_UpdateDisableConfig(TIMTypeDef* TIMx, FunctionalState Newstate)</td></tr><tr><td>功能描述</td><td>使能或者失能TIMx更新事件</td></tr><tr><td>输入参数1</td><td>TIMx: x可以是2,3或者4,来选择TIM外设</td></tr><tr><td>输入参数2</td><td>NewState: TIMx_CR1 寄存器UDIS位的新状态这个参数可以取: ENABLE或者 DISABLE</td></tr><tr><td>输出参数</td><td>无</td></tr><tr><td>返回值</td><td>无</td></tr><tr><td>先决条件</td><td>无</td></tr><tr><td>被调用函数</td><td>无</td></tr></table>

例：  
/* Enables the Update event for TIM2 */  
TIM_UpdateDisableConfig(TIM2, DISABLE);

# 19.2.40 函数TIM EncoderInterfaceConfig

Table 525. 描述了函数TIM EncoderInterfaceConfig  
Table 525. 函数 TIM EncoderInterfaceConfig  

<table><tr><td>函数名</td><td>TIM EncoderInterfaceConfig</td></tr><tr><td>函数原形</td><td>void TIM EncoderInterfaceConfig(TIMTypeDef* TIMx, u8 TIM EncoderMode, u8 TIM_IC1Polarity, u8 TIM_IC2Polarity)</td></tr><tr><td>功能描述</td><td>设置TIMx编码界面</td></tr><tr><td>输入参数1</td><td>TIMx: x可以是2,3或者4,来选择TIM外设</td></tr><tr><td>输入参数2</td><td>TIM EncoderMode: 触发源
参阅 Section: TIM EncoderMode 查阅更多该参数允许取值范围</td></tr><tr><td>输入参数3</td><td>TIM_IC1Polarity: TI1极性
参阅 Section: TIM_ICPolarity 查阅更多该参数允许取值范围</td></tr><tr><td>输入参数4</td><td>TIM_IC2Polarity: TI2极性
参阅 Section: TIM_ICPolarity 查阅更多该参数允许取值范围</td></tr><tr><td>输出参数</td><td>无</td></tr><tr><td>返回值</td><td>无</td></tr><tr><td>先决条件</td><td>无</td></tr><tr><td>被调用函数</td><td>无</td></tr></table>

# TIM EncoderMode

TIM EncoderMode 选择TIMx编码模式。见Table 526. 参阅该参数的取值。

Table 526. TIM EncoderMode 值  

<table><tr><td>TIM EncoderMode</td><td>描述</td></tr><tr><td>TIM EncoderMode_TI1</td><td>使用TIM编码模式1</td></tr><tr><td>TIM EncoderMode_TI1</td><td>使用TIM编码模式2</td></tr><tr><td>TIM EncoderMode_TI12</td><td>使用TIM编码模式3</td></tr></table>

例：  
/* Configures the encoder mode TI1 for TIM2 */  
TIM EncoderInterfaceConfig(TIM2, TIM EncoderMode_T11,

# ST

译文英文原版为UM0427 Oct. 2007 Rev 2, 译文仅供参考，与英文版冲突的，以英文版为准

TIM_ICPolarity_Rising, TIM_ICPolarity_Rising);

# 19.2.41 函数TIM_GenerateEvent

Table 527. 描述了函数TIM_GenerateEvent

Table 527. 函数 TIM_GenerateEvent  

<table><tr><td>函数名</td><td>TIM_GenerateEvent</td></tr><tr><td>函数原形</td><td>void TIM_GenerateEvent(TIMTypeDef* TIMx, u16 TIM_EventSource)</td></tr><tr><td>功能描述</td><td>设置TIMx事件由软件产生</td></tr><tr><td>输入参数1</td><td>TIMx: x可以是2,3或者4,来选择TIM外设</td></tr><tr><td>输入参数2</td><td>TIM_EventSource: TIM软件事件源
参阅Section: TIM_EventSource 查阅更多该参数允许取值范围</td></tr><tr><td>输出参数</td><td>无</td></tr><tr><td>返回值</td><td>无</td></tr><tr><td>先决条件</td><td>无</td></tr><tr><td>被调用函数</td><td>无</td></tr></table>

# TIM_EventSource

TIM_EventSource 选择 TIM 软件事件源。见 Table 528. 参阅该参数的取值。

Table 528. TIM_EventSource 值  

<table><tr><td>TIM_EventSource</td><td>描述</td></tr><tr><td>TIM_EventSource_Update</td><td>TIM 更新事件源</td></tr><tr><td>TIM_EventSource_CC1</td><td>TIM 捕获比较 1 事件源</td></tr><tr><td>TIM_EventSource_CC2</td><td>TIM 捕获比较 2 事件源</td></tr><tr><td>TIM_EventSource_CC3</td><td>TIM 捕获比较 3 事件源</td></tr><tr><td>TIM_EventSource_CC4</td><td>TIM 捕获比较 4 事件源</td></tr><tr><td>TIM_EventSource_Trigger</td><td>TIM 触发事件源</td></tr></table>

例：

/\* Selects the Trigger software Event generation for TIM2 \*/TIM_GenerateEvent(TIM2，TIM_EventSource_Trigger);

# 19.2.42 函数TIM_OC1PolarityConfig

Table 529. 描述了函数TIM_OC1PolarityConfig

Table 529. 函数 TIM_OC1PolarityConfig  

<table><tr><td>函数名</td><td>TIM_OC1PolarityConfig</td></tr><tr><td>函数原形</td><td>void TIM_OC1PolarityConfig(TIMTypeDef* TIMx, u16 TIM_OCPolarity)</td></tr><tr><td>功能描述</td><td>设置TIMx通道1极性</td></tr><tr><td>输入参数1</td><td>TIMx: x可以是2,3或者4,来选择TIM外设</td></tr><tr><td>输入参数2</td><td>TIM_OCPolarity: 输出比较极性
参阅Section: TIM_OCPolarity 查阅更多该参数允许取值范围</td></tr><tr><td>输出参数</td><td>无</td></tr><tr><td>返回值</td><td>无</td></tr><tr><td>先决条件</td><td>无</td></tr><tr><td>被调用函数</td><td>无</td></tr></table>

例：

/\* Selects the Polarity high for TIM2 channel 1 output compare \*/TIM_OClPolarityConfig(TIM2，TIM_OCPolarity_High);

# 19.2.43 函数TIM_OC2PolarityConfig

Table 530. 描述了函数TIM_OC2PolarityConfig  
Table 530. 函数 TIM_OC2PolarityConfig  

<table><tr><td>函数名</td><td>TIM_OC2PolarityConfig</td></tr><tr><td>函数原形</td><td>void TIM_OC2PolarityConfig(TIMTypeDef* TIMx, u16 TIM_OCPolarity)</td></tr><tr><td>功能描述</td><td>设置TIMx通道2极性</td></tr><tr><td>输入参数1</td><td>TIMx: x可以是2,3或者4,来选择TIM外设</td></tr><tr><td>输入参数2</td><td>TIM_OCPolarity: 输出比较极性
参阅Section: TIM_OCPolarity 查阅更多该参数允许取值范围</td></tr><tr><td>输出参数</td><td>无</td></tr><tr><td>返回值</td><td>无</td></tr><tr><td>先决条件</td><td>无</td></tr><tr><td>被调用函数</td><td>无</td></tr></table>

例：
/* Selects the Polarity high for TIM2 channel 2 output compare */
TIM_OC1PolarityConfig(TIM2, TIM_OCPolarity_High);

# 19.2.44 函数TIM_OC3PolarityConfig

Table 531. 描述了函数TIM_OC1PolarityConfig  
Table 531. 函数 TIM_OC1PolarityConfig  

<table><tr><td>函数名</td><td>TIM_OC3PolarityConfig</td></tr><tr><td>函数原形</td><td>void TIM_OC3PolarityConfig(TIMTypeDef* TIMx, u16 TIM_OCPolarity)</td></tr><tr><td>功能描述</td><td>设置TIMx通道3极性</td></tr><tr><td>输入参数1</td><td>TIMx: x可以是2, 3或者4, 来选择TIM外设</td></tr><tr><td>输入参数2</td><td>TIM_OCPolarity: 输出比较极性
参阅Section: TIM_OCPolarity 查阅更多该参数允许取值范围</td></tr><tr><td>输出参数</td><td>无</td></tr><tr><td>返回值</td><td>无</td></tr><tr><td>先决条件</td><td>无</td></tr><tr><td>被调用函数</td><td>无</td></tr></table>

例：
/* Selects the Polarity high for TIM2 channel 3 output compare */
TIM_OC1PolarityConfig(TIM2, TIM_OCPolarity_High);

# 19.2.45 函数TIM_OC4PolarityConfig

Table 532. 描述了函数TIM_OC4PolarityConfig  
Table 532. 函数 TIM_OC4PolarityConfig  

<table><tr><td>函数名</td><td>TIM_OC4PolarityConfig</td></tr><tr><td>函数原形</td><td>void TIM_OC4PolarityConfig(TIMTypeDef* TIMx, u16TIM_OCPolarity)</td></tr><tr><td>功能描述</td><td>设置TIMx通道4极性</td></tr><tr><td>输入参数1</td><td>TIMx: x可以是2,3或者4,来选择TIM外设</td></tr><tr><td>输入参数2</td><td>TIM_OCPolarity: 输出比较极性
参阅Section: TIM_OCPolarity 查阅更多该参数允许取值范围</td></tr><tr><td>输出参数</td><td>无</td></tr><tr><td>返回值</td><td>无</td></tr><tr><td>先决条件</td><td>无</td></tr><tr><td>被调用函数</td><td>无</td></tr></table>

例：
/* Selects the Polarity high for TIM2 channel 4 output compare */
TIM_OC1PolarityConfig(TIM2, TIM_OCPolarity_High);

# 19.2.46 函数TIM_UpdateRequestConfig

Table 533. 描述了函数TIM_UpdateRequestConfig  
Table 533. 函数 TIM_UpdateRequestConfig  

<table><tr><td>函数名</td><td>TIM_UpdateRequestConfig</td></tr><tr><td>函数原形</td><td>void TIM_UpdateRequestConfig(TIM_TYPEDef* TIMx, u16 TIM_UpdateSource)</td></tr><tr><td>功能描述</td><td>设置TIMx更新请求源</td></tr><tr><td>输入参数1</td><td>TIMx: x可以是2,3或者4,来选择TIM外设</td></tr><tr><td>输入参数2</td><td>TIM_UpdateSource: TIM更新请求源
参阅Section: TIM_UpdateSource 查阅更多该参数允许取值范围</td></tr><tr><td>输出参数</td><td>无</td></tr><tr><td>返回值</td><td>无</td></tr><tr><td>先决条件</td><td>无</td></tr><tr><td>被调用函数</td><td>无</td></tr></table>

# TIM_UpdateSource

TIM_UpdateSource 选择 TIM 更新源。见 Table 534. 参阅该参数的取值。

Table 534. TIM_UpdateSource 值  

<table><tr><td>TIM_UpdateSource</td><td>描述</td></tr><tr><td>TIM_UpdateSourceGLOBAL</td><td>生成重复的脉冲：在更新事件时计数器不停止</td></tr><tr><td>TIM_UpdateSource-Regular</td><td>生成单一的脉冲：计数器在下一个更新事件停止</td></tr></table>

例：
/* Selects the regular update source for TIM2 */
TIM_UpdateRequestConfig(TIM2, TIM_UpdateSource-Regular);

# 19.2.47 函数TIM_SelectHallSensor

Table 535. 描述了函数TIM_SelectHallSensor

Table 535. 函数 TIM_SelectHallSensor  

<table><tr><td>函数名</td><td>TIM_SelectHallSensor</td></tr><tr><td>函数原形</td><td>void TIM_SelectHallSensor(TIMTypeDef* TIMx, FunctionalState Newstate)</td></tr><tr><td>功能描述</td><td>使能或者失能TIMx霍尔传感器接口</td></tr><tr><td>输入参数1</td><td>TIMx: x可以是2,3或者4,来选择TIM外设</td></tr><tr><td>输入参数2</td><td>NewState: TIMx霍尔传感器接口的新状态
这个参数可以取: ENABLE或者 DISABLE</td></tr><tr><td>输出参数</td><td>无</td></tr><tr><td>返回值</td><td>无</td></tr><tr><td>先决条件</td><td>无</td></tr><tr><td>被调用函数</td><td>无</td></tr></table>

例：

/\* Selects the Hall Sensor Interface for TIM2 \*/

TIM_SelectHallSensor(TIM2，ENABLE);

# 19.2.48 函数TIM_SelectOnePulseMode

Table 536. 描述了函数TIM_SelectOnePulseMode

Table 536. 函数 TIM_SelectOnePulseMode  

<table><tr><td>函数名</td><td>TIM_SelectOnePulseMode</td></tr><tr><td>函数原形</td><td>void TIM_SelectOnePulseMode(TIMTypeDef* TIMx, u16 TIM_OPMode)</td></tr><tr><td>功能描述</td><td>设置TIMx单脉冲模式</td></tr><tr><td>输入参数1</td><td>TIMx: x可以是2,3或者4,来选择TIM外设</td></tr><tr><td>输入参数2</td><td>TIM_OPMode: OPM模式
参阅Section: TIM_OPMode 查阅更多该参数允许取值范围</td></tr><tr><td>输出参数</td><td>无</td></tr><tr><td>返回值</td><td>无</td></tr><tr><td>先决条件</td><td>无</td></tr><tr><td>被调用函数</td><td>无</td></tr></table>

# TIM OPMode

TIM_OPMode 选择 TIM 更新源。见 Table 537. 参阅该参数的取值。

Table 537. TIM_OPMode 值  

<table><tr><td>TIM_OPMode</td><td>描述</td></tr><tr><td>TIM_OPMode_Repetitive</td><td>生成重复的脉冲：在更新事件时计数器不停止</td></tr><tr><td>TIM_OPMode_Single</td><td>生成单一的脉冲：计数器在下一个更新事件停止</td></tr></table>

例：

/* Selects the Single One Pulse Mode for TIM2 */

TIM_SelectOnePulseMode(TIM2，TIM_OPMode_Single);

# 19.2.49 函数TIM_SelectOutputTrigger

Table 538. 描述了函数TIM_SelectOutputTrigger

Table 538. 函数 TIM_SelectOutputTrigger  

<table><tr><td>函数名</td><td>TIM_SelectOutputTrigger</td></tr><tr><td>函数原形</td><td>void TIM_SelectOutputTrigger(TIMTypeDef* TIMx, u16 TIM_TRGOSource)</td></tr><tr><td>功能描述</td><td>选择TIMx触发输出模式</td></tr><tr><td>输入参数1</td><td>TIMx: x可以是2, 3或者4, 来选择TIM外设</td></tr><tr><td>输入参数2</td><td>TIM_TRGOSource: 触发输出模式
参阅Section: TIM_TRGOSource 查阅更多该参数允许取值范围</td></tr><tr><td>输出参数</td><td>无</td></tr><tr><td>返回值</td><td>无</td></tr><tr><td>先决条件</td><td>无</td></tr><tr><td>被调用函数</td><td>无</td></tr></table>

# TIM_TRGOSource

TIM_TRGSource 选择 TIM 触发输出源。见 Table 539. 参阅该参数的取值。

Table 539. TIM_TRGOSource 值  

<table><tr><td>TIM_TRGOSource</td><td>描述</td></tr><tr><td>TIM_TRGOSource Reset</td><td>使用寄存器 TIM_EGR 的 UG 位作为触发输出（TRGO）</td></tr><tr><td>TIM_TRGOSource_Enable</td><td>使用计数器使能 CEN 作为触发输出（TRGO）</td></tr><tr><td>TIM_TRGOSource_Update</td><td>使用更新事件作为触发输出（TRGO）</td></tr><tr><td>TIM_TRGOSource_OC1</td><td>一旦捕获或者比较匹配发生，当标志位 CC1F 被设置时触发输出发送一个肯定脉冲（TRGO）</td></tr><tr><td>TIM_TRGOSource_OC1Ref</td><td>使用 OC1REF 作为触发输出（TRGO）</td></tr><tr><td>TIM_TRGOSource_OC2Ref</td><td>使用 OC2REF 作为触发输出（TRGO）</td></tr><tr><td>TIM_TRGOSource_OC3Ref</td><td>使用 OC3REF 作为触发输出（TRGO）</td></tr><tr><td>TIM_TRGOSource_OC4Ref</td><td>使用 OC4REF 作为触发输出（TRGO）</td></tr></table>

例：

/\* Selects the update event as Trigger Output for TIM2 \*/TIM_SelectOutputTrigger(TIM2，TIM_TRGOSource_Update);

# 19.2.50 函数TIM_SelectSlaveMode

Table 540. 描述了函数TIM_SelectSlaveMode  
Table 540. 函数 TIM_SelectSlaveMode  

<table><tr><td>函数名</td><td>TIM_SelectSlaveMode</td></tr><tr><td>函数原形</td><td>void TIM_SelectSlaveMode(TIMTypeDef* TIMx, u16 TIM_S SlaveMode)</td></tr><tr><td>功能描述</td><td>选择TIMx从模式</td></tr><tr><td>输入参数1</td><td>TIMx: x可以是2,3或者4,来选择TIM外设</td></tr><tr><td>输入参数2</td><td>TIM_S SlaveMode: TIM从模式
参阅Section: TIM_S SlaveMode 查阅更多该参数允许取值范围</td></tr><tr><td>输出参数</td><td>无</td></tr><tr><td>返回值</td><td>无</td></tr><tr><td>先决条件</td><td>无</td></tr><tr><td>被调用函数</td><td>无</td></tr></table>

# TIM_SlaveMode

TIM_SlaveMode 选择 TIM 从模式。见 Table 541. 参阅该参数的取值。

Table 541. TIM_SlaveMode 值  

<table><tr><td>TIM_SlaveMode</td><td>描述</td></tr><tr><td>TIM_SlaveModeRESET</td><td>选中触发信号(TRGI)的上升沿重初始化计数器并触发寄存器的更新</td></tr><tr><td>TIM_SlaveMode_Gated</td><td>当触发信号(TRGI)为高电平计数器时钟使能</td></tr><tr><td>TIM_SlaveMode_Trigger</td><td>计数器在触发(TRGI)的上升沿开始</td></tr><tr><td>TIM_SlaveMode_External1</td><td>选中触发(TRGI)的上升沿作为计数器时钟</td></tr></table>

例：  
/\* Selects the Gated Mode as Slave Mode for TIM2 \*/  
TIM_SelectSlaveMode(TIM2，TIM_SlaveMode_Gated);

# 19.2.51 函数TIM_SelectMasterSlaveMode

Table 542. 描述了函数TIM_SelectMasterSlaveMode

Table 542. 函数 TIM_SelectMasterSlaveMode  

<table><tr><td>函数名</td><td>TIM_SelectMasterSlaveMode</td></tr><tr><td>函数原形</td><td>void TIM_SelectMasterSlaveMode(TIMTypeDef* TIMx, u16 TIM_MasterSlaveMode)</td></tr><tr><td>功能描述</td><td>设置或者重置TIMx主/从模式</td></tr><tr><td>输入参数1</td><td>TIMx: x可以是2,3或者4,来选择TIM外设</td></tr><tr><td>输入参数2</td><td>TIM_MasterSlaveMode: 定时器主/从模式
参阅Section: TIM_MasterSlaveMode 查阅更多该参数允许取值范围</td></tr><tr><td>输出参数</td><td>无</td></tr><tr><td>返回值</td><td>无</td></tr><tr><td>先决条件</td><td>无</td></tr><tr><td>被调用函数</td><td>无</td></tr></table>

# TIM_MasterSlaveMode

TIM_MasterSlaveMode 选择 TIM 主/从模式。见 Table 543. 参阅该参数的取值。

Table 543. TIM MasterSlaveMode 值  

<table><tr><td>TIM_MasterSlaveMode</td><td>描述</td></tr><tr><td>TIM_MasterSlaveMode_Enable</td><td>TIM主/从模式使能</td></tr><tr><td>TIM_MasterSlaveMode_Disable</td><td>TIM主/从模式失能</td></tr></table>

例：

```javascript
/\*Enables the Master Slave Mode for TIM2 \*/TIM_SelectMasterSlaveMode(TIM2，TIM_MasterSlaveMode_Enable);
```

# 19.2.52 函数TIM_SetCounter

Table 544. 描述了函数TIM_SetCounter

Table 544. 函数 TIM_SetCounter  

<table><tr><td>函数名</td><td>TIM_SetCounter</td></tr><tr><td>函数原形</td><td>void TIM_SetCounter(TIM_TYPEDef* TIMx, u16 Counter)</td></tr><tr><td>功能描述</td><td>设置TIMx计数器寄存器值</td></tr><tr><td>输入参数1</td><td>TIMx: x可以是2,3或者4,来选择TIM外设</td></tr><tr><td>输入参数2</td><td>Counter: 计数器寄存器新值</td></tr><tr><td>输出参数</td><td>无</td></tr><tr><td>返回值</td><td>无</td></tr><tr><td>先决条件</td><td>无</td></tr><tr><td>被调用函数</td><td>无</td></tr></table>

例：

```javascript
/\* Sets the TIM2 new Counter value \*/ u16TIMCounter  $= 0\mathrm{xFFFF}$  TIM_SetCounter(TIM2，TIMCounter);
```

# 19.2.53 函数TIM_SetAutoreload

Table 545. 描述了函数TIM_SetAutoreload  
Table 545. 函数 TIM_SetAutoreload  

<table><tr><td>函数名</td><td>TIM_SetAutoreload</td></tr><tr><td>函数原形</td><td>void TIM_SetCounter(TIM_TYPEDef* TIMx, u16 Counter)</td></tr><tr><td>功能描述</td><td>设置TIMx自动重装载寄存器值</td></tr><tr><td>输入参数1</td><td>TIMx: x可以是2,3或者4,来选择TIM外设</td></tr><tr><td>输入参数2</td><td>Autoreload: 自动重装载寄存器新值</td></tr><tr><td>输出参数</td><td>无</td></tr><tr><td>返回值</td><td>无</td></tr><tr><td>先决条件</td><td>无</td></tr><tr><td>被调用函数</td><td>无</td></tr></table>

例：  
/\* Sets the TIM2 new Autoreload value \*/ u16TIMAutoreload  $=$  0xFFFF; TIM_SetAutoreload(TIM2，TIMAutoreload);

# 19.2.54 函数TIM_SetCompare1

Table 546. 描述了函数TIM_SetCompare1  
Table 546. 函数 TIM_SetCompare1  

<table><tr><td>函数名</td><td>TIM_SetCompare1</td></tr><tr><td>函数原形</td><td>void TIM_SetCompare1(TIM_TYPEDef* TIMx, u16 Compare1)</td></tr><tr><td>功能描述</td><td>设置TIMx捕获比较1寄存器值</td></tr><tr><td>输入参数1</td><td>TIMx: x可以是2,3或者4,来选择TIM外设</td></tr><tr><td>输入参数2</td><td>Compare1: 捕获比较1寄存器新值</td></tr><tr><td>输出参数</td><td>无</td></tr><tr><td>返回值</td><td>无</td></tr><tr><td>先决条件</td><td>无</td></tr><tr><td>被调用函数</td><td>无</td></tr></table>

例：  
/\* Sets the TIM2 new Output Compare 1 value \*/ u16 TIMCompare1  $= 0\mathrm{x}7\mathrm{FFF}$  TIM_SetCompare1(TIM2，TIMCompare1);

# 19.2.55 函数TIM_SetCompare2

Table 547. 描述了函数TIM_SetCompare2  
Table 547. 函数 TIM_SetCompare2  

<table><tr><td>函数名</td><td>TIM_SetCompare2</td></tr><tr><td>函数原形</td><td>void TIM_SetCompare2(TIM_TYPEDef* TIMx, u16 Compare2)</td></tr><tr><td>功能描述</td><td>设置TIMx捕获比较2寄存器值</td></tr><tr><td>输入参数1</td><td>TIMx: x可以是2,3或者4,来选择TIM外设</td></tr><tr><td>输入参数2</td><td>Compare2: 捕获比较2寄存器新值</td></tr><tr><td>输出参数</td><td>无</td></tr><tr><td>返回值</td><td>无</td></tr><tr><td>先决条件</td><td>无</td></tr><tr><td>被调用函数</td><td>无</td></tr></table>

例：  
/\* Sets the TIM2 new Output Compare 2 value \*/ u16 TIMCompare2  $= 0\mathrm{x}7\mathrm{FFF}$  TIM_SetCompare2(TIM2，TIMCompare2);

# 19.2.56 函数TIM_SetCompare3

Table 548. 描述了函数TIM_SetCompare3  
Table 548. 函数 TIM_SetCompare3  

<table><tr><td>函数名</td><td>TIM_SetCompare3</td></tr><tr><td>函数原形</td><td>void TIM_SetCompare3(TIM_TYPEDef* TIMx, u16 Compare3)</td></tr><tr><td>功能描述</td><td>设置TIMx捕获比较3寄存器值</td></tr><tr><td>输入参数1</td><td>TIMx: x可以是2, 3或者4, 来选择TIM外设</td></tr><tr><td>输入参数2</td><td>Compare1: 捕获比较3寄存器新值</td></tr><tr><td>输出参数</td><td>无</td></tr><tr><td>返回值</td><td>无</td></tr><tr><td>先决条件</td><td>无</td></tr><tr><td>被调用函数</td><td>无</td></tr></table>

例：  
/\* Sets the TIM2 new Output Compare 3 value \*/ u16 TIMCompare3  $= 0\mathrm{x}7\mathrm{FFF}$  TIM_SetCompare3(TIM2，TIMCompare3);

# 19.2.57 函数TIM_SetCompare4

Table 549. 描述了函数TIM_SetCompare4  
Table 549. 函数 TIM_SetCompare4  

<table><tr><td>函数名</td><td>TIM_SetCompare4</td></tr><tr><td>函数原形</td><td>void TIM_SetCompare4(TIM_TYPEDef* TIMx, u16 Compare4)</td></tr><tr><td>功能描述</td><td>设置TIMx捕获比较4寄存器值</td></tr><tr><td>输入参数1</td><td>TIMx: x可以是2,3或者4,来选择TIM外设</td></tr><tr><td>输入参数2</td><td>Compare4: 捕获比较4寄存器新值</td></tr><tr><td>输出参数</td><td>无</td></tr><tr><td>返回值</td><td>无</td></tr><tr><td>先决条件</td><td>无</td></tr><tr><td>被调用函数</td><td>无</td></tr></table>

例：  
/\* Sets the TIM2 new Output Compare 4 value \*/ u16 TIMCompare4  $= 0\mathrm{x}7\mathrm{FFF}$  TIM_SetCompare4(TIM2，TIMCompare4);

# 19.2.58 函数TIM_SetIC1Prescaler

Table 550. 描述了函数TIM_SetIC1Prescaler  
Table 550. 函数 TIM_SetIC1Prescaler  

<table><tr><td>函数名</td><td>TIM_SetIC1Prescaler</td></tr><tr><td>函数原形</td><td>void TIM_SetIC1Prescaler(TIM_TYPEDef* TIMx, u16 TIM_IC1Prescaler)</td></tr><tr><td>功能描述</td><td>设置TIMx输入捕获1预分频</td></tr><tr><td>输入参数1</td><td>TIMx: x可以是2,3或者4,来选择TIM外设</td></tr><tr><td>输入参数2</td><td>TIM_IC1Prescaler: 输入捕获1预分频
参阅Section: TIM_IC1Prescaler 查阅更多该参数允许取值范围</td></tr><tr><td>输出参数</td><td>无</td></tr><tr><td>返回值</td><td>无</td></tr><tr><td>先决条件</td><td>无</td></tr><tr><td>被调用函数</td><td>无</td></tr></table>

例：  
/\* Sets the TIM2 Input Capture 1 Prescaler \*/TIM_SetIC1Prescaler(TIM2，TIM_ICPSC_Div2);

# 19.2.59 函数TIM_SetIC2Prescaler

Table 551. 描述了函数TIM_SetIC2Prescaler  
Table 551. 函数 TIM_SetIC2Prescaler  

<table><tr><td>函数名</td><td>TIM_SetIC2Prescaler</td></tr><tr><td>函数原形</td><td>void TIM_SetIC2Prescaler(TIM_TYPEDef* TIMx, u16 TIM_IC2Prescaler)</td></tr><tr><td>功能描述</td><td>设置TIMx输入捕获2预分频</td></tr><tr><td>输入参数1</td><td>TIMx: x可以是2,3或者4,来选择TIM外设</td></tr><tr><td>输入参数2</td><td>TIM_IC2Prescaler: 输入捕获2预分频
参阅Section: TIM_IC1Prescaler 查阅更多该参数允许取值范围</td></tr><tr><td>输出参数</td><td>无</td></tr><tr><td>返回值</td><td>无</td></tr><tr><td>先决条件</td><td>无</td></tr><tr><td>被调用函数</td><td>无</td></tr></table>

例：/\*Sets the TIM2 Input Capture 2 Prescaler \*/TIM_SetIC2Prescaler(TIM2，TIM_ICPSC_Div2);

# 19.2.60 函数TIM_SetIC3Prescaler

Table 552. 描述了函数TIM_SetIC3Prescaler  
Table 552. 函数 TIM_SetIC3Prescaler  

<table><tr><td>函数名</td><td>TIM_SetIC3Prescaler</td></tr><tr><td>函数原形</td><td>void TIM_SetIC3Prescaler(TIM_TYPEDef* TIMx, u16 TIM_IC3Prescaler)</td></tr><tr><td>功能描述</td><td>设置TIMx输入捕获3预分频</td></tr><tr><td>输入参数1</td><td>TIMx: x可以是2, 3或者4, 来选择TIM外设</td></tr><tr><td>输入参数2</td><td>TIM_IC1Prescaler: 输入捕获3预分频
参阅Section: TIM_IC1Prescaler 查阅更多该参数允许取值范围</td></tr><tr><td>输出参数</td><td>无</td></tr><tr><td>返回值</td><td>无</td></tr><tr><td>先决条件</td><td>无</td></tr><tr><td>被调用函数</td><td>无</td></tr></table>

例：/\*Sets the TIM2 Input Capture 3 Prescaler \*/TIM_SetIC3Prescaler(TIM2，TIM_ICPSC_Div2);

# 19.2.61 函数TIM_SetIC4Prescaler

Table 553. 描述了函数TIM_SetIC4Prescaler  
Table 553. 函数 TIM_SetIC4Prescaler  

<table><tr><td>函数名</td><td>TIM_SetIC4Prescaler</td></tr><tr><td>函数原形</td><td>void TIM_SetIC1Prescaler(TIM_TYPEDef* TIMx, u16 TIM_IC4Prescaler)</td></tr><tr><td>功能描述</td><td>设置TIMx输入捕获4预分频</td></tr><tr><td>输入参数1</td><td>TIMx: x可以是2,3或者4,来选择TIM外设</td></tr><tr><td>输入参数2</td><td>TIM_IC1Prescaler: 输入捕获4预分频
参阅Section: TIM_IC1Prescaler 查阅更多该参数允许取值范围</td></tr><tr><td>输出参数</td><td>无</td></tr><tr><td>返回值</td><td>无</td></tr><tr><td>先决条件</td><td>无</td></tr><tr><td>被调用函数</td><td>无</td></tr></table>

例：  
/* Sets the TIM2 Input Capture 4 Prescaler */  
TIM_SetIC4Prescaler(TIM2, TIM_ICPSC_Div2);

# 19.2.62 函数TIM_SetClockDivision

Table 554. 描述了函数TIM_SetClockDivision  
Table 554. 函数 TIM_SetClockDivision  

<table><tr><td>函数名</td><td>TIM_SetClockDivision</td></tr><tr><td>函数原形</td><td>void TIM_SetClockDivision(TIM_TYPEDef* TIMx, u16 TIM_CKD)</td></tr><tr><td>功能描述</td><td>设置TIMx的时钟分割值</td></tr><tr><td>输入参数1</td><td>TIMx: x可以是2,3或者4,来选择TIM外设</td></tr><tr><td>输入参数2</td><td>TIM_CKD: 时钟分割值
参阅Section: TIM_ClockDivision 查阅更多该参数允许取值范围</td></tr><tr><td>输出参数</td><td>无</td></tr><tr><td>返回值</td><td>无</td></tr><tr><td>先决条件</td><td>无</td></tr><tr><td>被调用函数</td><td>无</td></tr></table>

例：  
/* Sets the TIM2 CKD value */  
TIM_SetClockDivision(TIM2, TIM_CKD_DIV4);

# 19.2.63 函数TIM_GetCapture1

Table 555. 描述了函数TIM_GetCapture1  
Table 555. 函数 TIM_GetCapture1  

<table><tr><td>函数名</td><td>TIM_GetCapture1</td></tr><tr><td>函数原形</td><td>u16 TIM_GetCapture1(TIMTypeDef* TIMx)</td></tr><tr><td>功能描述</td><td>获得TIMx输入捕获1的值</td></tr><tr><td>输入参数</td><td>TIMx: x可以是2,3或者4,来选择TIM外设</td></tr><tr><td>输出参数</td><td>无</td></tr><tr><td>返回值</td><td>输入捕获1的值</td></tr><tr><td>先决条件</td><td>无</td></tr><tr><td>被调用函数</td><td>无</td></tr></table>

例：
/* Gets the Input Capture 1 value of the TIM2 */
u16 ICAP1value = TIM_GetCapture1(TIM2);

# 19.2.64 函数TIM_GetCapture2

Table 556. 描述了函数TIM_GetCapture2  
Table 556. 函数 TIM_GetCapture2  

<table><tr><td>函数名</td><td>TIM_GetCapture2</td></tr><tr><td>函数原形</td><td>u16 TIM_GetCapture2(TIMTypeDef* TIMx)</td></tr><tr><td>功能描述</td><td>获得TIMx输入捕获2的值</td></tr><tr><td>输入参数</td><td>TIMx: x可以是2,3或者4,来选择TIM外设</td></tr><tr><td>输出参数</td><td>无</td></tr><tr><td>返回值</td><td>输入捕获2的值</td></tr><tr><td>先决条件</td><td>无</td></tr><tr><td>被调用函数</td><td>无</td></tr></table>

例：
/* Gets the Input Capture 2 value of the TIM2 */
u16 ICAP2value = TIM_GetCapture2(TIM2);

# 19.2.65 函数TIM_GetCapture3

Table 557. 描述了函数TIM_GetCaptur3  
Table 557. 函数 TIM_GetCapture3  

<table><tr><td>函数名</td><td>TIM_GetCapture3</td></tr><tr><td>函数原形</td><td>u16 TIM_GetCapture3(TIMTypeDef* TIMx)</td></tr><tr><td>功能描述</td><td>获得TIMx输入捕获3的值</td></tr><tr><td>输入参数</td><td>TIMx: x可以是2, 3或者4, 来选择TIM外设</td></tr><tr><td>输出参数</td><td>无</td></tr><tr><td>返回值</td><td>输入捕获3的值</td></tr><tr><td>先决条件</td><td>无</td></tr><tr><td>被调用函数</td><td>无</td></tr></table>

例：
/* Gets the Input Capture 3 value of the TIM2 */
u16 ICAP3value = TIM_GetCapture3(TIM2);

# 19.2.66 函数TIM_GetCapture4

Table 558. 描述了函数TIM_GetCapture4  
Table 558. 函数 TIM_GetCapture4  

<table><tr><td>函数名</td><td>TIM_GetCapture4</td></tr><tr><td>函数原形</td><td>u16 TIM_GetCapture4(TIMTypeDef* TIMx)</td></tr><tr><td>功能描述</td><td>获得TIMx输入捕获4的值</td></tr><tr><td>输入参数</td><td>TIMx: x可以是2,3或者4,来选择TIM外设</td></tr><tr><td>输出参数</td><td>无</td></tr><tr><td>返回值</td><td>输入捕获4的值</td></tr><tr><td>先决条件</td><td>无</td></tr><tr><td>被调用函数</td><td>无</td></tr></table>

例：
/* Gets the Input Capture 4 value of the TIM2 */
u16 ICAP4value = TIM_GetCapture4(TIM2);

# 19.2.67 函数TIM_GetCounter

Table 559. 描述了函数TIM_GetCounter  
Table 559. 函数 TIM_GetCounter  

<table><tr><td>函数名</td><td>TIM_GetCounter</td></tr><tr><td>函数原形</td><td>u16 TIM_GetCounter(TIMTypeDef* TIMx)</td></tr><tr><td>功能描述</td><td>获得TIMx计数器的值</td></tr><tr><td>输入参数</td><td>TIMx: x可以是2,3或者4,来选择TIM外设</td></tr><tr><td>输出参数</td><td>无</td></tr><tr><td>返回值</td><td>计数器的值</td></tr><tr><td>先决条件</td><td>无</td></tr><tr><td>被调用函数</td><td>无</td></tr></table>

例：  
/\*GetsTIM2countervalue\*/u16TIMCounter  $\equiv$  TIM_GetCounter(TIM2);

# 19.2.68 函数TIM_GetPrescaler

Table 560. 描述了函数TIM_GetPrescaler

Table 560. 函数 TIM_GetPrescaler  

<table><tr><td>函数名</td><td>TIM_GetPrescaler</td></tr><tr><td>函数原形</td><td>u16 TIM_GetPrescaler (TIM_TYPEDef* TIMx)</td></tr><tr><td>功能描述</td><td>获得TIMx预分频值</td></tr><tr><td>输入参数</td><td>TIMx: x可以是2,3或者4,来选择TIM外设</td></tr><tr><td>输出参数</td><td>无</td></tr><tr><td>返回值</td><td>预分频的值</td></tr><tr><td>先决条件</td><td>无</td></tr><tr><td>被调用函数</td><td>无</td></tr></table>

例：  
/\*GetsTIM2prescalervalue\*/ u16TIMPrescaler  $\equiv$  TIM_GetPrescaler(TIM2);

# 19.2.69 函数TIM_GetFlagStatus

Table 561. 描述了函数TIM_GetFlagStatus

Table 561. 函数 TIM_GetFlagStatus  

<table><tr><td>函数名</td><td>TIM_GetFlagStatus</td></tr><tr><td>函数原形</td><td>FlagStatus TIM_GetFlagStatus(TIMTypeDef* TIMx, u16 TIM_FLAG)</td></tr><tr><td>功能描述</td><td>检查指定的TIM标志位设置与否</td></tr><tr><td>输入参数1</td><td>TIMx: x可以是2,3或者4,来选择TIM外设</td></tr><tr><td>输入参数2</td><td>TIM_FLAG: 待检查的TIM标志位
参阅Section: TIM_FLAG 查阅更多该参数允许取值范围</td></tr><tr><td>输出参数</td><td>无</td></tr><tr><td>返回值</td><td>TIM_FLAG 的新状态 (SET 或者 RESET)</td></tr><tr><td>先决条件</td><td>无</td></tr><tr><td>被调用函数</td><td>无</td></tr></table>

# TIM_FLAG

Table 562. 给出了所有可以被函数TIM_GetFlagStatus检查的标志位列表

Table 562. TIM_FLAG 值  

<table><tr><td>TIM_FLAG</td><td>描述</td></tr><tr><td>TIM_FLAG_Update</td><td>TIM 更新标志位</td></tr><tr><td>TIM_FLAG_CC1</td><td>TIM 捕获/比较 1 标志位</td></tr><tr><td>TIM_FLAG_CC2</td><td>TIM 捕获/比较 2 标志位</td></tr><tr><td>TIM_FLAG_CC3</td><td>TIM 捕获/比较 3 标志位</td></tr><tr><td>TIM_FLAG_CC4</td><td>TIM 捕获/比较 4 标志位</td></tr><tr><td>TIM_FLAG_Trigger</td><td>TIM 触发标志位</td></tr><tr><td>TIM_FLAG_CC1OF</td><td>TIM 捕获/比较 1 溢出标志位</td></tr><tr><td>TIM_FLAG_CC2OF</td><td>TIM 捕获/比较 2 溢出标志位</td></tr><tr><td>TIM_FLAG_CC3OF</td><td>TIM 捕获/比较 3 溢出标志位</td></tr><tr><td>TIM_FLAG_CC4OF</td><td>TIM 捕获/比较 4 溢出标志位</td></tr></table>

例：  
/\* Check if the TIM2 Capture Compare 1 flag is set or reset \*/ if(TIM_GetFlagStatus(TIM2，TIM_FLAG_CC1）  $= =$  SET)

ST

译文英文原版为UM0427 Oct. 2007 Rev 2, 译文仅供参考，与英文版冲突的，以英文版为准

# 19.2.70 函数TIM_ClearFlag

Table 563. 描述了函数TIM_ClearFlag  
Table 563. 函数 TIM_ClearFlag  

<table><tr><td>函数名</td><td>TIM_ClearFlag</td></tr><tr><td>函数原形</td><td>void TIM_ClearFlag(TIMTypeDef* TIMx, u32 TIM_FLAG)</td></tr><tr><td>功能描述</td><td>清除TIMx的待处理标志位</td></tr><tr><td>输入参数1</td><td>TIMx: x可以是2, 3或者4, 来选择TIM外设</td></tr><tr><td>输入参数2</td><td>TIM_FLAG: 待清除的TIM标志位
参阅Section: TIM_FLAG 查阅更多该参数允许取值范围</td></tr><tr><td>输出参数</td><td>无</td></tr><tr><td>返回值</td><td>无</td></tr><tr><td>先决条件</td><td>无</td></tr><tr><td>被调用函数</td><td>无</td></tr></table>

例：  
/\* Clear the TIM2 Capture Compare 1 flag \*/TIM_ClearFlag(TIM2，TIM_FLAG_CC1);

# 19.2.71 函数TIM_GetITStatus

Table 564. 描述了函数TIM_GetITStatus  
Table 564. 函数 TIM_GetITStatus  

<table><tr><td>函数名</td><td>TIM_GetITStatus</td></tr><tr><td>函数原形</td><td>ITStatus TIM_GetITStatus(TIMTypeDef* TIMx, u16 TIM_IT)</td></tr><tr><td>功能描述</td><td>检查指定的TIM中断发生与否</td></tr><tr><td>输入参数1</td><td>TIMx: x可以是2,3或者4,来选择TIM外设</td></tr><tr><td>输入参数2</td><td>TIM_IT: 待检查的TIM中断源
参阅Section: TIM_IT 查阅更多该参数允许取值范围</td></tr><tr><td>输出参数</td><td>无</td></tr><tr><td>返回值</td><td>TIM_IT的新状态</td></tr><tr><td>先决条件</td><td>无</td></tr><tr><td>被调用函数</td><td>无</td></tr></table>

```txt
例：  
/\* Check if the TIM2 Capture Compare 1 interrupt has occured or not \*/  
if(TIM_GetITStatus(TIM2，TIM_IT_CC1）  $= =$  SET)
```

# 19.2.72 函数TIM_ClearITPendingBit

Table 565. 描述了函数TIM_ClearITPendingBit  
Table 565. 函数 TIM_ClearITPendingBit  

<table><tr><td>函数名</td><td>TIM_ClearITPendingBit</td></tr><tr><td>函数原形</td><td>void TIM_ClearITPendingBit(TIMTypeDef* TIMx, u16 TIM_IT)</td></tr><tr><td>功能描述</td><td>清除TIMx的中断待处理位</td></tr><tr><td>输入参数1</td><td>TIMx: x可以是2,3或者4,来选择TIM外设</td></tr><tr><td>输入参数2</td><td>TIM_IT: 待检查的TIM中断待处理位
参阅Section: TIM_IT 查阅更多该参数允许取值范围</td></tr><tr><td>输出参数</td><td>无</td></tr><tr><td>返回值</td><td>无</td></tr><tr><td>先决条件</td><td>无</td></tr><tr><td>被调用函数</td><td>无</td></tr></table>

例：
/* Clear the TIM2 Capture Compare 1 interrupt pending bit */
TIM_ClearITPendingBit(TIM2, TIM_IT_CC1);

# 20 高级控制定时器（TIM1）

高级控制定时器(TIM1)由一个16位的自动装载计数器组成，它由一个可编程预分频器驱动。

它适合多种用途，包含测量输入信号的脉冲宽度(输入捕获)，或者产生输出波形(输出比较，PWM，嵌入死区时间的互补PWM等)。

使用定时器预分频器和RCC时钟控制预分频器，可以实现脉冲宽度和波形周期从几个微秒到几个毫秒的调节。

Section 20.1 TIM1 寄存器结构描述了固件函数库所使用的数据结构，Section 20.2 固件库函数介绍了函数库里的所有函数。

# 20.1 TIM1 寄存器结构

TIM1 寄存器结构，TIM1_TYPEDeff，在文件“stm32f10x_map.h”中定义如下：

```c
typedef struct  
{  
vu16 CR1;  
u16 RESERVED0;  
vu16 CR2;  
u16 RESERVED1;  
vu16 SMCR;  
u16 RESERVED2;  
vu16 DIER;  
u16 RESERVED3;  
vu16 SR;  
u16 RESERVED4;  
vu16 EGR;  
u16 RESERVED5;  
vu16 CCMR1;  
u16 RESERVED6;  
vu16 CCMR2;  
u16 RESERVED7;  
vu16 CCER;  
u16 RESERVED8;  
vu16 CNT;  
u16 RESERVED9;  
vu16 PSC;  
u16 RESERVED10;  
vu16 ARR;  
u16 RESERVED11;  
vu16 RCR;  
u16 RESERVED12;  
vu16 CCR1;  
u16 RESERVED13;  
vu16 CCR2;  
u16 RESERVED14;  
vu16 CCR3;  
u16 RESERVED15;  
vu16 CCR4;  
u16 RESERVED16;  
vu16 BDTR;  
u16 RESERVED17;  
vu16 DCR;  
u16 RESERVED18;  
vu16 DMAR;  
u16 RESERVED19;  
} TIM1TypeDef;
```

# ST

译文英文原版为UM0427 Oct. 2007 Rev 2, 译文仅供参考，与英文版冲突的，以英文版为准

Table 566.例举了TIM1所有寄存器  
Table 566. TIM1 寄存器  

<table><tr><td>寄存器</td><td>描述</td></tr><tr><td>CR1</td><td>控制寄存器1</td></tr><tr><td>CR2</td><td>控制寄存器2</td></tr><tr><td>SMCR</td><td>从模式控制寄存器</td></tr><tr><td>DIER</td><td>DMA/中断使能寄存器</td></tr><tr><td>SR</td><td>状态寄存器</td></tr><tr><td>EGR</td><td>事件产生寄存器</td></tr><tr><td>CCMR1</td><td>捕获/比较模式寄存器1</td></tr><tr><td>CCMR2</td><td>捕获/比较模式寄存器2</td></tr><tr><td>CCER</td><td>捕获/比较使能寄存器</td></tr><tr><td>CNT</td><td>计数器寄存器</td></tr><tr><td>PSC</td><td>预分频寄存器</td></tr><tr><td>APR</td><td>自动重装载寄存器</td></tr><tr><td>RCR</td><td>周期计数寄存器</td></tr><tr><td>CCR1</td><td>捕获/比较寄存器1</td></tr><tr><td>CCR2</td><td>捕获/比较寄存器2</td></tr><tr><td>CCR3</td><td>捕获/比较寄存器3</td></tr><tr><td>CCR4</td><td>捕获/比较寄存器4</td></tr><tr><td>BDTR</td><td>刹车和死区寄存器</td></tr><tr><td>DCR</td><td>DMA 控制寄存器</td></tr><tr><td>DMAR</td><td>连续模式的 DMA 地址寄存器</td></tr></table>

TIM1外设声明于文件“stm32f10x_map.h”：

```c
define PERIPH_BASE ((u32)0x40000000)   
#define APB1PERIPH_BASE PERIPH_BASE   
#define APB2PERIPH_BASE (PERIPH_BASE + 0x10000)   
#define AHBPERIPH_BASE (PERIPH_BASE + 0x20000)   
...   
#define TIM1_BASE (APB2PERIPH_BASE + 0x2C00)   
...   
#	define DEBUG   
...   
#	define TIM1   
#define TIM1 ((TIM1TypeDef *) TIM1_BASE)   
endif /\*TIM1\*/   
else/\* DEBUG\*/   
#	define TIM1   
EXT TIM1TypeDef \*TIM1;   
endif /\*TIM1\*/   
endif
```

使用Debug模式时，初始化指针TIM1于文件“stm32f10x_lib.c”：

```c
...
#ifdef __TIM1
TIM1 = (TIM1TypeDef *) TIM1_BASE;
#endif /*__TIM1 */
```

为了访问TIM1寄存器，，_TIM1必须在文件“stm32f10x_conf.h”中定义如下：

```txt
define _TIM1
```

# 20.2 TIM1 库函数

Table 567. 例举了TIM1的库函数  
Table 567. TIM1 库函数  

<table><tr><td>函数名</td><td>描述</td></tr><tr><td>TIM1_DeInit</td><td>将外设TIM1寄存器重设为缺省值</td></tr><tr><td>TIM1_TIM1BaseInit</td><td>根据TIM1_TIM1BaseInitStruct中指定的参数初始化TIM1的时间基数单位</td></tr><tr><td>TIM1_OC1Init</td><td>根据TIM1_OCInitStruct中指定的参数初始化TIM1通道1</td></tr><tr><td>TIM1_OC2Init</td><td>根据TIM1_OCInitStruct中指定的参数初始化TIM1通道2</td></tr><tr><td>TIM1_OC3Init</td><td>根据TIM1_OCInitStruct中指定的参数初始化TIM1通道3</td></tr><tr><td>TIM1_OC4Init</td><td>根据TIM1_OCInitStruct中指定的参数初始化TIM1通道4</td></tr><tr><td>TIM1_BDTRConfig</td><td>设置刹车特性,死区时间,锁电平,OSSI,OSSR状态和AOE(自动输出使能)</td></tr><tr><td>TIM1_ICInit</td><td>根据TIM1_ICInitStruct中指定的参数初始化外设TIM1</td></tr><tr><td>TIM1_PWMConfig</td><td>根据TIM1_ICInitStruct中指定的参数设置外设TIM1工作在PWM输入模式</td></tr><tr><td>TIM1_TIM1BaseStructInit</td><td>把TIM1_TIM1BaseStruct中的每一个参数按缺省值填入</td></tr><tr><td>TIM1_OCStructInit</td><td>把TIM1_OCInitStruct中的每一个参数按缺省值填入</td></tr><tr><td>TIM1_ICStructInit</td><td>把TIM1_ICInitStruct中的每一个参数按缺省值填入</td></tr><tr><td>TIM1_BDTRStructInit</td><td>把TIM1_BDTRInitStruct中的每一个参数按缺省值填入</td></tr><tr><td>TIM1_Cmd</td><td>使能或者失能TIM1外设</td></tr><tr><td>TIM1_CtrlPWMOutputs</td><td>使能或者失能TIM1外设的主输出</td></tr><tr><td>TIM1_ITConfig</td><td>使能或者失能指定的TIM1中断</td></tr><tr><td>TIM1_DMAConfig</td><td>设置TIM1的DMA接口</td></tr><tr><td>TIM1_DMAcd</td><td>使能或者失能指定的TIM1的DMA请求</td></tr><tr><td>TIM1_IntervalClockConfig</td><td>设置DMA内部时钟</td></tr><tr><td>TIM1_ETRCLKModelConfig</td><td>配置TIM1外部时钟模式1</td></tr><tr><td>TIM1_ETRCLKMode2Config</td><td>配置TIM1外部时钟模式2</td></tr><tr><td>TIM1_ETRConfig</td><td>配置TIM1外部触发</td></tr><tr><td>TIM1_ITRxExternalClockConfig</td><td>设置TIM1内部触发为外部时钟模式</td></tr><tr><td>TIM1_TIxExternalClockConfig</td><td>设置TIM1触发为外部时钟</td></tr><tr><td>TIM1_SelectionTrigger</td><td>选择TIM1输入触发源</td></tr><tr><td>TIM1_UpdateDisableConfig</td><td>使能或者失能TIM1更新事件</td></tr><tr><td>TIM1_UpdateRequestConfig</td><td>设置TIM1更新请求源</td></tr><tr><td>TIM1_SelectHallSensor</td><td>使能或者失能TIM1霍尔传感器接口</td></tr><tr><td>TIM1_SELECTOnePulseMode</td><td>设置TIM1单脉冲模式</td></tr><tr><td>TIM1_SELECTOutputTrigger</td><td>选择TIM1触发输出模式</td></tr><tr><td>TIM1_SELECTSlaveMode</td><td>选择TIM1从模式</td></tr><tr><td>TIM1_SELECTMasterSlaveMode</td><td>设置或者重置TIM1主/从模式</td></tr><tr><td>TIM1_EmitterInterfaceConfig</td><td>设置TIM1编码界面</td></tr><tr><td>TIM1_PrescalerConfig</td><td>设置TIM1预分频</td></tr><tr><td>TIM1 CounterModeConfig</td><td>设置TIM1计数器模式</td></tr><tr><td>TIM1_FocusedOC1Config</td><td>置TIM1输出1为活动或者非活动电平</td></tr><tr><td>TIM1_FocusedOC2Config</td><td>置TIM1输出2为活动或者非活动电平</td></tr><tr><td>TIM1_FocusedOC3Config</td><td>置TIM1输出3为活动或者非活动电平</td></tr><tr><td>TIM1_FocusedOC4Config</td><td>置TIM1输出4为活动或者非活动电平</td></tr></table>

TIM1  

<table><tr><td>TIM1_ARRPreloadConfig</td><td>使能或者失能 TIM1 在 ARR 上的预装载寄存器</td></tr><tr><td>TIM1_SelectionCOM</td><td>选择 TIM1 外设的通讯事件</td></tr><tr><td>TIM1_SELECTCCDMA</td><td>选择 TIM1 外设的捕获比较 DMA 源</td></tr><tr><td>TIM1_CCPreloadControl</td><td>设置或者重置 TIM1 捕获比较控制位</td></tr><tr><td>TIM1_OC1PreloadConfig</td><td>使能或者失能 TIM1 在 CCR1 上的预装载寄存器</td></tr><tr><td>TIM1_OC2PreloadConfig</td><td>使能或者失能 TIM1 在 CCR2 上的预装载寄存器</td></tr><tr><td>TIM1_OC3PreloadConfig</td><td>使能或者失能 TIM1 在 CCR3 上的预装载寄存器</td></tr><tr><td>TIM1_OC4PreloadConfig</td><td>使能或者失能 TIM1 在 CCR4 上的预装载寄存器</td></tr><tr><td>TIM1_OC1FastConfig</td><td>设置 TIM1 捕获比较 1 快速特征</td></tr><tr><td>TIM1_OC2FastConfig</td><td>设置 TIM1 捕获比较 2 快速特征</td></tr><tr><td>TIM1_OC3FastConfig</td><td>设置 TIM1 捕获比较 3 快速特征</td></tr><tr><td>TIM1_OC4FastConfig</td><td>设置 TIM1 捕获比较 4 快速特征</td></tr><tr><td>TIM1_ClearOC1Ref</td><td>在一个外部事件时清除或者保持 OCREF1 信号</td></tr><tr><td>TIM1_ClearOC2Ref</td><td>在一个外部事件时清除或者保持 OCREF2 信号</td></tr><tr><td>TIM1_ClearOC3Ref</td><td>在一个外部事件时清除或者保持 OCREF3 信号</td></tr><tr><td>TIM1_ClearOC4Ref</td><td>在一个外部事件时清除或者保持 OCREF4 信号</td></tr><tr><td>TIM1_GenerateEvent</td><td>设置 TIM1 事件由软件产生</td></tr><tr><td>TIM1_OC1PolarityConfig</td><td>设置 TIM1 通道 1N 极性</td></tr><tr><td>TIM1_OC1NPolarityConfig</td><td>设置 TIM1 通道 1N 极性</td></tr><tr><td>TIM1_OC2PolarityConfig</td><td>设置 TIM1 通道 2 极性</td></tr><tr><td>TIM1_OC2NPolarityConfig</td><td>设置 TIM1 通道 2N 极性</td></tr><tr><td>TIM1_OC3PolarityConfig</td><td>设置 TIM1 通道 3 极性</td></tr><tr><td>TIM1_OC3NPolarityConfig</td><td>设置 TIM1 通道 3N 极性</td></tr><tr><td>TIM1_OC4PolarityConfig</td><td>设置 TIM1 通道 4 极性</td></tr><tr><td>TIM1_SetCounter</td><td>设置 TIM1 计数器寄存器值</td></tr><tr><td>TIM1_CCxCmd</td><td>使能或者失能 TIM1 捕获比较通道 x</td></tr><tr><td>TIM1_CCxCNCmd</td><td>使能或者失能 TIM1 捕获比较通道 xN</td></tr><tr><td>TIM1_SelectionOCxM</td><td>选择 TIM1 输出比较模式。本函数在改变输出比较模式前失能选中的通道。用户必须使用函数 TIM1_CCxCmd 和 TIM1_CCxCNCmd 来使能这个通道。</td></tr><tr><td>TIM1_SetAutoreload</td><td>设置 TIM1 自动重装载寄存器值</td></tr><tr><td>TIM1_SetCompare1</td><td>设置 TIM1 捕获比较 1 寄存器值</td></tr><tr><td>TIM1_SetCompare2</td><td>设置 TIM1 捕获比较 2 寄存器值</td></tr><tr><td>TIM1_SetCompare3</td><td>设置 TIM1 捕获比较 3 寄存器值</td></tr><tr><td>TIM1_SetCompare4</td><td>设置 TIM1 捕获比较 4 寄存器值</td></tr><tr><td>TIM1_SetIC1Prescaler</td><td>设置 TIM1 输入捕获 1 预分频</td></tr><tr><td>TIM1_SetIC2Prescaler</td><td>设置 TIM1 输入捕获 2 预分频</td></tr><tr><td>TIM1_SetIC3Prescaler</td><td>设置 TIM1 输入捕获 3 预分频</td></tr><tr><td>TIM1_SetIC4Prescaler</td><td>设置 TIM1 输入捕获 4 预分频</td></tr><tr><td>TIM1_SetClockDivision</td><td>设置 TIM1 的时钟分割值</td></tr><tr><td>TIM1_GetCapture1</td><td>获得 TIM1 输入捕获 1 的值</td></tr><tr><td>TIM1_GetCapture2</td><td>获得 TIM1 输入捕获 2 的值</td></tr><tr><td>TIM1_GetCapture3</td><td>获得 TIM1 输入捕获 3 的值</td></tr><tr><td>TIM1_GetCapture4</td><td>获得 TIM1 输入捕获 4 的值</td></tr><tr><td>TIM1_GetCounter</td><td>获得 TIM1 计数器的值</td></tr><tr><td>TIM1_GetPrescaler</td><td>获得 TIM1 预分频值</td></tr><tr><td>TIM1_GetFlagStatus</td><td>检查指定的 TIM1 标志位设置与否</td></tr><tr><td>TIM1_ClearFlag</td><td>清除 TIM1 的待处理标志位</td></tr><tr><td>TIM1_GetITStatus</td><td>检查指定的 TIM1 中断发生与否</td></tr><tr><td>TIM1_ClearITPendingBit</td><td>清除 TIM1 的中断待处理位</td></tr></table>

# 20.2.1 函数TIM1_DeInit

Table 568. 描述了函数 TIM1_DeInit

Table 568. 函数 TIM1_DeInit  

<table><tr><td>函数名</td><td>TIM1_DeInit</td></tr><tr><td>函数原形</td><td>void TIM1_DeInit(void)</td></tr><tr><td>功能描述</td><td>将外设TIM1寄存器重设为缺省值</td></tr><tr><td>输入参数</td><td>无</td></tr><tr><td>输出参数</td><td>无</td></tr><tr><td>返回值</td><td>无</td></tr><tr><td>先决条件</td><td>无</td></tr><tr><td>被调用函数</td><td>RCC_AP2PeriphClockCmd().</td></tr></table>

例：/\* Resets the TIM1 \*/TIM1_DeInit();

# 20.2.2 函数TIM1(TIM1BaseInit

Table 569. 描述了函数 TIM1(TIM1BaseInit

Table 569. 函数 TIM1(TIM1BaseInit  

<table><tr><td>函数名</td><td>TIM1_TIM1BaseInit</td></tr><tr><td>函数原形</td><td>void TIM1_TIM1BaseInit(TIM1_TIM1BaseInitTypeDef*TIM1_BaseInitStruct)</td></tr><tr><td>功能描述</td><td>根据TIM1_TIM1BaseInitStruct中指定的参数初始化TIM1的时间基数单位</td></tr><tr><td>输入参数</td><td>TIM1TIM1Base_InitStruct:指向结构TIM1_TIM1BaseInitTypeDef的指针,包含了TIM1时间基数单位的配置信息参阅Section:TIM1_TIM1BaseInitTypeDef查阅更多该参数允许取值范围</td></tr><tr><td>输出参数</td><td>无</td></tr><tr><td>返回值</td><td>无</td></tr><tr><td>先决条件</td><td>无</td></tr><tr><td>被调用函数</td><td>无</td></tr></table>

# TIM1_TIM1BaseInitTypeDef structure

TIM1_TIM1BaseInitTypeDef 定义于文件“stm32f10x_TIM1.h”： typedef struct { u16 TIM1_Period; u16 TIM1_Prescaler; u8 TIM1_ClockDivision; u16 TIM1 CounterMode; u8 TIM1_RepetitionCounter; } TIM1_TIM1BaseInitTypeDef;

# TIM1 Period

TIM1_Period设置了在下一个更新事件装入活动的自动重装载寄存器周期的值。它的取值必须在0x0000和0xFFFF之间。

# TIM1_Prescaler

TIM1_Prescaler 设置了用来作为 TIM1 时钟频率除数的预分频值。它的取值必须在 0x0000 和 0xFFFF 之间。

# TIM1 ClockDivision

TIM1_ClockDivision 设置了时钟分割。该参数取值见下表。

Table 570. TIM1_ClockDivision 值  

<table><tr><td>TIM1_ClockDivision</td><td>描述</td></tr><tr><td>TIM1_CKD_DIV1</td><td>TDDS = Tck_TIM1</td></tr><tr><td>TIM1_CKD_DIV2</td><td>TDDS = 2Tck_TIM1</td></tr><tr><td>TIM1_CKD_DIV4</td><td>TDDS = 4Tck_TIM1</td></tr></table>

# TIM1_CounterMode

TIM1_Mode 选择了计数器模式。该参数取值见下表。

Table 571. TIM1_Mode 值  

<table><tr><td>TIM1_Mode</td><td>描述</td></tr><tr><td>TIM1_Mode_Up</td><td>TIM1 向上计数模式</td></tr><tr><td>TIM1_Mode_Down</td><td>TIM1 向下计数模式</td></tr><tr><td>TIM1_Mode_CenterAligned1</td><td>TIM1 中央对齐模式 1 计数模式</td></tr><tr><td>TIM1_Mode_CenterAligned2</td><td>TIM1 中央对齐模式 2 计数模式</td></tr><tr><td>TIM1_Mode_CenterAligned3</td><td>TIM1 中央对齐模式 3 计数模式</td></tr></table>

# TIM1_RepetitionCounter

TIM1_RepetitionCounter设置了周期计数器值。RCR向下计数器每次计数至0，会产生一个更新事件且计数器重新由RCR值（N）开始计数。

这意味着在PWM模式（N+1）对应着：

$\bullet$  边沿对齐模式下PWM周期数  
- 中央对齐模式下PWM半周期数

它的取值必须在0x00和0xFF之间。

# 20.2.3 函数TIM1_OC1Init

Table 572. 描述了函数 TIM1_OC1Init

Table 572. 函数 TIM1_OC1Init  

<table><tr><td>函数名</td><td>TIM1_OC1Init</td></tr><tr><td>函数原形</td><td>void TIM1_OC1Init(TIM1_OCInitTypeDef* TIM1_OCInitStruct)</td></tr><tr><td>功能描述</td><td>根据TIM1_OCInitStruct中指定的参数初始化TIM1通道1</td></tr><tr><td>输入参数</td><td>TIM1_OCInitStruct: 指向结构TIM1_OCInitTypeDef 的指针, 包含了TIM1时间基数单位的配置信息。参阅Section: TIM1_OCInitTypeDef 查阅更多该参数允许取值范围</td></tr><tr><td>输出参数</td><td>无</td></tr><tr><td>返回值</td><td>无</td></tr><tr><td>先决条件</td><td>无</td></tr><tr><td>被调用函数</td><td>无</td></tr></table>

# TIM1_OCInitTypeDef structure

TIM1_OCInitTypeDef 定义于文件“stm32f10x_TIM1.h”：

```c
typedef struct   
{   
u16 TIM1_OCMode;   
u16 TIM1_OutputState;   
u16 TIM1_OutputNState;   
u16 TIM1_Pulse;   
u16 TIM1_OCPolarity;   
u16 TIM1_OCNPolarity;   
u16 TIM1_OCIdleState;   
u16 TIM1_OCIdleState; }TIM1_OCInitTypeDef;
```

# TIM1_OCMode

TIM1_OCMode 选择定时器模式。该参数取值见下表。

Table 573. TIM1_OCMode 定义  

<table><tr><td>TIM1_OCMode</td><td>描述</td></tr><tr><td>TIM1_OCMode_TIM1ing</td><td>TIM1 输出比较时间模式</td></tr><tr><td>TIM1_OCMode_Active</td><td>TIM1 输出比较主动模式</td></tr><tr><td>TIM1_OCMode_Inactive</td><td>TIM1 输出比较非主动模式</td></tr><tr><td>TIM1_OCMode_Toggle</td><td>TIM1 输出比较触发模式</td></tr><tr><td>TIM1_OCMode_PWM1</td><td>TIM1 脉冲宽度调制模式 1</td></tr><tr><td>TIM1_OCMode_PWM2</td><td>TIM1 脉冲宽度调制模式 2</td></tr></table>

# TIM1_OutputState

TIM1_OutputState选择输出比较状态。该参数取值见下表。

Table 574. TIM1_OutputState 值  

<table><tr><td>TIM1_OutputState</td><td>描述</td></tr><tr><td>TIM1_OutputState_Disable</td><td>失能输出比较状态</td></tr><tr><td>TIM1_OutputState_Enable</td><td>使能输出比较状态</td></tr></table>

# TIM1_OutputNState

TIM1_OutputNState选择互补输出比较状态。该参数取值见下表。

Table 575. TIM1_OutputNState 值  

<table><tr><td>TIM1_OutputNState</td><td>描述</td></tr><tr><td>TIM1_OutputState_Disable</td><td>失能输出比较 N 状态</td></tr><tr><td>TIM1_OutputState_Enable</td><td>使能输出比较 N 状态</td></tr></table>

# TIM1_Pulse

TIM1_Pulse设置了待装入捕获比较寄存器的脉冲值。它的取值必须在0x0000和0xFFFF之间。

# TIM1_OCPolarity

TIM1_OCPolarity输出极性。该参数取值见下表。

Table 576. TIM1_OCPolarity 值  

<table><tr><td>TIM1_OCPolarity</td><td>描述</td></tr><tr><td>TIM1_OCPolarity_High</td><td>TIM1 输出比较极性高</td></tr><tr><td>TIM1_OCPolarity_Low</td><td>TIM1 输出比较极性低</td></tr></table>

# TIM1_OCNPolarity

TIM1_OCNPolarity互补输出极性。该参数取值见下表。

Table 577. TIM1_OCNPolarity 值  

<table><tr><td>TIM1_OCNPolarity</td><td>描述</td></tr><tr><td>TIM1_OCNPolarity_High</td><td>TIM1 输出比较 N 极性高</td></tr><tr><td>TIM1_OCNPolarity_Low</td><td>TIM1 输出比较 N 极性低</td></tr></table>

# TIM1_OCIdleState

TIM1_OCIdleState选择空闲状态下的非工作状态。该参数取值见下表。

Table 578. TIM1_OCIdleState 值  

<table><tr><td>TIM1_OCIdleState</td><td>描述</td></tr><tr><td>TIM1_OCIdleState_Set</td><td>当MOE=0设置TIM1输出比较空闲状态</td></tr><tr><td>TIM1_OCIdleState_Set</td><td>当MOE=0重置TIM1输出比较空闲状态</td></tr></table>

# TIM1_OCNIdleState

TIM1_OCIdleState选择空闲状态下的非工作状态。该参数取值见下表。

Table 579. TIM1_OCNIdleState 值  

<table><tr><td>TIM1_OCIdleState</td><td>描述</td></tr><tr><td>TIM1_OCIdleState_Set</td><td>当MOE=0设置TIM1输出比较N空闲状态</td></tr><tr><td>TIM1_OCIdleState_SetReset</td><td>当MOE=0重置TIM1输出比较N空闲状态</td></tr></table>

例：

```c
/\* Configures the TIM1 Channel1 in PWM Mode \*/   
TIM1_OCInitTypeDef TIM1_OCInitStructure;   
TIM1_OCInitStructure(TIM1_OCMode  $=$  TIM1_OCMode_PWM1;   
TIM1_OCInitStructure(TIM1_OutputState  $=$  TIM1_OutputState_Enable;   
TIM1_OCInitStructure(TIM1_OutputNState  $=$  TIM1_OutputNState_Enable;   
TIM1_OCInitStructure(TIM1_Pulse  $= 0x7FF$  .   
TIM1_OCInitStructure(TIM1_OCPolarity  $=$  TIM1_OCPolarity_Low;   
TIM1_OCInitStructure(TIM1_OCNPolarity  $=$  TIM1_OCNPolarity_Low;   
TIM1_OCInitStructure(TIM1_OCIdleState  $=$  TIM1_OCIdleState_Set;   
TIM1_OCInitStructure(TIM1_OCIdleState  $=$  TIM1_OCIdleStateRESET;   
TIM1_OCInit(&TIM1_OCInitStructure);
```

# 20.2.4 函数TIM1_OC2Init

Table 580. 描述了函数 TIM1_OC2Init  
Table 580. 函数 TIM1 OC2Init  

<table><tr><td>函数名</td><td>TIM1_OC2Init</td></tr><tr><td>函数原形</td><td>void TIM1_OC2Init(TIM1_OCInitTypeDef* TIM1_OCInitStruct)</td></tr><tr><td>功能描述</td><td>根据TIM1_OCInitStruct中指定的参数初始化TIM1通道2</td></tr><tr><td>输入参数</td><td>TIM1_OCInitStruct: 指向结构TIM1_OCInitTypeDef的指针, 包含了TIM1时间基数单位的配置信息参阅Section: TIM1_OCInitTypeDef 查阅更多该参数允许取值范围</td></tr><tr><td>输出参数</td><td>无</td></tr><tr><td>返回值</td><td>无</td></tr><tr><td>先决条件</td><td>无</td></tr><tr><td>被调用函数</td><td>无</td></tr></table>

# 例：

```txt
/\* Configures the TIM1 Channel2 in PWM Mode \*/   
TIM1_OCInitTypeDef TIM1_OCInitStructure;   
TIM1_OCInitStructure(TIM1_OCMode  $=$  TIM1_OCMode_PWM1;   
TIM1_OCInitStructure(TIM1_OutputState  $=$  TIM1_OutputState_Enable;   
TIM1_OCInitStructure(TIM1_OutputNState  $=$  TIM1_OutputNState_Enable;   
TIM1_OCInitStructure(TIM1_Pulse  $=$  0x7FF;   
TIM1_OCInitStructure(TIM1_OCPolarity  $=$  TIM1_OCPolarity_Low;   
TIM1_OCInitStructure(TIM1_OCNPolarity  $=$  TIM1_OCNPolarity_Low;   
TIM1_OCInitStructure(TIM1_OCIdleState  $=$  TIM1_OCIdleState_Set;   
TIM1_OCInitStructure(TIM1_OCIdleState  $=$  TIM1_OCIdleStateRESET;   
TIM1_OC2Init(&TIM1_OCInitStructure);
```

# 20.2.5 函数TIM1_OC3Init

Table 581. 描述了函数 TIM1_OC3Init  
Table 581. 函数 TIM1_OC3Init  

<table><tr><td>函数名</td><td>TIM1_OC3Init</td></tr><tr><td>函数原形</td><td>void TIM1_OC3Init(TIM1_OCInitTypeDef* TIM1_OCInitStruct)</td></tr><tr><td>功能描述</td><td>根据TIM1_OCInitStruct中指定的参数初始化TIM1通道3</td></tr><tr><td>输入参数</td><td>TIM1_OCInitStruct: 指向结构TIM1_OCInitTypeDef的指针, 包含了TIM1时间基数单位的配置信息参阅Section: TIM1_OCInitTypeDef 查阅更多该参数允许取值范围</td></tr><tr><td>输出参数</td><td>无</td></tr><tr><td>返回值</td><td>无</td></tr><tr><td>先决条件</td><td>无</td></tr><tr><td>被调用函数</td><td>无</td></tr></table>

# 例：

```txt
/\* Configures the TIM1 Channel3 in PWM Mode \*/   
TIM1_OCInitTypeDef TIM1_OCInitStructure;   
TIM1_OCInitStructure.TIM1_OCMode  $=$  TIM1_OCMode_PWM1;   
TIM1_OCInitStructure.TIM1_OutputState  $=$  TIM1_OutputState_Enable;   
TIM1_OCInitStructure.TIM1_OutputNState  $=$  TIM1_OutputNState_Enable;   
TIM1_OCInitStructure.TIM1_Pulse  $= 0x7FF$  .   
TIM1_OCInitStructure.TIM1_OCPolarity  $=$  TIM1_OCPolarity_Low;   
TIM1_OCInitStructure.TIM1_OCNPolarity  $=$  TIM1_OCNPolarity_Low;   
TIM1_OCInitStructure.TIM1_OCIdleState  $=$  TIM1_OCIdleState_Set;   
TIM1_OCInitStructure.TIM1_OCIdleState  $=$  TIM1_OCIdleStateRESET;   
TIM1_OC3Init(&TIM1_OCInitStructure);
```

# 20.2.6 函数TIM1_OC4Init

Table 582. 描述了函数 TIM1_OC4Init

Table 582. 函数 TIM1 OC4Init  

<table><tr><td>函数名</td><td>TIM1_OC4Init</td></tr><tr><td>函数原形</td><td>void TIM1_OC4Init(TIM1_OCInitTypeDef* TIM1_OCInitStruct)</td></tr><tr><td>功能描述</td><td>根据TIM1_OCInitStruct中指定的参数初始化TIM1通道4</td></tr><tr><td>输入参数</td><td>TIM1_OCInitStruct: 指向结构TIM1_OCInitTypeDef的指针, 包含了TIM1时间基数单位的配置信息参阅Section: TIM1_OCInitTypeDef 查阅更多该参数允许取值范围</td></tr><tr><td>输出参数</td><td>无</td></tr><tr><td>返回值</td><td>无</td></tr><tr><td>先决条件</td><td>无</td></tr><tr><td>被调用函数</td><td>无</td></tr></table>

例：

```c
/\* Configures the TIM1 Channel4 in PWM Mode \*/   
TIM1_OCInitTypeDef TIM1_OCInitStructure;   
TIM1_OCInitStructure(TIM1_OCMode  $=$  TIM1_OCMode_PWM1;   
TIM1_OCInitStructure(TIM1_OutputState  $=$  TIM1_OutputState_Enable;   
TIM1_OCInitStructure(TIM1_Pulse  $= 0x7FF$  .   
TIM1_OCInitStructure(TIM1_OCPolarity  $=$  TIM1_OCPolarity_Low;   
TIM1_OCInitStructure(TIM1_OCIdleState  $=$  TIM1_OCIdleState_Set;   
TIM1_OC4Init(&TIM1_OCInitStructure);
```

# 20.2.7 函数TIM1_BDTRConfig

Table 583. 描述了函数 TIM1_BDTRConfig

Table 583. 函数 TIM1_BDTRConfig  

<table><tr><td>函数名</td><td>TIM1_BDTRConfig</td></tr><tr><td>函数原形</td><td>void TIM1_BDTRConfig(TIM1_BDTRInitTypeDef *TIM1_BDTRInitStruct)</td></tr><tr><td>功能描述</td><td>设置刹车特性,死区时间,锁电平,OSSI,OSSR状态和AOE(自动输出使能)</td></tr><tr><td>输入参数</td><td>TIM1_BDTRInitStruct:指向结构TIM1_BDTRInitTypeDef的指针,包含了TIM1的BDTR寄存器的配置信息参阅Section:TIM1_BDTRInitTypeDef 查阅更多该参数允许取值范围</td></tr><tr><td>输出参数</td><td>无</td></tr><tr><td>返回值</td><td>无</td></tr><tr><td>先决条件</td><td>无</td></tr><tr><td>被调用函数</td><td>无</td></tr></table>

# TIM1_BDTRInitStruct structure

TIM1_BDTRInitStruct structure 定义于文件“stm32f10x_TIM1.h”：

```c
typedef struct   
{   
u16 TIM1_OSSRState;   
u16 TIM1_OSSIState;   
u16 TIM1_LOCKLevel;   
u16 TIM1DeadTIM1;   
u16 TIM1_Break;   
u16 TIM1_BreakPolarity;   
u16 TIM1_AutomaticOutput;   
}TIM1_BDTRInitTypeDef;
```

# TIM1_OSSRState

TIM1_OSSRState设置在运行模式下非工作状态选项。该参数取值见下表。

Table 584. TIM1 OSSRState 值  

<table><tr><td>TIM1_OSSRState</td><td>描述</td></tr><tr><td>TIM1_OSSRState_Enable</td><td>使能 TIM1 OSSR 状态</td></tr><tr><td>TIM1_OSSRState_Disable</td><td>失能 TIM1 OSSR 状态</td></tr></table>

# TIM1 OSSIState

TIM1_OSSIState 设置在运行模式下非工作状态选项。该参数取值见下表。

Table 585. TIM1_OSSIState 值  

<table><tr><td>TIM1_OSSIState</td><td>描述</td></tr><tr><td>TIM1_OSSIState_Enable</td><td>使能 TIM1 OSSI 状态</td></tr><tr><td>TIM1_OSSIState_Disable</td><td>失能 TIM1 OSSI 状态</td></tr></table>

# TIM1_LOCKLevel

TIM1_LOCKLevel 设置了锁电平参数。该参数取值见下表。

Table 586. TIM1_LOCKLevel 值  

<table><tr><td>TIM1_LOCKLevel</td><td>描述</td></tr><tr><td>TIM1_LOCKLevel_OFF</td><td>不锁任何位</td></tr><tr><td>TIM1_LOCKLevel_1</td><td>使用锁电平1</td></tr><tr><td>TIM1_LOCKLevel_2</td><td>使用锁电平2</td></tr><tr><td>TIM1_LOCKLevel_3</td><td>使用锁电平3</td></tr></table>

# TIM1_DeadTIM1

TIM1_DeadTIM1指定了输出打开和关闭状态之间的延时。

# TIM1 Break

TIM1_Break使能或者失能TIM1刹车输入。该参数取值见下表。

Table 587. TIM1_OSSIState 值  

<table><tr><td>TIM1_Break</td><td>描述</td></tr><tr><td>TIM1_Break_Enable</td><td>使能 TIM1 刹车输入</td></tr><tr><td>TIM1_Break_Disable</td><td>失能 TIM1 刹车输入</td></tr></table>

# TIM1_BreakPolarity

TIM1_BreakPolarity 设置 TIM1 刹车输入管脚极性。该参数取值见下表。

Table 588. TIM1_BreakPolarity 值  

<table><tr><td>TIM1_BreakPolarity</td><td>描述</td></tr><tr><td>TIM1_BreakPolarity_Low</td><td>TIM1 刹车输入管脚极性低</td></tr><tr><td>TIM1_BreakPolarity_High</td><td>TIM1 刹车输入管脚极性高</td></tr></table>

# TIM1_AutomaticOutput

TIM1_AutomaticOutput使能或者失能自动输出功能该参数取值见下表。

Table 589. TIM1_AutomaticOutput 值  

<table><tr><td>TIM1_AutomaticOutput</td><td>描述</td></tr><tr><td>TIM1_AutomaticOutput_Enable</td><td>自动输出功能使能</td></tr><tr><td>TIM1_AutomaticOutput_Disable</td><td>自动输出功能失能</td></tr></table>

# 例：

```c
/\*OSSR，OSSI，Automatic Output enable，Break，dead TIM1 and Lock Level configuration\*/   
TIM1_BDTRInitTypeDef TIM1_BDTRInitStructure;   
TIM1_BDTRInitStructure(TIM1_OSSRState  $=$  TIM1_OSSRState_Enable;   
TIM1_BDTRInitStructure(TIM1_OSSIState  $=$  TIM1_OSSIState_Enable;   
TIM1_BDTRInitStructure(TIM1_LOCKLevel  $=$  TIM1_LOCKLevel_1;   
TIM1_BDTRInitStructure(TIM1DeadTIM1  $= 0x05$  .   
TIM1_BDTRInitStructure(TIM1_Break  $=$  TIM1_Break_Enable;   
TIM1_BDTRInitStructure(TIM1_BreakPolarity  $=$    
TIM1_BreakPolarity_High;
```

# ST

译文英文原版为UM0427 Oct. 2007 Rev 2, 译文仅供参考，与英文版冲突的，以英文版为准

```c
TIM1_BDTRInitStructure.TIM1_AutomaticOutput = TIM1_AutomaticOutput_Enable;  
TIM1_BDTRConfig(&TIM1_BDTRInitStructure);
```

# 20.2.8 函数TIM1_ICInit

Table 590. 描述了函数 TIM1_ICInit

Table 590. 函数 TIM1_ICInit  

<table><tr><td>函数名</td><td>TIM1_OCInit</td></tr><tr><td>函数原形</td><td>void TIM1_ICInit(TIM1_ICInitTypeDef* TIM1_ICInitStruct)</td></tr><tr><td>功能描述</td><td>根据TIM1_ICInitStruct中指定的参数初始化外设TIM1</td></tr><tr><td>输入参数</td><td>TIM1_ICInitStruct: 指向结构TIM1_ICInitTypeDef的指针, 包含了TIM1的配置信息。参阅Section: TIM1_ICInitTypeDef 查阅更多该参数允许取值范围</td></tr><tr><td>输出参数</td><td>无</td></tr><tr><td>返回值</td><td>无</td></tr><tr><td>先决条件</td><td>无</td></tr><tr><td>被调用函数</td><td>无</td></tr></table>

# TIM1_ICInitTypeDef structure

TIM1_ICInitTypeDef 定义于文件“stm32f10x_TIM1.h”：

```c
typedef struct   
{   
u16 TIM1_Channel;   
u16 TIM1_ICPolarity;   
u16 TIM1_ICSelection;   
u16 TIM1_ICPrescaler;   
u16 TIM1_ICFilter;   
}TIM1_ICInitTypeDef;
```

# TIM1_Channel

TIM1_Channel 选择通道。该参数取值见下表。

Table 591. TIM1_Channel 值  

<table><tr><td>TIM1_Channel</td><td>描述</td></tr><tr><td>TIM1_Channel_1</td><td>使用TIM1通道1</td></tr><tr><td>TIM1_Channel_2</td><td>使用TIM1通道2</td></tr><tr><td>TIM1_Channel_3</td><td>使用TIM1通道3</td></tr><tr><td>TIM1_Channel_4</td><td>使用TIM1通道4</td></tr></table>

# TIM1_ICPolarity

TIM1_ICPolarity输入活动沿。该参数取值见下表。

Table 592. TIM1_Channel 值  

<table><tr><td>TIM1_OCPolarity</td><td>描述</td></tr><tr><td>TIM1_ICPolarity_Rising</td><td>TIM1 输入捕获上升沿</td></tr><tr><td>TIM1_ICPolarity_Falling</td><td>TIM1 输入捕获下降沿</td></tr></table>

# TIM1_ICSelection

TIM1_ICSelection选择输入。该参数取值见下表。

Table 593. TIM1_ICSelection 值  

<table><tr><td>TIM1_ICSelection</td><td>描述</td></tr><tr><td>TIM1_ICSelection_DirectTI</td><td>TIM1 输入 2, 3 或 4 选择对应地与 IC1 或 IC2 或 IC3 或 IC4 相连</td></tr><tr><td>TIM1_ICSelection_IndirectTI</td><td>TIM1 输入 2, 3 或 4 选择对应地与 IC2 或 IC1 或 IC4 或 IC3 相连</td></tr><tr><td>TIM1_ICSelection_TRC</td><td>TIM1 输入 2, 3 或 4 选择与 TRC 相连</td></tr></table>

# TIM1_ICPrescaler

TIM1_ICPrescaler设置输入捕获预分频器。该参数取值见下表。

Table 594. TIM1_ICPrescaler 值  

<table><tr><td>TIM1_ICPrescaler</td><td>描述</td></tr><tr><td>TIM1_ICPSC_DIV1</td><td>TIM1 捕获在捕获输入上每探测到一个边沿执行一次</td></tr><tr><td>TIM1_ICPSC_DIV2</td><td>TIM1 捕获每 2 个事件执行一次</td></tr><tr><td>TIM1_ICPSC_DIV3</td><td>TIM1 捕获每 3 个事件执行一次</td></tr><tr><td>TIM1_ICPSC_DIV4</td><td>TIM1 捕获每 4 个事件执行一次</td></tr></table>

# TIM1_ICFilter

TIM1_ICFilter选择输入比较滤波器。该参数取值在0x0和0xF之间。

例：

```c
/\*TIM1 Input Capture Channel 1 mode Configuration \*/   
TIM1_ICInitTypeDef TIM1_ICInitStructure;   
TIM1_ICInitStructure.TIM1_Channel  $=$  TIM1_Channel_1;   
TIM1_ICInitStructure.TIM1_ICPolarity  $=$  TIM1_ICPolarity_Falling;   
TIM1_ICInitStructure.TIM1_ICSelection  $=$  TIM1_ICSelection_DirectTI;   
TIM1_ICInitStructure.TIM1_ICPrescaler  $=$  TIM1_ICPSC_DIV2;   
TIM1_ICInitStructure.TIM1_ICFilter  $= 0\mathrm{x}0$    
TIM1_ICInit(&TIM1_ICInitStructure);
```

# 20.2.9 函数TIM1_PWMConfig

Table 595. 描述了函数 TIM1_PWMConfig  
Table 595. 函数 TIM1_PWMConfig  

<table><tr><td>函数名</td><td>TIM1_PWMConfig</td></tr><tr><td>函数原形</td><td>TIM1_PWMConfig(TIM1_ICInitTypeDef* TIM1_ICInitStruct)</td></tr><tr><td>功能描述</td><td>根据TIM1_ICInitStruct中指定的参数设置外设TIM1工作在PWM输入模式</td></tr><tr><td>输入参数</td><td>TIM1_ICInitStruct: 指向结构TIM1_ICInitTypeDef的指针,包含了TIM1的配置信息。参阅Section: TIM1_ICInitTypeDef 查阅更多该参数允许取值范围</td></tr><tr><td>输出参数</td><td>无</td></tr><tr><td>返回值</td><td>无</td></tr><tr><td>先决条件</td><td>无</td></tr><tr><td>被调用函数</td><td>无</td></tr></table>

例：

```txt
/\*TIM1PWMInputChannel1modeConfiguration\*/   
TIM1_ICInitTypeDefTIM1_ICInitStructure;   
TIM1_ICInitStructure.TIM1_Channel  $=$  TIM1_Channel_1;   
TIM1_ICInitStructure.TIM1_ICPolarity  $=$  TIM1_ICPolarity_Rising;   
TIM1_ICInitStructure.TIM1_ICSelection  $=$  TIM1_ICSelection_DirectTI;   
TIM1_ICInitStructure.TIM1_ICPrescaler  $=$  TIM1_ICPSC_DIV1;   
TIM1_ICInitStructure.TIM1_ICFilter  $= 0x0$    
TIM1_PWMConfig(&TIM1_ICInitStructure);
```

# 20.2.10 函数TIM1_TimeBaseStructInit

Table 596. 描述了函数TIM1_TimeBaseStructInit

Table 596. 函数 TIM1_TimeBaseStructInit  

<table><tr><td>函数名</td><td>TIM1_TimeBaseStructInit</td></tr><tr><td>函数原形</td><td>void TIM1_TimeBaseStructInit(TIM1_TimeBaseInitTypeDef* TIM1_TimeBaseInitStruct)</td></tr><tr><td>功能描述</td><td>把TIM1_TimeBaseInitStruct中的每一个参数按缺省值填入</td></tr><tr><td>输入参数</td><td>TIM1_TimeBaseInitStruct: 指向结构TIM1_TimeBaseInitTypeDef的指针, 待初始化</td></tr><tr><td>输出参数</td><td>无</td></tr><tr><td>返回值</td><td>无</td></tr><tr><td>先决条件</td><td>无</td></tr><tr><td>被调用函数</td><td>无</td></tr></table>

Table 597. 给出了TIM1_TimeBaseInitStruct各个成员的缺省值  
Table 597. TIM1_TimeBaseInitStruct 缺省值  

<table><tr><td>成员</td><td>缺省值</td></tr><tr><td>TIM1_Period</td><td>TIM1_Period Reset_Mask</td></tr><tr><td>TIM1_Prescaler</td><td>TIM1_Prescaler Reset_Mask</td></tr><tr><td>TIM1_CKD</td><td>TIM1_CKD_DIV1</td></tr><tr><td>TIM1 CounterMode</td><td>TIM1 CounterMode_Up</td></tr><tr><td>TIM1_RepetitionCounter</td><td>TIM1_RepetitionCounter Reset_Mask</td></tr></table>

例：

```txt
/\* The following example illustrates how to initialize a TIM1_BaseInitTypeDef structure \*/ TIM1_TimeBaseInitTypeDef TIM1_TimeBaseInitStructure; TIM1_TimeBaseStructInit(&TIM1_TimeBaseInitStructure);
```

# 20.2.11 函数TIM1_OCStructInit

Table 598. 描述了函数TIM1_OCStructInit

Table 598. 函数 TIM1_TimeBaseStructInit  

<table><tr><td>函数名</td><td>TIM1_TimeBaseStructInit</td></tr><tr><td>函数原形</td><td>void TIM1_OCStructInit(TIM1_OCInitTypeDef* TIM1_OCInitStruct)</td></tr><tr><td>功能描述</td><td>把TIM1_OCInitStruct中的每一个参数按缺省值填入</td></tr><tr><td>输入参数</td><td>TIM1_OCInitStruct: 指向结构TIM1_OCInitTypeDef的指针, 待初始化</td></tr><tr><td>输出参数</td><td>无</td></tr><tr><td>返回值</td><td>无</td></tr><tr><td>先决条件</td><td>无</td></tr><tr><td>被调用函数</td><td>无</td></tr></table>

Table 599. 给出了TIM1_OCInitStruct各个成员的缺省值

Table 599. TIM1_OCInitStruct 缺省值  

<table><tr><td>成员</td><td>缺省值</td></tr><tr><td>TIM1_OCMode</td><td>TIM1_OCMode_Timing</td></tr><tr><td>TIM1_OutputState</td><td>TIM1_OutputState_Disable</td></tr><tr><td>TIM1_OutputNState</td><td>TIM1_OutputNState_Disable</td></tr><tr><td>TIM1_Pulse</td><td>TIM1_Pulse Reset_Mask</td></tr><tr><td>TIM1_OCPolarity</td><td>TIM1_OCPolarity_High</td></tr><tr><td>TIM1_OCNPolarity</td><td>TIM1_OCNPolarity_High</td></tr><tr><td>TIM1_OCIdleState</td><td>TIM1_OCIdleState_Diset</td></tr><tr><td>TIM1_OCIdleState</td><td>TIM1_OCIdleState_Diset</td></tr></table>

例：  
/\* The following example illustrates how to initialize a  
TIM1 OCInitTypeDef structure */  
TIM1 OCInitTypeDef TIM1 OCInitStructure;  
TIM1_OCStructInit(& TIM1_OCInitStructure);

# 20.2.12 函数TIM1_ICStructInit

Table 600. 描述了函数TIM1_ICStructInit  
Table 600. 函数 TIM1_ICStructInit  

<table><tr><td>函数名</td><td>TIM1_ICStructInit</td></tr><tr><td>函数原形</td><td>void TIM1_ICStructInit(TIM1_ICInitTypeDef* TIM1_ICInitStruct)</td></tr><tr><td>功能描述</td><td>把TIM1_ICInitStruct中的每一个参数按缺省值填入</td></tr><tr><td>输入参数</td><td>TIM1_ICInitStruct: 指向结构TIM1_ICInitTypeDef的指针, 待初始化</td></tr><tr><td>输出参数</td><td>无</td></tr><tr><td>返回值</td><td>无</td></tr><tr><td>先决条件</td><td>无</td></tr><tr><td>被调用函数</td><td>无</td></tr></table>

Table 601. 给出了TIM1_ICInitStruct各个成员的缺省值  
Table 601. TIM1_ICInitStruct 缺省值  

<table><tr><td>成员</td><td>缺省值</td></tr><tr><td>TIM1_ICMode</td><td>TIM1_ICMode_ICAP</td></tr><tr><td>TIM1_Channel</td><td>TIM1_Channel_1</td></tr><tr><td>TIM1_ICPolarity</td><td>TIM1_ICPolarity_Rising</td></tr><tr><td>TIM1_ICPrescaler</td><td>TIM1_ICPSC_DIV1</td></tr><tr><td>TIM1_ICFilter</td><td>TIM1_ICFilter_Mask</td></tr></table>

例：  
/\* The following example illustrates how to initialize a TIM1 ICInitTypeDef structure \*/  
TIM1_ICInitTypeDef TIM1_ICInitStructure;  
TIM1_ICStructInit(& TIM1_ICInitStructure);

# 20.2.13 函数TIM1_BDTRStructInit

Table 602. 描述了函数 TIM1_BDTRStructInit

Table 602. 函数 TIM1_BDTRStructInit  

<table><tr><td>函数名</td><td>TIM1_TimeBaseStructInit</td></tr><tr><td>函数原形</td><td>void TIM1_TimeBaseStructInit(TIM1_TimeBaseInitTypeDef* TIM1_TimeBaseInitStruct)</td></tr><tr><td>功能描述</td><td>把TIM1_BDTRInitStruct中的每一个参数按缺省值填入</td></tr><tr><td>输入参数</td><td>TIM1_TimeBaseInitStruct: 指向结构TIM1_TimeBaseInitTypeDef的指针, 待初始化</td></tr><tr><td>输出参数</td><td>无</td></tr><tr><td>返回值</td><td>无</td></tr><tr><td>先决条件</td><td>无</td></tr><tr><td>被调用函数</td><td>无</td></tr></table>

Table 603. 给出了TIM1_TimeBaseInitStruct各个成员的缺省值  
Table 603. TIM1_TimeBaseInitStruct 缺省值  

<table><tr><td>成员</td><td>缺省值</td></tr><tr><td>TIM1_OSSRState</td><td>TIM1_OSSRState_Disable</td></tr><tr><td>TIM1_OSSIState</td><td>TIM1_OSSIState_Disable</td></tr><tr><td>TIM1_LOCKLevel</td><td>TIM1_LOCKLevel_OFF</td></tr><tr><td>TIM1_DeadTime</td><td>TIM1_DeadTime_Sett_Mask</td></tr><tr><td>TIM1_Break</td><td>TIM1_Break_Disable</td></tr><tr><td>TIM1_BreakPolarity</td><td>TIM1_BreakPolarity_Low</td></tr><tr><td>TIM1_AutomaticOutput</td><td>TIM1_AutomaticOutput_Disable</td></tr></table>

例：  
/\* The following example illustrates how to initialize a  
TIM1 BDTRInitTypeDef structure */  
TIM1 BDTRInitTypeDef TIM1 BDTRInitStructure;  
TIM1_BDTRStructInit(& TIM1_BDTRInitStructure);

# 20.2.14 函数TIM1_Cmd

Table 604. 描述了函数TIM1_Cmd  
Table 604. 函数 TIM1_Cmd  

<table><tr><td>函数名</td><td>TIM1_Cmd</td></tr><tr><td>函数原形</td><td>void TIM1_Cmd(FunctionalState NewState)</td></tr><tr><td>功能描述</td><td>使能或者失能 TIM1 外设</td></tr><tr><td>输入参数</td><td>NewState: 外设 TIM1 的新状态
这个参数可以取: ENABLE 或者 DISABLE</td></tr><tr><td>输出参数</td><td>无</td></tr><tr><td>返回值</td><td>无</td></tr><tr><td>先决条件</td><td>无</td></tr><tr><td>被调用函数</td><td>无</td></tr></table>

例：  
/* Enables the TIM1 counter */  
TIM1_Cmd(ENABLE)；

# 20.2.15 函数TIM1_CtrlPWMOutputs

Table 605. 描述了函数TIM1_CtrlPWMOutputs

Table 605. 函数 TIM1_CtrlPWMOutputs  

<table><tr><td>函数名</td><td>TIM1_CtrlPWMOutputs</td></tr><tr><td>函数原形</td><td>void TIM1_CtrlPWMOutputs(FunctionalState Newstate)</td></tr><tr><td>功能描述</td><td>使能或者失能 TIM1 的主输出</td></tr><tr><td>输入参数</td><td>NewState: 外设 TIM1 主输出的新状态
这个参数可以取: ENABLE 或者 DISABLE</td></tr><tr><td>输出参数</td><td>无</td></tr><tr><td>返回值</td><td>无</td></tr><tr><td>先决条件</td><td>无</td></tr><tr><td>被调用函数</td><td>无</td></tr></table>

例：  
/\*Enables the TIM1 peripheral Main Outputs. \*/TIM1_CtrlPWMOputs(ENABLE);

# 20.2.16 函数TIM1_ITConfig

Table 606. 描述了函数TIM1_ITConfig  
Table 606. 函数 TIM1_ITConfig  

<table><tr><td>函数名</td><td>TIM1_ITConfig</td></tr><tr><td>函数原形</td><td>void TIM1_ITConfig(u16 TIM1_IT, FunctionalState NewState)</td></tr><tr><td>功能描述</td><td>使能或者失能指定的 TIM1 中断</td></tr><tr><td>输入参数 1</td><td>TIM1_IT: 待使能或者失能的 TIM 中断源
参阅 Section: TIM1_IT 查阅更多该参数允许取值范围</td></tr><tr><td>输入参数 2</td><td>NewState: TIM1 中断的新状态
这个参数可以取: ENABLE 或者 DISABLE</td></tr><tr><td>输出参数</td><td>无</td></tr><tr><td>返回值</td><td>无</td></tr><tr><td>先决条件</td><td>无</td></tr><tr><td>被调用函数</td><td>无</td></tr></table>

# TIM1_IT

输入参数TIM1_IT使能或者失能TIM的中断。可以取下表的一个或者多个取值的组合作为该参数的值。

Table 607. TIM1_IT 值  

<table><tr><td>TIM1_IT</td><td>描述</td></tr><tr><td>TIM1_IT_Update</td><td>TIM1中断源</td></tr><tr><td>TIM1_IT_CC1</td><td>TIM1捕获/比较1中断源</td></tr><tr><td>TIM1_IT_CC2</td><td>TIM1捕获/比较2中断源</td></tr><tr><td>TIM1_IT_CC3</td><td>TIM1捕获/比较3中断源</td></tr><tr><td>TIM1_IT_CC4</td><td>TIM1捕获/比较4中断源</td></tr><tr><td>TIM1_IT_COM</td><td>TIM1 COM中断源</td></tr><tr><td>TIM1_IT_Trigger</td><td>TIM1触发中断源</td></tr><tr><td>TIM1_IT_BRK</td><td>TIM1刹车中断源</td></tr></table>

例：  
/\*Enables the TIM1 Capture Compare channel 1 Interrupt source \*/TIM1_ITConfig(TIM1_IT_CC1, ENABLE);

# 20.2.17 函数TIM1_DMAConfig

Table 608. 描述了函数TIM1_DMAConfig  
Table 608. 函数 TIM1_DMAConfig  

<table><tr><td>函数名</td><td>TIM1_DMAConfig</td></tr><tr><td>函数原形</td><td>void TIM1_ITConfig(u16 TIM1_IT, FunctionalState NewState)</td></tr><tr><td>功能描述</td><td>设置TIM1的DMA接口</td></tr><tr><td>输入参数1</td><td>TIM1_DMABase: DMA传输起始地址
参阅Section: TIM1_DMABase 查阅更多该参数允许取值范围</td></tr><tr><td>输入参数2</td><td>TIM1_DMABurstLength: DMA连续传送长度
参阅Section: TIM1_DMABurstLength 查阅更多该参数允许取值范围</td></tr><tr><td>输出参数</td><td>无</td></tr><tr><td>返回值</td><td>无</td></tr><tr><td>先决条件</td><td>无</td></tr><tr><td>被调用函数</td><td>无</td></tr></table>

# TIM1_DMABase

TIM1_DMABase 设置 DMA 传输起始地址。可以取下表的值。

Table 609. TIM1_DMABase 值  

<table><tr><td>TIM1_DMABase</td><td>描述</td></tr><tr><td>TIM1_DMABase_CR1</td><td>TIM1 CR1 寄存器作为 DMA 传输起始</td></tr><tr><td>TIM1_DMABase_CR2</td><td>TIM1 CR2 寄存器作为 DMA 传输起始</td></tr><tr><td>TIM1_DMABase_SMCR</td><td>TIM1 SMCR 寄存器作为 DMA 传输起始</td></tr><tr><td>TIM1_DMABase_DIER</td><td>TIM1 DIER 寄存器作为 DMA 传输起始</td></tr><tr><td>TIM1_DMABase_SR</td><td>TIM1 SR 寄存器作为 DMA 传输起始</td></tr><tr><td>TIM1_DMABase_EGR</td><td>TIM1 EGR 寄存器作为 DMA 传输起始</td></tr><tr><td>TIM1_DMABase_CCMR1</td><td>TIM1 CCMR1 寄存器作为 DMA 传输起始</td></tr><tr><td>TIM1_DMABase_CCMR2</td><td>TIM1 CCMR2 寄存器作为 DMA 传输起始</td></tr><tr><td>TIM1_DMABase_CCER</td><td>TIM1 CCER 寄存器作为 DMA 传输起始</td></tr><tr><td>TIM1_DMABase_CNT</td><td>TIM1 CNT 寄存器作为 DMA 传输起始</td></tr><tr><td>TIM1_DMABase_PSC</td><td>TIM1 PSC 寄存器作为 DMA 传输起始</td></tr><tr><td>TIM1_DMABase_ERR</td><td>TIM1 APR 寄存器作为 DMA 传输起始</td></tr><tr><td>TIM1_DMABase_RCR</td><td>TIM1RCR 寄存器作为 DMA 传输起始</td></tr><tr><td>TIM1_DMABase_CCR1</td><td>TIM1 CCR1 寄存器作为 DMA 传输起始</td></tr><tr><td>TIM1_DMABase_CCR2</td><td>TIM1 CCR2 寄存器作为 DMA 传输起始</td></tr><tr><td>TIM1_DMABase_CCR3</td><td>TIM1 CCR3 寄存器作为 DMA 传输起始</td></tr><tr><td>TIM1_DMABase_CCR4</td><td>TIM1 CCR4 寄存器作为 DMA 传输起始</td></tr><tr><td>TIM1_DMABase_BDTR</td><td>TIM1 BDTR 寄存器作为 DMA 传输起始</td></tr><tr><td>TIM1_DMABase_DCR</td><td>TIM1 DCR 寄存器作为 DMA 传输起始</td></tr></table>

# TIM1_DMABurstLength

TIM1_DMABurstLength 设置 DMA 连续传送长度。可以取下表的值。

Table 610. TIM1_DMA BurstLength 值  

<table><tr><td>TIM1_DMABurstLength</td><td>描述</td></tr><tr><td>TIM1_DMABurstLength_1Byte</td><td>TIM1 DMA 连续传送长度 1 字</td></tr><tr><td>TIM1_DMABurstLength_2Bytes</td><td>TIM1 DMA 连续传送长度 2 字</td></tr><tr><td>TIM1_DMABurstLength_3Bytes</td><td>TIM1 DMA 连续传送长度 3 字</td></tr><tr><td>TIM1_DMABurstLength_4Bytes</td><td>TIM1 DMA 连续传送长度 4 字</td></tr></table>

TIM1  

<table><tr><td>TIM1_DMABurstLength_5Bytes</td><td>TIM1 DMA 连续传送长度 5 字</td></tr><tr><td>TIM1_DMABurstLength_6Bytes</td><td>TIM1 DMA 连续传送长度 6 字</td></tr><tr><td>TIM1_DMABurstLength_7Bytes</td><td>TIM1 DMA 连续传送长度 7 字</td></tr><tr><td>TIM1_DMABurstLength_8Bytes</td><td>TIM1 DMA 连续传送长度 8 字</td></tr><tr><td>TIM1_DMABurstLength_9Bytes</td><td>TIM1 DMA 连续传送长度 9 字</td></tr><tr><td>TIM1_DMABurstLength_10Bytes</td><td>TIM1 DMA 连续传送长度 10 字</td></tr><tr><td>TIM1_DMABurstLength_11Bytes</td><td>TIM1 DMA 连续传送长度 11 字</td></tr><tr><td>TIM1_DMABurstLength_12Bytes</td><td>TIM1 DMA 连续传送长度 12 字</td></tr><tr><td>TIM1_DMABurstLength_13Bytes</td><td>TIM1 DMA 连续传送长度 13 字</td></tr><tr><td>TIM1_DMABurstLength_14Bytes</td><td>TIM1 DMA 连续传送长度 14 字</td></tr><tr><td>TIM1_DMABurstLength_15Bytes</td><td>TIM1 DMA 连续传送长度 15 字</td></tr><tr><td>TIM1_DMABurstLength_16Bytes</td><td>TIM1 DMA 连续传送长度 16 字</td></tr><tr><td>TIM1_DMABurstLength_17Bytes</td><td>TIM1 DMA 连续传送长度 17 字</td></tr><tr><td>TIM1_DMABurstLength_18Bytes</td><td>TIM1 DMA 连续传送长度 18 字</td></tr></table>

例：  
/\* Configures the TIM1 DMA Interface to transfer 1 byte and to use  
the CCR1 as base address \*/  
TIM1_DMAConfig(TIM1_DMABase_CCR1, TIM1_DMA BurstLength_1Byte)

# 20.2.18 函数TIM1_DMAcmd

Table 611. 描述了函数TIM1_DMACmd  
Table 611. 函数 TIM1_DMAcmd  

<table><tr><td>函数名</td><td>TIM1_DMAcmd</td></tr><tr><td>函数原形</td><td>void TIM1_DMAcmd(u16 TIM1_DMASource, FunctionalState Newstate)</td></tr><tr><td>功能描述</td><td>使能或者失能指定的 TIM1 的 DMA 请求</td></tr><tr><td>输入参数 1</td><td>TIM1_DMASource: 待使能或者失能的 TIM 中断源
参阅 Section: TIM1_DMASource 查阅更多该参数允许取值范围</td></tr><tr><td>输入参数 2</td><td>NewState: DMA 请求的新状态
这个参数可以取: ENABLE 或者 DISABLE</td></tr><tr><td>输出参数</td><td>无</td></tr><tr><td>返回值</td><td>无</td></tr><tr><td>先决条件</td><td>无</td></tr><tr><td>被调用函数</td><td>无</td></tr></table>

# TIM1 DMASource

输入参数TIM1_DMASource使能或者失能TIM的中断。可以取下表的值。

Table 612. TIM1_DMASource 值  

<table><tr><td>TIM1_DMASource</td><td>描述</td></tr><tr><td>TIM1_DMA_Update</td><td>TIM1 更新 DMA 源</td></tr><tr><td>TIM1_DMA_CC1</td><td>TIM1 捕获/比较 1DMA 源</td></tr><tr><td>TIM1_DMA_CC2</td><td>TIM1 捕获/比较 2DMA 源</td></tr><tr><td>TIM1_DMA_CC3</td><td>TIM1 捕获/比较 3DMA 源</td></tr><tr><td>TIM1_DMA_CC4</td><td>TIM1 捕获/比较 4DMA 源</td></tr><tr><td>TIM1_DMA_COM</td><td>TIM1 COM DMA 源</td></tr><tr><td>TIM1_DMA_Trigger</td><td>TIM1 触发 DMA 源</td></tr></table>

例：  
/* TIM1 Capture Compare 1 DMA Request Configuration */  
TIM1_DMACmd(TIM1_DMA_CC1，ENABLE);

# 20.2.19 函数TIM1/InternalClockConfig

Table 613. 描述了函数TIM1/InternalClockConfig  
Table 613. 函数 TIM1/InternalClockConfig  

<table><tr><td>函数名</td><td>TIM1/InternalClockConfig</td></tr><tr><td>函数原形</td><td>void TIM1/InternalClockConfig(void)</td></tr><tr><td>功能描述</td><td>设置TIM1内部时钟</td></tr><tr><td>输入参数</td><td>无</td></tr><tr><td>输出参数</td><td>无</td></tr><tr><td>返回值</td><td>无</td></tr><tr><td>先决条件</td><td>无</td></tr><tr><td>被调用函数</td><td>无</td></tr></table>

例：
/* Selects the internal clock for TIM2 */
TIM1/InternalClockConfig(TIM2);

# 20.2.20 函数TIM1_ETRClockMode1Config

Table 614. 描述了函数TIM1_ETRClockMode1Config  
Table 614. 函数 TIM1_ETRClockMode1Config  

<table><tr><td>函数名</td><td>TIM1_ETRClockMode1Config</td></tr><tr><td>函数原形</td><td>void TIM1_ETRClockMode1Config(u16 TIM1_ExtTRGPrescaler,u16 TIM1_ExtTRGPolarity,u16 ExtTRGFilter)</td></tr><tr><td>功能描述</td><td>配置TIM1外部时钟模式1</td></tr><tr><td>输入参数1</td><td>TIM1_ExtTRGPrescaler:外部触发预分频参阅Section:TIM1_ExtTRGPrescaler 查阅更多该参数允许取值范围</td></tr><tr><td>输入参数2</td><td>TIM1_ExtTRGPolarity:外部时钟极性参阅Section:TIM1_ExtTRGPolarity 查阅更多该参数允许取值范围</td></tr><tr><td>输入参数3</td><td>ExtTRGFilter:外部触发滤波器。该参数取值在0x0和0xF之间。</td></tr><tr><td>输出参数</td><td>无</td></tr><tr><td>返回值</td><td>无</td></tr><tr><td>先决条件</td><td>无</td></tr><tr><td>被调用函数</td><td>无</td></tr></table>

# TIM1_ExtTRGPrescaler

TIM1_ExtTRPGrescaler设置TIM1外部触发预分频。见Table493.参阅该参数的取值。

Table 615. TIM1 ExtTRGPrescaler 值  

<table><tr><td>TIM1_ExtTRGPrescaler</td><td>描述</td></tr><tr><td>TIM1_ExtTRGPSC_OFF</td><td>TIM1 ETRP 预分频 OFF</td></tr><tr><td>TIM1_ExtTRGPSC_DIV2</td><td>TIM1 ETRP 频率除以 2</td></tr><tr><td>TIM1_ExtTRGPSC_DIV4</td><td>TIM1 ETRP 频率除以 4</td></tr><tr><td>TIM1_ExtTRGPSC_DIV8</td><td>TIM1 ETRP 频率除以 8</td></tr></table>

# TIM1_ExtTRGPolarity

TIM1_ExtTRGPolarity设置TIM1外部触发极性。见Table 494.参阅该参数的取值。

Table 616. TIM1_ExtTRGPolarity 值  

<table><tr><td>TIM1_ExtTRGPolarity</td><td>描述</td></tr><tr><td>TIM1_ExtTRGPolarity_Inverted</td><td>TIM1 外部触发极性翻转：低电平或下降沿有效</td></tr><tr><td>TIM1_ExtTRGPolarity_NonInverted</td><td>TIM1 外部触发极性非翻转：高电平或上升沿有效</td></tr></table>

例：

/\* Selects the external clock Mode 1 for TIM1: the external clock is connected to ETR input pin, the rising edge is the active edge, no filter sampling is done (ExtTRGFilter  $= 0$  ) and the prescaler is fixed to TIM1_ExtTRGPSC_DIV2 \*/ TIM1_ExternalCLK1Config(TIM1_ExtTRGPSC_DIV2, TIM1_ExtTRGPolarity_NonInverted, 0x0);

# 20.2.21 函数TIM1_ETRClockMode2Config

Table 617. 描述了函数TIM1_ETRClockMode2Config  
Table 617. 函数 TIM1_ETRClockMode2Config  

<table><tr><td>函数名</td><td>TIM1_ETRClockMode2Config</td></tr><tr><td>函数原形</td><td>void TIM1_ETRClockMode2Config(u16 TIM1_ExtTRGPrescaler,u16 TIM1_ExtTRGPolarity, u16 ExtTRGFilter)</td></tr><tr><td>功能描述</td><td>配置TIM1外部时钟模式2</td></tr><tr><td>输入参数1</td><td>TIM1_ExtTRGPrescaler: 外部触发预分频参阅Section: TIM1_ExtTRGPrescaler 查阅更多该参数允许取值范围</td></tr><tr><td>输入参数2</td><td>TIM1_ExtTRGPolarity: 外部时钟极性参阅Section: TIM1_ExtTRGPolarity 查阅更多该参数允许取值范围</td></tr><tr><td>输入参数3</td><td>ExtTRGFilter: 外部触发滤波器。该参数取值在0x0和0xF之间。</td></tr><tr><td>输出参数</td><td>无</td></tr><tr><td>返回值</td><td>无</td></tr><tr><td>先决条件</td><td>无</td></tr><tr><td>被调用函数</td><td>无</td></tr></table>

例：

/\* Selects the external clock Mode 2 for TIM1: the external clock is connected to ETR input pin, the rising edge is the active edge, no filter sampling is done (ExtTRGFilter  $= 0$  ) and the prescaler is fixed to TIM1_ExtTRGPSC_DIV2 \*/ TIM1_ExternalCLK2Config(TIM1_ExtTRGPSC_DIV2, TIM1_ExtTRGPolarity_NonInverted, 0x0);

# 20.2.22 函数TIM1_ETRConfig

Table 618. 描述了函数TIM1_ETRConfig

Table 618. 函数 TIM1_ETRConfig  

<table><tr><td>函数名</td><td>TIM1_ETRConfig</td></tr><tr><td>函数原形</td><td>void TIM1_ETRConfig(u16 TIM1_ExtTRGPrescaler, u16 TIM1_ExtTRGPolarity, u8 ExtTRGFilter)</td></tr><tr><td>功能描述</td><td>配置TIM1外部触发</td></tr><tr><td>输入参数1</td><td>TIM1_ExtTRGPrescaler: 外部触发预分频
参阅Section: TIM1_ExtTRGPrescaler 查阅更多该参数允许取值范围</td></tr><tr><td>输入参数2</td><td>TIM1_ExtTRGPolarity: 外部时钟极性
参阅Section: TIM1_ExtTRGPolarity 查阅更多该参数允许取值范围</td></tr><tr><td>输入参数3</td><td>ExtTRGFilter: 外部触发滤波器。该参数取值在0x0和0xF之间。</td></tr><tr><td>输出参数</td><td>无</td></tr><tr><td>返回值</td><td>无</td></tr><tr><td>先决条件</td><td>无</td></tr><tr><td>被调用函数</td><td>无</td></tr></table>

例：

```txt
/\* Configure the External Trigger (ETR) for TIM1: the rising edge is the active edge, no filter sampling is done (ExtTRGFilter  $= 0$  ) and the prescaler is fixed to TIM1_ExtTRGPSC_DIV2 \*/ TIM1_ExternalCLK2Config(TIM1_ExtTRGPSC_DIV2, TIM1_ExtTRGPolarity_NonInverted, 0x0);
```

# 20.2.23 函数TIM1_ITRxExternalClockConfig

Table 619. 描述了函数TIM1_ITRxExternalClockConfig

Table 619. 函数 TIM1_ITRxExternalClockConfig  

<table><tr><td>函数名</td><td>TIM1_ITRxExternalClockConfig</td></tr><tr><td>函数原形</td><td>void TIM1_ITRxExternalClockConfig(u16 TIM1_InputTriggerSource)</td></tr><tr><td>功能描述</td><td>设置TIM1内部触发为外部时钟模式</td></tr><tr><td>输入参数</td><td>TIM1_InputTriggerSource: 输入触发源
参阅 Section: TIM1_InputTriggerSource 查阅更多该参数允许取值范围</td></tr><tr><td>输出参数</td><td>无</td></tr><tr><td>返回值</td><td>无</td></tr><tr><td>先决条件</td><td>无</td></tr><tr><td>被调用函数</td><td>无</td></tr></table>

# TIM1_InputTriggerSource

TIM1_InputTriggerSource 选择 TIM 输入触发。见 Table 620. 参阅该参数的取值。

Table 620. TIM1_InputTriggerSource 值  

<table><tr><td>TIM1_InputTriggerSource</td><td>描述</td></tr><tr><td>TIM1_TS_ITR0</td><td>TIM1 内部触发 0</td></tr><tr><td>TIM1_TS_ITR1</td><td>TIM1 内部触发 1</td></tr><tr><td>TIM1_TS_ITR2</td><td>TIM1 内部触发 2</td></tr><tr><td>TIM1_TS_ITR3</td><td>TIM1 内部触发 3</td></tr></table>

例：

```txt
/\*TIM1internal trigger3used as clock source \*/ TIM1_ITRxExternalClockConfig(TIM1_TS_ITR3);
```

# 20.2.24 函数TIM1_TIxExternalClockConfig

Table 621. 描述了函数TIM1_TIxExternalClockConfig

Table 621. 函数 TIM1_TIxExternalClockConfig  

<table><tr><td>函数名</td><td>TIM1_TIxExternalClockConfig</td></tr><tr><td>函数原形</td><td>void TIM1_TIxExternalClockConfig(u16 TIM1_TIxExternalCLKSource, u16 TIM1_ICPolarity, u16 ICFilter)</td></tr><tr><td>功能描述</td><td>设置TIM1触发为外部时钟</td></tr><tr><td>输入参数1</td><td>TIM1_TIxExternalCLKSource: 触发源
参阅 Section: TIM1_TIxExternalCLKSource 查阅更多该参数允许取值范围</td></tr><tr><td>输入参数2</td><td>TIM1_ICPolarity: 指定的TI极性
参阅 Section: TIM1_ICPolarity 查阅更多该参数允许取值范围</td></tr><tr><td>输入参数3</td><td>ICFilter: 指定的输入比较滤波器。该参数取值在0x0和0xF之间。</td></tr><tr><td>输出参数</td><td>无</td></tr><tr><td>返回值</td><td>无</td></tr><tr><td>先决条件</td><td>无</td></tr><tr><td>被调用函数</td><td>无</td></tr></table>

# TIM1_TXExternalCLKSource

TIM1_TIxExternalCLKSource选择TIM1外部时钟源。见Table 622.参阅该参数的取值。

Table 622. TIM1_TXExternalCLKSource 值  

<table><tr><td>TIM1_TXExternalCLKSource</td><td>描述</td></tr><tr><td>TIM1_TS_TI1FP1</td><td>TIM1 IC1 连接到 TI1</td></tr><tr><td>TIM1_TS_TI1FP2</td><td>TIM1 IC2 连接到 TI2</td></tr><tr><td>TIM1_TS_TI1F_ED</td><td>TIM1 IC1 连接到 TI1: 使用边沿探测</td></tr></table>

例：

```txt
/\* Selects the TI1 as clock for TIM1: the external clock is connected to TI1 input pin, the rising edge is the active edge and no filter sampling is done (ICFilter  $= 0$  \*/TIM1_TXExternalClockConfig(TIM1_TS_T1FP1, TIM1_ICPolarity_Rising, 0);
```

# 20.2.25 函数TIM1_SelectionTrigger

Table 623. 描述了函数TIM1_SelectionTrigger

Table 623. 函数 TIM1_SelectionTrigger  

<table><tr><td>函数名</td><td>TIM1_SelectionTrigger</td></tr><tr><td>函数原形</td><td>void TIM1_SelectionTrigger(TIM1TypeDef* TIM1, u16 TIM1_InputTriggerSource)</td></tr><tr><td>功能描述</td><td>选择 TIM1 输入触发源</td></tr><tr><td>输入参数</td><td>TIM1_InputTriggerSource: 输入触发源
参阅 Section: TIM1_InputTriggerSource 查阅更多该参数允许取值范围</td></tr><tr><td>输出参数</td><td>无</td></tr><tr><td>返回值</td><td>无</td></tr><tr><td>先决条件</td><td>无</td></tr><tr><td>被调用函数</td><td>无</td></tr></table>

# TIM1_InputTriggerSource

TIM1_InputTriggerSource选择TIM1输入触发源。见Table 498.参阅该参数的取值。

Table 624. TIM1_InputTriggerSource 值  

<table><tr><td>TIM1_InputTriggerSource</td><td>描述</td></tr><tr><td>TIM1_TS_ITR0</td><td>TIM1 内部触发 0</td></tr><tr><td>TIM1_TS_ITR1</td><td>TIM1 内部触发 1</td></tr><tr><td>TIM1_TS_ITR2</td><td>TIM1 内部触发 2</td></tr><tr><td>TIM1_TS_ITR3</td><td>TIM1 内部触发 3</td></tr><tr><td>TIM1_TS_TI1F_ED</td><td>TIM 1 TL1 边沿探测器</td></tr><tr><td>TIM1_TS_TI1FP1</td><td>TIM1 经滤波定时器输入 1</td></tr><tr><td>TIM1_TS_TI2FP2</td><td>TIM1 经滤波定时器输入 2</td></tr><tr><td>TIM1_TS_ETRF</td><td>TIM1 外部触发输入</td></tr></table>

例：

/\* Selects the Internal Trigger 3 as input trigger fot TIM1 \*/ void TIM1_SelectInputTrigger(TIM1_TS_ITR3);

# 20.2.26 函数TIM1_UpdateDisableConfig

Table 625. 描述了函数TIM1_UpdateDisableConfig

Table 625. 函数 TIM1_UpdateDisableConfig  

<table><tr><td>函数名</td><td>TIM1_UpdateDisableConfig</td></tr><tr><td>函数原形</td><td>void TIM1_UpdateDisableConfig(FunctionalState Newstate)</td></tr><tr><td>功能描述</td><td>使能或者失能 TIM1 更新事件</td></tr><tr><td>输入参数</td><td>NewState: TIM1_CR1 寄存器 UDIS 位的新状态
这个参数可以取: ENABLE 或者 DISABLE</td></tr><tr><td>输出参数</td><td>无</td></tr><tr><td>返回值</td><td>无</td></tr><tr><td>先决条件</td><td>无</td></tr><tr><td>被调用函数</td><td>无</td></tr></table>

例：

/\*Enables the Update event for TIM1 \*/TIM1_UpdateDisableConfig(DISABLE);

# 20.2.27 函数TIM1_UpdateRequestConfig

Table 626. 描述了函数TIM1_UpdateRequestConfig

Table 626. 函数 TIM1_UpdateRequestConfig  

<table><tr><td>函数名</td><td>TIM1_UpdateRequestConfig</td></tr><tr><td>函数原形</td><td>void TIM1_UpdateRequestConfig(u8 TIM1_UpdateSource)</td></tr><tr><td>功能描述</td><td>设置TIM1更新请求源</td></tr><tr><td>输入参数</td><td>TIM1_UpdateSource: TIM更新请求源
参阅Section: TIM1_UpdateSource 查阅更多该参数允许取值范围</td></tr><tr><td>输出参数</td><td>无</td></tr><tr><td>返回值</td><td>无</td></tr><tr><td>先决条件</td><td>无</td></tr><tr><td>被调用函数</td><td>无</td></tr></table>

# TIM1_UpdateSource

TIM1_UpdateSource 选择 TIM1 更新源。见 Table 534. 参阅该参数的取值。

Table 627. TIM1_UpdateSource 值  

<table><tr><td>TIM1_UpdateSource</td><td>描述</td></tr><tr><td>TIM1_UpdateSourceGLOBAL</td><td>生成重复的脉冲：在更新事件时计数器不停止</td></tr><tr><td>TIM1_UpdateSource-Regular</td><td>生成单一的脉冲：计数器在下一个更新事件停止</td></tr></table>

例：

/\* Selects the regular update source for TIM1 \*/TIM1_UpdateRequestConfig(TIM1_UpdateSource-Regular);

# 20.2.28 函数TIM1_SelectHallSensor

Table 628. 描述了函数TIM1_SelectHallSensor

Table 628. 函数 TIM1_SelectHallSensor  

<table><tr><td>函数名</td><td>TIM1_SelectHallSensor</td></tr><tr><td>函数原形</td><td>void TIM1_SelectHallSensor(TIM1TypeDef* TIM1, FunctionalState Newstate)</td></tr><tr><td>功能描述</td><td>使能或者失能 TIM1 霍尔传感器接口</td></tr><tr><td>输入参数</td><td>NewState: TIM1 霍尔传感器接口的新状态
这个参数可以取: ENABLE 或者 DISABLE</td></tr><tr><td>输出参数</td><td>无</td></tr><tr><td>返回值</td><td>无</td></tr><tr><td>先决条件</td><td>无</td></tr><tr><td>被调用函数</td><td>无</td></tr></table>

例：

/\* Selects the Hall Sensor Interface for TIM1 \*/TIM1_SelectHallSensor(ENABLE);

# 20.2.29 函数TIM1_SelectOnePulseMode

Table 629. 描述了函数TIM1_SelectOnePulseMode

Table 629. 函数 TIM1_SelectOnePulseMode  

<table><tr><td>函数名</td><td>TIM1_SelectOnePulseMode</td></tr><tr><td>函数原形</td><td>void TIM1_SelectOnePulseMode(u16 TIM1_OPMode)</td></tr><tr><td>功能描述</td><td>设置TIM1单脉冲模式</td></tr><tr><td>输入参数</td><td>TIM1_OPMode: OPM模式
参阅Section: TIM1_OPMode 查阅更多该参数允许取值范围</td></tr><tr><td>输出参数</td><td>无</td></tr><tr><td>返回值</td><td>无</td></tr><tr><td>先决条件</td><td>无</td></tr><tr><td>被调用函数</td><td>无</td></tr></table>

# TIM1_OPMode

TIM1_OPMode 选择 TIM1 更新源。见 Table 630. 参阅该参数的取值。

Table 630. TIM1_OPMode 值  

<table><tr><td>TIM1_OPMode</td><td>描述</td></tr><tr><td>TIM1_OPMode_Repetitive</td><td>生成重复的脉冲：在更新事件时计数器不停止</td></tr><tr><td>TIM1_OPMode_Single</td><td>生成单一的脉冲：计数器在下一个更新事件停止</td></tr></table>

例：

/\* Selects the Single One Pulse Mode for TIM1 \*/TIM1_SELECTOnePulseMode(TIM1_OPMode_Single);

# 20.2.30 函数TIM1_SelectOutputTrigger

Table 631. 描述了函数TIM1_SelectionTrigger

Table 631. 函数 TIM1_SelectOutputTrigger  

<table><tr><td>函数名</td><td>TIM1_SelectOutputTrigger</td></tr><tr><td>函数原形</td><td>void TIM1_SelectOutputTrigger(u16 TIM1_TRGOSource)</td></tr><tr><td>功能描述</td><td>选择TIM1触发输出模式</td></tr><tr><td>输入参数</td><td>TIM1_TRGOSource: 触发输出模式
参阅 Section: TIM1_TRGOSource 查阅更多该参数允许取值范围</td></tr><tr><td>输出参数</td><td>无</td></tr><tr><td>返回值</td><td>无</td></tr><tr><td>先决条件</td><td>无</td></tr><tr><td>被调用函数</td><td>无</td></tr></table>

# TIM1_TRGOSource

TIM1_TRGOSource 选择 TIM 触发输出源。见 Table 632. 参阅该参数的取值。

Table 632. TIM1_TRGOSource 值  

<table><tr><td>TIM1_TRGOSource</td><td>描述</td></tr><tr><td>TIM1_TRGOSource Reset</td><td>使用寄存器TIM1_EGR的UG位作为触发输出（TRGO）</td></tr><tr><td>TIM1_TRGOSource_Enable</td><td>使用计数器使能CEN作为触发输出（TRGO）</td></tr><tr><td>TIM1_TRGOSource_Update</td><td>使用更新事件作为触发输出（TRGO）</td></tr><tr><td>TIM1_TRGOSource_OC1</td><td>一旦捕获或者比较匹配发生，当标志位CC1F被设置时触发输出发送一个肯定脉冲（TRGO）</td></tr><tr><td>TIM1_TRGOSource_OC1Ref</td><td>使用OC1REF作为触发输出（TRGO）</td></tr><tr><td>TIM1_TRGOSource_OC2Ref</td><td>使用OC2REF作为触发输出（TRGO）</td></tr><tr><td>TIM1_TRGOSource_OC3Ref</td><td>使用OC3REF作为触发输出（TRGO）</td></tr><tr><td>TIM1_TRGOSource_OC4Ref</td><td>使用OC4REF作为触发输出（TRGO）</td></tr></table>

例：

```c
/\* Selects the update event as TRGO for TIM1 \*/TIM1_SelectOutputTrigger(TIM1_TRGOSource_Update);
```

# 20.2.31 函数TIM1_SelectSlaveMode

Table 633. 描述了函数TIM1_SelectionMode

Table 633. 函数 TIM1 SelectSlaveMode  

<table><tr><td>函数名</td><td>TIM1_SelectSlaveMode</td></tr><tr><td>函数原形</td><td>void TIM1_SelectSlaveMode(u16 TIM1_SlaveMode)</td></tr><tr><td>功能描述</td><td>选择TIM1从模式</td></tr><tr><td>输入参数</td><td>TIM1_SlaveMode: TIM从模式
参阅Section: TIM1_SlaveMode 查阅更多该参数允许取值范围</td></tr><tr><td>输出参数</td><td>无</td></tr><tr><td>返回值</td><td>无</td></tr><tr><td>先决条件</td><td>无</td></tr><tr><td>被调用函数</td><td>无</td></tr></table>

# TIM1_SlaveMode

TIM1_SlaveMode 选择 TIM 从模式。见 Table 541. 参阅该参数的取值。

Table 634. TIM1_SlaveMode 值  

<table><tr><td>TIM1_SlaveMode</td><td>描述</td></tr><tr><td>TIM1_SlaveModeRESET</td><td>选中触发信号（TRGI）的上升沿重初始化计数器并触发寄存器的更新</td></tr><tr><td>TIM1_SlaveMode_Gated</td><td>当触发信号（TRGI）为高电平计数器时钟使能</td></tr><tr><td>TIM1_SlaveMode_Trigger</td><td>计数器在触发（TRGI）的上升沿开始</td></tr><tr><td>TIM1_SlaveMode_External1</td><td>选中触发（TRGI）的上升沿作为计数器时钟</td></tr></table>

例：  
/\* Selects the Gated Mode as Slave Mode for TIM1 \*/  
TIM1_SelectionMode(TIM1_SlaveMode_Gated);

# 20.2.32 函数TIM1_SelectMasterSlaveMode

Table 635. 描述了函数TIM1_SelectionSlaveMode  
Table 635. 函数 TIM1_SelectMasterSlaveMode  

<table><tr><td>函数名</td><td>TIM1_SelectMasterSlaveMode</td></tr><tr><td>函数原形</td><td>void TIM1_SelectMasterSlaveMode(u16 TIM1_MasterSlaveMode)</td></tr><tr><td>功能描述</td><td>设置或者重置TIM1主/从模式</td></tr><tr><td>输入参数</td><td>TIM1_MasterSlaveMode: 定时器主/从模式
参阅 Section: TIM1_MasterSlaveMode 查阅更多该参数允许取值范围</td></tr><tr><td>输出参数</td><td>无</td></tr><tr><td>返回值</td><td>无</td></tr><tr><td>先决条件</td><td>无</td></tr><tr><td>被调用函数</td><td>无</td></tr></table>

# TIM1_MasterSlaveMode

TIM1_MasterSlaveMode 选择 TIM 主/从模式。见 Table 543. 参阅该参数的取值。

Table 636. TIM1 MasterSlaveMode 值  

<table><tr><td>TIM1_MasterSlaveMode</td><td>描述</td></tr><tr><td>TIM1_MasterSlaveMode_Enable</td><td>TIM1 主/从模式使能</td></tr><tr><td>TIM1_MasterSlaveMode_Disable</td><td>TIM1 主/从模式失能</td></tr></table>

例：  
/* Enables the Master Slave Mode for TIM2 */  
TIM1_SelectMasterSlaveMode(TIM2，TIM1_MasterSlaveMode_Enable);

# 20.2.33 函数TIM1 EncoderInterfaceConfig

Table 637. 描述了函数TIM1 EncoderInterfaceConfig

Table 637. 函数 TIM1 EncoderInterfaceConfig  

<table><tr><td>函数名</td><td>TIM1 EncoderInterfaceConfig</td></tr><tr><td>函数原形</td><td>void TIM1 EncoderInterfaceConfig(u16 TIM1 EncoderMode, u16 TIM1_IC1Polarity, u16 TIM1_IC2Polarity)</td></tr><tr><td>功能描述</td><td>设置TIM1编码界面</td></tr><tr><td>输入参数1</td><td>TIM1 EncoderMode: 触发源
参阅Section: TIM1 EncoderMode 查阅更多该参数允许取值范围</td></tr><tr><td>输入参数2</td><td>TIM1_IC1Polarity: TI1 极性
参阅Section: TIM1_ICPolarity 查阅更多该参数允许取值范围</td></tr><tr><td>输入参数3</td><td>TIM1_IC2Polarity: TI2 极性
参阅Section: TIM1_ICPolarity 查阅更多该参数允许取值范围</td></tr><tr><td>输出参数</td><td>无</td></tr><tr><td>返回值</td><td>无</td></tr><tr><td>先决条件</td><td>无</td></tr><tr><td>被调用函数</td><td>无</td></tr></table>

# TIM1 EncoderMode

TIM1 EncoderMode 选择TIM1编码模式。见Table 526. 参阅该参数的取值。

Table 638. TIM1 EncoderMode 值  

<table><tr><td>TIM1 EncoderMode</td><td>描述</td></tr><tr><td>TIM1 EncoderMode_TI1</td><td>使用TIM1编码模式1</td></tr><tr><td>TIM1 EncoderMode_TI1</td><td>使用TIM1编码模式2</td></tr><tr><td>TIM1 EncoderMode_TI12</td><td>使用TIM1编码模式3</td></tr></table>

例：

```sql
/\*uses of the TIM1 Encoder interface \*/   
TIM1 EncoderInterfaceConfig(TIM1 EncoderMode_1,   
TIM1_ICPolarity_Rising,   
TIM1_ICPolarity_Rising);
```

# 20.2.34 函数TIM1_PrescalerConfig

Table 639. 描述了函数TIM1_PrescalerConfig

Table 639. 函数 TIM1_PrescalerConfig  

<table><tr><td>函数名</td><td>TIM1_PrescalerConfig</td></tr><tr><td>函数原形</td><td>void TIM1_PrescalerConfig(u16 Prescaler, u16 TIM1_PSCReloadMode)</td></tr><tr><td>功能描述</td><td>设置TIM1预分频</td></tr><tr><td>输入参数</td><td>TIM1_PSCReloadMode: 预分频重载模式
参阅Section: TIM1_PSCReloadMode 查阅更多该参数允许取值范围</td></tr><tr><td>输出参数</td><td>无</td></tr><tr><td>返回值</td><td>无</td></tr><tr><td>先决条件</td><td>无</td></tr><tr><td>被调用函数</td><td>无</td></tr></table>

# TIM1_PSCReloadMode

TIM1_PSCReloadMode选择预分频重载模式。见Table 640.参阅该参数的取值。

Table 640. TIM1_PSCReloadMode 值  

<table><tr><td>TIM1_PSCReloadMode</td><td>描述</td></tr><tr><td>TIM1_PSCReloadMode_Update</td><td>TIM1 预分频值在更新事件装入</td></tr><tr><td>TIM1_PSCReloadMode_Immediate</td><td>TIM1 预分频值即时装入</td></tr></table>

例：

```txt
/\* Sets the TIM1 new Prescaler value \*/   
u16 TIM1Prescaler  $=$  0xFF00;   
TIM1_SetPrescaler(TIM1Prescaler，TIM1_PSCReloadMode_Update);
```

# 20.2.35 函数TIM1_ModeConfig

Table 641. 描述了函数TIM1_ModeConfig  
Table 641. 函数 TIM1_ModeConfig  

<table><tr><td>函数名</td><td>TIM1_ModeConfig</td></tr><tr><td>函数原形</td><td>void TIM1_ModeConfig(u16 TIM1_Mode)</td></tr><tr><td>功能描述</td><td>设置TIM1计数器模式</td></tr><tr><td>输入参数</td><td>TIM1_Mode: 待使用的计数器模式
参阅Section: TIM1_Mode 查阅更多该参数允许取值范围</td></tr><tr><td>输出参数</td><td>无</td></tr><tr><td>返回值</td><td>无</td></tr><tr><td>先决条件</td><td>无</td></tr><tr><td>被调用函数</td><td>无</td></tr></table>

例：

```javascript
/\* Selects the Center Aligned counter Mode 1 for the TIM1 \*/TIM1_CounterModeConfig(TIM1_Counter_CenterAligned1);
```

# 20.2.36 函数TIM1_ForceDC1Config

Table 642. 描述了函数TIM1_ForceDC1Config  
Table 642. 函数 TIM1_FocusedOC1Config  

<table><tr><td>函数名</td><td>TIM1_ForcedOC1Config</td></tr><tr><td>函数原形</td><td>void TIM1_ForcedOC1Config(u16 TIM1_ForcedAction)</td></tr><tr><td>功能描述</td><td>置TIM1输出1为活动或者非活动电平</td></tr><tr><td>输入参数</td><td>TIM1_ForcedAction: 输出信号的设置动作
参阅Section: TIM1_ForcedAction 查阅更多该参数允许取值范围</td></tr><tr><td>输出参数</td><td>无</td></tr><tr><td>返回值</td><td>无</td></tr><tr><td>先决条件</td><td>无</td></tr><tr><td>被调用函数</td><td>无</td></tr></table>

# TIM1 ForcedAction

输出信号的设置动作取值见下表。

Table 643. TIM1_ForcedAction 值  

<table><tr><td>TIM1_ForcedAction</td><td>描述</td></tr><tr><td>TIM1_ForcedAction_Active</td><td>置为 OCxREF 上的活动电平</td></tr><tr><td>TIM1_ForcedAction_InActive</td><td>置为 OCxREF 上的非活动电平</td></tr></table>

例：

```javascript
/\*Forces the TIM1 Channel1 Output to the active level \*/TIM1_InvalidConfig(TIM1_InvalidAction_Active);
```

# 20.2.37 函数TIM1_ForceDC2Config

Table 644. 描述了函数TIM1_ForceDC2Config  
Table 644. 函数 TIM1_FocusedOC2Config  

<table><tr><td>函数名</td><td>TIM1_ForcedOC2Config</td></tr><tr><td>函数原形</td><td>void TIM1_ForcedOC2Config(u16 TIM1_ForcedAction)</td></tr><tr><td>功能描述</td><td>置TIM1输出2为活动或者非活动电平</td></tr><tr><td>输入参数</td><td>TIM1_ForcedAction: 输出信号的设置动作
参阅Section: TIM1_ForcedAction 查阅更多该参数允许取值范围</td></tr><tr><td>输出参数</td><td>无</td></tr><tr><td>返回值</td><td>无</td></tr><tr><td>先决条件</td><td>无</td></tr><tr><td>被调用函数</td><td>无</td></tr></table>

例：  
/\*Forces the TIM1 Channel2 Output to the active level \*/TIM1_InvalidConfig(TIM1_InvalidAction_Active);

# 20.2.38 函数TIM1_ForceDC3Config

Table 645. 描述了函数TIM1_ForceDC3Config  
Table 645. 函数 TIM1_FocusedOC3Config  

<table><tr><td>函数名</td><td>TIM1_ForcedOC3Config</td></tr><tr><td>函数原形</td><td>void TIM1_ForcedOC3Config(u16 TIM1_ForcedAction)</td></tr><tr><td>功能描述</td><td>置TIM1输出3为活动或者非活动电平</td></tr><tr><td>输入参数</td><td>TIM1_ForcedAction: 输出信号的设置动作
参阅Section: TIM1_ForcedAction 查阅更多该参数允许取值范围</td></tr><tr><td>输出参数</td><td>无</td></tr><tr><td>返回值</td><td>无</td></tr><tr><td>先决条件</td><td>无</td></tr><tr><td>被调用函数</td><td>无</td></tr></table>

例：  
/* Forces the TIM1 Channel3 Output to the active level */
TIM1 ForcedOC3Config(TIM1_FocusedAction_Active);

# 20.2.39 函数TIM1_ForceDC4Config

Table 646. 描述了函数TIM1_ForceDC4Config  
Table 646. 函数 TIM1_FocusedOC4Config  

<table><tr><td>函数名</td><td>TIM1_ForcedOC4Config</td></tr><tr><td>函数原形</td><td>void TIM1_ForcedOC4Config(u16 TIM1_ForcedAction)</td></tr><tr><td>功能描述</td><td>置TIM1输出4为活动或者非活动电平</td></tr><tr><td>输入参数</td><td>TIM1_ForcedAction: 输出信号的设置动作
参阅Section: TIM1_ForcedAction 查阅更多该参数允许取值范围</td></tr><tr><td>输出参数</td><td>无</td></tr><tr><td>返回值</td><td>无</td></tr><tr><td>先决条件</td><td>无</td></tr><tr><td>被调用函数</td><td>无</td></tr></table>

例：  
/\*Forces the TIM1 Channel4 Output to the active level \*/TIM1 ForcedOC4Config(TIM1_ForcedAction_Active);

# 20.2.40 函数TIM1_ARRPreloadConfig

Table 647. 描述了函数TIM1_ARRPreloadConfig  
Table 647. 函数 TIM1_ARRPreloadConfig  

<table><tr><td>函数名</td><td>TIM1_SelectCOM</td></tr><tr><td>函数原形</td><td>void TIM1_ARRPreloadConfig(FunctionalState Newstate)</td></tr><tr><td>功能描述</td><td>使能或者失能 TIM1 在 ARR 上的预装载寄存器</td></tr><tr><td>输入参数</td><td>NewState: TIM1_CR1 寄存器 ARPE 位的新状态这个参数可以取: ENABLE 或者 DISABLE</td></tr><tr><td>输出参数</td><td>无</td></tr><tr><td>返回值</td><td>无</td></tr><tr><td>先决条件</td><td>无</td></tr><tr><td>被调用函数</td><td>无</td></tr></table>

例：  
/\*Enables the TIM1 Preload on ARR Register \*/TIM1_ARRPreloadConfig(ENABLE);

# 20.2.41 函数TIM1_SelectionCOM

Table 648. 描述了函数TIM1_SelectionCOM  
Table 648. 函数 TIM1_SelectCOM  

<table><tr><td>函数名</td><td>TIM1_SelectionCOM</td></tr><tr><td>函数原形</td><td>void TIM1_SELECTCOM(FunctionalState Newstate)</td></tr><tr><td>功能描述</td><td>选择TIM1外设的通讯事件</td></tr><tr><td>输入参数</td><td>NewState: 通讯事件的新状态
这个参数可以取: ENABLE或者 DISABLE</td></tr><tr><td>输出参数</td><td>无</td></tr><tr><td>返回值</td><td>无</td></tr><tr><td>先决条件</td><td>无</td></tr><tr><td>被调用函数</td><td>无</td></tr></table>

例：  
/\* Selects the TIM1 Commutation event \*/TIM1_SelectCOM(ENABLE);

# 20.2.42 函数TIM1_SelectCCDMA

Table 649. 描述了函数TIM1_SelectionCCDMA  
Table 649. 函数 TIM1_SelectCCDMA  

<table><tr><td>函数名</td><td>TIM1_SelectCCDMA</td></tr><tr><td>函数原形</td><td>void TIM1_SelectCCDMA(FunctionalState Newstate)</td></tr><tr><td>功能描述</td><td>选择TIM1外设的捕获比较DMA源</td></tr><tr><td>输入参数</td><td>NewState: 捕获比较DMA源的新状态
这个参数可以取: ENABLE或者 DISABLE</td></tr><tr><td>输出参数</td><td>无</td></tr><tr><td>返回值</td><td>无</td></tr><tr><td>先决条件</td><td>无</td></tr><tr><td>被调用函数</td><td>无</td></tr></table>

例：  
/\* Selects the TIM1 Capture Compare DMA source \*/TIM1_SelectCCDMA(ENABLE);

# 20.2.43 函数TIM1_CCPreloadControl

Table 650. 描述了函数 TIM1_CCPreloadControl

Table 650. 函数 TIM1_CCPreloadControl  

<table><tr><td>函数名</td><td>TIM1_CCPreloadControl</td></tr><tr><td>函数原形</td><td>void TIM1_CCPreloadControl(FunctionalState Newstate)</td></tr><tr><td>功能描述</td><td>设置或者重置TIM1捕获比较控制位</td></tr><tr><td>输入参数</td><td>NewState: 捕获比较DMA源的新状态
这个参数可以取: ENABLE或者 DISABLE</td></tr><tr><td>输出参数</td><td>无</td></tr><tr><td>返回值</td><td>无</td></tr><tr><td>先决条件</td><td>无</td></tr><tr><td>被调用函数</td><td>无</td></tr></table>

例：
/* Selects the TIM1 Capture Compare Preload Control */
TIM1_CCPreloadControl(ENABLE);

# 20.2.44 函数TIM1_OC1PreloadConfig

Table 651. 描述了函数TIM1_OC1PreloadConfig  
Table 651. 函数 TIM1_OC1PreloadConfig  

<table><tr><td>函数名</td><td>TIM1_OC1PreloadConfig</td></tr><tr><td>函数原形</td><td>void TIM1_OC1PreloadConfig(u16 TIM1_OCPreload)</td></tr><tr><td>功能描述</td><td>使能或者失能 TIM1 在 CCR1 上的预装载寄存器</td></tr><tr><td>输入参数</td><td>TIM1_OCPreload: 输出比较预装载状态
参阅 Section: TIM1_OCPreload 查阅更多该参数允许取值范围</td></tr><tr><td>输出参数</td><td>无</td></tr><tr><td>返回值</td><td>无</td></tr><tr><td>先决条件</td><td>无</td></tr><tr><td>被调用函数</td><td>无</td></tr></table>

# TIM1_OCPreload

输出比较预装载状态可以使能或者失能如下表。

Table 652. TIM1 OCPreload 值  

<table><tr><td>TIM1_OCPreload</td><td>描述</td></tr><tr><td>TIM1_OCPreload_Enable</td><td>TIM1 在 CCR1 上的预装载寄存器使能</td></tr><tr><td>TIM1_OCPreload_Disable</td><td>TIM1 在 CCR1 上的预装载寄存器失能</td></tr></table>

例：

```javascript
/\*Enables the TIM1 Preload on CC1 Register \*/TIM1_OC1PreloadConfig(TIM1_OC1preload_Enable);
```

# 20.2.45 函数TIM1_OC2PreloadConfig

Table 653. 描述了函数TIM1_OC2PreloadConfig

Table 653. 函数 TIM1_OC2PreloadConfig  

<table><tr><td>函数名</td><td>TIM1_OC2PreloadConfig</td></tr><tr><td>函数原形</td><td>void TIM1_OC2PreloadConfig(u16 TIM1_OCPreload)</td></tr><tr><td>功能描述</td><td>使能或者失能 TIM1 在 CCR2 上的预装载寄存器</td></tr><tr><td>输入参数</td><td>TIM1_OCPreload: 输出比较预装载状态
参阅 Section: TIM1_OCPreload 查阅更多该参数允许取值范围</td></tr><tr><td>输出参数</td><td>无</td></tr><tr><td>返回值</td><td>无</td></tr><tr><td>先决条件</td><td>无</td></tr><tr><td>被调用函数</td><td>无</td></tr></table>

例：  
/\*Enables the TIM1 Preload on CC2 Register \*/TIM1_OC2PreloadConfig(TIM1_OCPreload_Enable);

# 20.2.46 函数TIM1_OC3PreloadConfig

Table 654. 描述了函数TIM1_OC3PreloadConfig  
Table 654. 函数 TIM1_OC3PreloadConfig  

<table><tr><td>函数名</td><td>TIM1_OC3PreloadConfig</td></tr><tr><td>函数原形</td><td>void TIM1_OC3PreloadConfig(u16 TIM1_OCPreload)</td></tr><tr><td>功能描述</td><td>使能或者失能 TIM1 在 CCR3 上的预装载寄存器</td></tr><tr><td>输入参数</td><td>TIM1_OCPreload: 输出比较预装载状态
参阅 Section: TIM1_OCPreload 查阅更多该参数允许取值范围</td></tr><tr><td>输出参数</td><td>无</td></tr><tr><td>返回值</td><td>无</td></tr><tr><td>先决条件</td><td>无</td></tr><tr><td>被调用函数</td><td>无</td></tr></table>

例：  
/\*Enables the TIM1 Preload on CC3 Register \*/TIM1_OC3PreloadConfig(TIM1_OCPreload_Enable);

# 20.2.47 函数TIM1_OC4PreloadConfig

Table 655. 描述了函数TIM1_OC4PreloadConfig

Table 655. 函数 TIM1_OC4PreloadConfig  

<table><tr><td>函数名</td><td>TIM1_OC4PreloadConfig</td></tr><tr><td>函数原形</td><td>void TIM1_OC4PreloadConfig(u16 TIM1_OCPreload)</td></tr><tr><td>功能描述</td><td>使能或者失能 TIM1 在 CCR4 上的预装载寄存器</td></tr><tr><td>输入参数</td><td>TIM1_OCPreload: 输出比较预装载状态
参阅 Section: TIM1_OCPreload 查阅更多该参数允许取值范围</td></tr><tr><td>输出参数</td><td>无</td></tr><tr><td>返回值</td><td>无</td></tr><tr><td>先决条件</td><td>无</td></tr><tr><td>被调用函数</td><td>无</td></tr></table>

例：  
/\*Enables the TIM1 Preload on CC4 Register \*/TIM1_OC4PreloadConfig(TIM1_OCPreload_Enable);

# 20.2.48 函数TIM1_OC1FastConfig

Table 656. 描述了函数TIM1_OC1FastConfig  
Table 656. 函数 TIM1_OC1FastConfig  

<table><tr><td>函数名</td><td>TIM1_OC1FastConfig</td></tr><tr><td>函数原形</td><td>void TIM1_OC1FastConfig(u16 TIM1_OCFast)</td></tr><tr><td>功能描述</td><td>设置TIM1捕获比较1快速特征</td></tr><tr><td>输入参数</td><td>TIM1_OCFast: 输出比较快速特征状态
参阅Section: TIM1_OCFast 查阅更多该参数允许取值范围</td></tr><tr><td>输出参数</td><td>无</td></tr><tr><td>返回值</td><td>无</td></tr><tr><td>先决条件</td><td>无</td></tr><tr><td>被调用函数</td><td>无</td></tr></table>

# TIM1_OCFast

输出比较快速特征性能可以使能或者失能如下表。

Table 657. TIM1_OCPreload 值  

<table><tr><td>TIM1_OCFast</td><td>描述</td></tr><tr><td>TIM1_OCFast_Enable</td><td>TIM1 输出比较快速特征性能使能</td></tr><tr><td>TIM1_OCFast_Disable</td><td>TIM1 输出比较快速特征性能失能</td></tr></table>

例：  
/\*Use theTIM1OC1in fast Mode \*/TIM1_OC1FastConfig(TIM1_OCFast_Enable);

# 20.2.49 函数TIM1_OC2FastConfig

Table 658. 描述了函数TIM1_OC2FastConfig

Table 658. 函数 TIM1_OC2FastConfig  

<table><tr><td>函数名</td><td>TIM1_OC2FastConfig</td></tr><tr><td>函数原形</td><td>void TIM1_OC2FastConfig(u16 TIM1_OCFast)</td></tr><tr><td>功能描述</td><td>设置TIM1捕获比较2快速特征</td></tr><tr><td>输入参数</td><td>TIM1_OCFast: 输出比较快速特征状态
参阅Section: TIM1_OCFast 查阅更多该参数允许取值范围</td></tr><tr><td>输出参数</td><td>无</td></tr><tr><td>返回值</td><td>无</td></tr><tr><td>先决条件</td><td>无</td></tr><tr><td>被调用函数</td><td>无</td></tr></table>

例：  
/\*Use the TIM1 OC2 in fast Mode \*/TIM1_OC2FastConfig(TIM1_OCFast_Enable);

# 20.2.50 函数TIM1_OC3FastConfig

Table 659. 描述了函数TIM1_OC3FastConfig  
Table 659. 函数 TIM1_OC3FastConfig  

<table><tr><td>函数名</td><td>TIM1_OC3FastConfig</td></tr><tr><td>函数原形</td><td>void TIM1_OC3FastConfig(u16 TIM1_OCFast)</td></tr><tr><td>功能描述</td><td>设置TIM1捕获比较3快速特征</td></tr><tr><td>输入参数</td><td>TIM1_OCFast: 输出比较快速特征状态
参阅Section: TIM1_OCFast 查阅更多该参数允许取值范围</td></tr><tr><td>输出参数</td><td>无</td></tr><tr><td>返回值</td><td>无</td></tr><tr><td>先决条件</td><td>无</td></tr><tr><td>被调用函数</td><td>无</td></tr></table>

例：  
/\*Use the TIM1 OC3 in fast Mode \*/TIM1_OC3FastConfig(TIM1_OCFast_Enable);

# 20.2.51 函数TIM1_OC4FastConfig

Table 660. 描述了函数TIM1_OC4FastConfig

Table 660. 函数 TIM1_OC4FastConfig  

<table><tr><td>函数名</td><td>TIM1_OC4FastConfig</td></tr><tr><td>函数原形</td><td>void TIM1_OC4FastConfig(u16 TIM1_OCFast)</td></tr><tr><td>功能描述</td><td>设置TIM1捕获比较4快速特征</td></tr><tr><td>输入参数</td><td>TIM1_OCFast: 输出比较快速特征状态
参阅Section: TIM1_OCFast 查阅更多该参数允许取值范围</td></tr><tr><td>输出参数</td><td>无</td></tr><tr><td>返回值</td><td>无</td></tr><tr><td>先决条件</td><td>无</td></tr><tr><td>被调用函数</td><td>无</td></tr></table>

例：  
/\*Use the TIM1 OC4 in fast Mode \*/TIM1_OC4FastConfig(TIM1_OCFast_Enable);

# 20.2.52 函数TIM1_ClearOC1Ref

Table 661. 描述了函数TIM1_ClearOC1Ref  
Table 661. 函数 TIM1_ClearOC1Ref  

<table><tr><td>函数名</td><td>TIM1_ClearOC1Ref</td></tr><tr><td>函数原形</td><td>void TIM1_ClearOC1Ref(u16 TIM1_OCClear)</td></tr><tr><td>功能描述</td><td>在一个外部事件时清除或者保持OCREF1信号</td></tr><tr><td>输入参数</td><td>TIM1_OCClear: 输出比较清除使能位状态
参阅 Section: TIM1_OCClear 查阅更多该参数允许取值范围</td></tr><tr><td>输出参数</td><td>无</td></tr><tr><td>返回值</td><td>无</td></tr><tr><td>先决条件</td><td>无</td></tr><tr><td>被调用函数</td><td>无</td></tr></table>

# TIM1_OCClear

输出比较清除使能位的值列举如下表。

Table 662. TIM1_OCClear 值  

<table><tr><td>TIM1_OCClear</td><td>描述</td></tr><tr><td>TIM1_OCClear_Enable</td><td>TIM1 输出比较清除使能</td></tr><tr><td>TIM1_OCClear_Disable</td><td>TIM1 输出比较清除失能</td></tr></table>

例：  
/\* Enable the TIM1 Channel1 Output Compare Refence clear bit \*/TIM1_ClearOC1Ref(TIM1_OCClear_Enable);

# 20.2.53 函数TIM1_ClearOC2Ref

Table 663. 描述了函数TIM1_ClearOC2Ref  
Table 663. 函数 TIM1_ClearOC2Ref  

<table><tr><td>函数名</td><td>TIM1_ClearOC2Ref</td></tr><tr><td>函数原形</td><td>void TIM1_ClearOC2Ref(u16 TIM1_OCClear)</td></tr><tr><td>功能描述</td><td>在一个外部事件时清除或者保持OCREF2信号</td></tr><tr><td>输入参数</td><td>TIM1_OCClear: 输出比较清除使能位状态
参阅 Section: TIM1_OCClear 查阅更多该参数允许取值范围</td></tr><tr><td>输出参数</td><td>无</td></tr><tr><td>返回值</td><td>无</td></tr><tr><td>先决条件</td><td>无</td></tr><tr><td>被调用函数</td><td>无</td></tr></table>

例：  
/* Enable the TIM1 Channel2 Output Compare Refence clear bit */  
TIM1_ClearOC2Ref(TIM1_OCClear_Enable);

# 20.2.54 函数TIM1_ClearOC3Ref

Table 664. 描述了函数TIM1_ClearOC3Ref  
Table 664. 函数 TIM1_ClearOC3Ref  

<table><tr><td>函数名</td><td>TIM1_ClearOC3Ref</td></tr><tr><td>函数原形</td><td>void TIM1_ClearOC3Ref(u16 TIM1_OCClear)</td></tr><tr><td>功能描述</td><td>在一个外部事件时清除或者保持OCREF3信号</td></tr><tr><td>输入参数</td><td>TIM1_OCClear: 输出比较清除使能位状态
参阅 Section: TIM1_OCClear 查阅更多该参数允许取值范围</td></tr><tr><td>输出参数</td><td>无</td></tr><tr><td>返回值</td><td>无</td></tr><tr><td>先决条件</td><td>无</td></tr><tr><td>被调用函数</td><td>无</td></tr></table>

例：  
/* Enable the TIM1 Channel3 Output Compare Refence clear bit */  
TIM1_ClearOC3Ref(TIM1_OCClear_Enable);

# 20.2.55 函数TIM1_ClearOC4Ref

Table 665. 描述了函数TIM1_ClearOC4Ref

Table 665. 函数 TIM1_ClearOC4Ref  

<table><tr><td>函数名</td><td>TIM1_ClearOC4Ref</td></tr><tr><td>函数原形</td><td>void TIM1_ClearOC4Ref(u16 TIM1_OCClear)</td></tr><tr><td>功能描述</td><td>在一个外部事件时清除或者保持OCREF4信号</td></tr><tr><td>输入参数1</td><td>TIM1: x 可以是2,3或者4,来选择TIM 外设</td></tr><tr><td>输入参数2</td><td>TIM1_OCClear: 输出比较清除使能位状态
参阅 Section: TIM1_OCClear 查阅更多该参数允许取值范围</td></tr><tr><td>输出参数</td><td>无</td></tr><tr><td>返回值</td><td>无</td></tr><tr><td>先决条件</td><td>无</td></tr><tr><td>被调用函数</td><td>无</td></tr></table>

例：

/* Enable the TIM1 Channel4 Output Compare Refence clear bit */  
TIM1_ClearOC4Ref(TIM1_OCClear_Enable);

# 20.2.56 函数TIM1_GenerateEvent

Table 666. 描述了函数TIM1_GenerateEvent

Table 666. 函数 TIM1_GenerateEvent  

<table><tr><td>函数名</td><td>TIM1_GenerateEvent</td></tr><tr><td>函数原形</td><td>void TIM1_GenerateEvent(u16 TIM1_EventSource)</td></tr><tr><td>功能描述</td><td>设置TIM1事件由软件产生</td></tr><tr><td>输入参数</td><td>TIM1_EventSource: TIM软件事件源
参阅Section: TIM1_EventSource 查阅更多该参数允许取值范围</td></tr><tr><td>输出参数</td><td>无</td></tr><tr><td>返回值</td><td>无</td></tr><tr><td>先决条件</td><td>无</td></tr><tr><td>被调用函数</td><td>无</td></tr></table>

# TIM1_EventSource

TIM1_EventSource 选择 TIM 软件事件源。见 Table 667. 参阅该参数的取值。

Table 667. TIM1_EventSource 值  

<table><tr><td>TIM1_EventSource</td><td>描述</td></tr><tr><td>TIM1_EventSource_Update</td><td>TIM 更新事件源</td></tr><tr><td>TIM1_EventSource_CC1</td><td>TIM 捕获比较 1 事件源</td></tr><tr><td>TIM1_EventSource_CC2</td><td>TIM 捕获比较 2 事件源</td></tr><tr><td>TIM1_EventSource_CC3</td><td>TIM 捕获比较 3 事件源</td></tr><tr><td>TIM1_EventSource_CC4</td><td>TIM 捕获比较 4 事件源</td></tr><tr><td>TIM1_EventSource_Trigger</td><td>TIM 触发事件源</td></tr></table>

例：

/* Selects the Trigger software Event generation for TIM1 */

TIM1GenerateEvent(TIM1_EventSource_Trigger);

# 20.2.57 函数TIM1_OC1PolarityConfig

Table 668. 描述了函数TIM1_OC1PolarityConfig

Table 668. 函数 TIM1_OC1PolarityConfig  

<table><tr><td>函数名</td><td>TIM1_OC1PolarityConfig</td></tr><tr><td>函数原形</td><td>void TIM1_OC1PolarityConfig(u16 TIM1_OCPolarity)</td></tr><tr><td>功能描述</td><td>设置TIM1通道1极性</td></tr><tr><td>输入参数</td><td>TIM1_OCPolarity: 输出比较极性
参阅 Section: TIM1_OCPolarity 查阅更多该参数允许取值范围</td></tr><tr><td>输出参数</td><td>无</td></tr><tr><td>返回值</td><td>无</td></tr><tr><td>先决条件</td><td>无</td></tr><tr><td>被调用函数</td><td>无</td></tr></table>

# TIM1_OCPolarity

TIM1_OCPolarity 选择 TIM1 极性（见 Table 699.）

Table 699. TIM1_OCPolarity 值  

<table><tr><td>TIM1_OCPolarity</td><td>描述</td></tr><tr><td>TIM1_OCPolarity_High</td><td>TIM1 输出比较极性高</td></tr><tr><td>TIM1_OCPolarity_Low</td><td>TIM1 输出比较极性低</td></tr></table>

例：

/\* Selects the Polarity high for TIM1 channel 1 output compare \*/TIM1_OC1PolarityConfig(TIM1_OCPolarity_High);

# 20.2.58 函数TIM1_OC1NPolarityConfig

Table 670. 描述了函数TIM1_OC1NPolarityConfig

Table 670. 函数 TIM1_OC1NPolarityConfig  

<table><tr><td>函数名</td><td>TIM1_OC1NPolarityConfig</td></tr><tr><td>函数原形</td><td>void TIM1_OC1NPolarityConfig(u16 TIM1_OCNPolarity)</td></tr><tr><td>功能描述</td><td>设置TIM1通道1N极性</td></tr><tr><td>输入参数</td><td>TIM1_OCNPolarity: 输出比较极性
参阅 Section: TIM1_OCNPolarity 查阅更多该参数允许取值范围</td></tr><tr><td>输出参数</td><td>无</td></tr><tr><td>返回值</td><td>无</td></tr><tr><td>先决条件</td><td>无</td></tr><tr><td>被调用函数</td><td>无</td></tr></table>

例：

/\* Selects the Polarity high for TIM1 channel 1N output compare \*/TIM1_OC1NPolarityConfig(TIM1_OCNPolarity_High);

# 20.2.59 函数TIM1_OC2PolarityConfig

Table 671. 描述了函数TIM1_OC2PolarityConfig

Table 671. 函数 TIM1_OC2PolarityConfig  

<table><tr><td>函数名</td><td>TIM1_OC2PolarityConfig</td></tr><tr><td>函数原形</td><td>void TIM1_OC2PolarityConfig(u16 TIM1_OCPolarity)</td></tr><tr><td>功能描述</td><td>设置TIM1通道2极性</td></tr><tr><td>输入参数</td><td>TIM1_OCPolarity: 输出比较极性
参阅 Section: TIM1_OCPolarity 查阅更多该参数允许取值范围</td></tr><tr><td>输出参数</td><td>无</td></tr><tr><td>返回值</td><td>无</td></tr><tr><td>先决条件</td><td>无</td></tr><tr><td>被调用函数</td><td>无</td></tr></table>

例：  
/\* Selects the Polarity high for TIM1 channel 2 output compare \*/TIM1_OC2PolarityConfig(TIM1_OCPolarity_High);

# 20.2.60 函数TIM1_OC2NPolarityConfig

Table 672. 描述了函数TIM1_OC2PolarityConfig  
Table 672. 函数 TIM1_OC2NPolarityConfig  

<table><tr><td>函数名</td><td>TIM1_OC2NPolarityConfig</td></tr><tr><td>函数原形</td><td>void TIM1_OC2NPolarityConfig(u16 TIM1_OCNPolarity)</td></tr><tr><td>功能描述</td><td>设置TIM1通道2N极性</td></tr><tr><td>输入参数</td><td>TIM1_OCNPolarity: 输出比较极性
参阅 Section: TIM1_OCNPolarity 查阅更多该参数允许取值范围</td></tr><tr><td>输出参数</td><td>无</td></tr><tr><td>返回值</td><td>无</td></tr><tr><td>先决条件</td><td>无</td></tr><tr><td>被调用函数</td><td>无</td></tr></table>

例：  
/\* Selects the Polarity high for TIM1 channel 2N output compare \*/TIM1_OC2NPolarityConfig(TIM1_OCNPolarity_High);

# 20.2.61 函数TIM1_OC3PolarityConfig

Table 673. 描述了函数TIM1_OC3PolarityConfig  
Table 673. 函数 TIM1_OC3PolarityConfig  

<table><tr><td>函数名</td><td>TIM1_OC3PolarityConfig</td></tr><tr><td>函数原形</td><td>void TIM1_OC3PolarityConfig(u16 TIM1_OCPolarity)</td></tr><tr><td>功能描述</td><td>设置TIM1通道3极性</td></tr><tr><td>输入参数</td><td>TIM1_OCPolarity: 输出比较极性
参阅 Section: TIM1_OCPolarity 查阅更多该参数允许取值范围</td></tr><tr><td>输出参数</td><td>无</td></tr><tr><td>返回值</td><td>无</td></tr><tr><td>先决条件</td><td>无</td></tr><tr><td>被调用函数</td><td>无</td></tr></table>

例：  
/\* Selects the Polarity high for TIM1 channel 3 output compare \*/TIM1_OC3PolarityConfig(TIM1_OCPolarity_High);

# 20.2.62 函数TIM1_OC3NPolarityConfig

Table 674. 描述了函数TIM1_OC3PolarityConfig  
Table 674. 函数 TIM1_OC3NPolarityConfig  

<table><tr><td>函数名</td><td>TIM1_OC1NPolarityConfig</td></tr><tr><td>函数原形</td><td>void TIM1_OC3NPolarityConfig(u16 TIM1_OCNPolarity)</td></tr><tr><td>功能描述</td><td>设置TIM1通道3N极性</td></tr><tr><td>输入参数</td><td>TIM1_OCNPolarity: 输出比较极性
参阅 Section: TIM1_OCNPolarity 查阅更多该参数允许取值范围</td></tr><tr><td>输出参数</td><td>无</td></tr><tr><td>返回值</td><td>无</td></tr><tr><td>先决条件</td><td>无</td></tr><tr><td>被调用函数</td><td>无</td></tr></table>

例：  
/\* Selects the Polarity high for TIM1 channel 3N output compare \*/TIM1_OC3NPolarityConfig(TIM1_OCNPolarity_High);

# 20.2.63 函数TIM1_OC4PolarityConfig

Table 675. 描述了函数TIM1_OC4PolarityConfig

Table 675. 函数 TIM1_OC4PolarityConfig  

<table><tr><td>函数名</td><td>TIM1_OC1PolarityConfig</td></tr><tr><td>函数原形</td><td>void TIM1_OC4PolarityConfig(u16 TIM1_OCPolarity)</td></tr><tr><td>功能描述</td><td>设置TIM1通道4极性</td></tr><tr><td>输入参数</td><td>TIM1_OCPolarity: 输出比较极性
参阅 Section: TIM1_OCPolarity 查阅更多该参数允许取值范围</td></tr><tr><td>输出参数</td><td>无</td></tr><tr><td>返回值</td><td>无</td></tr><tr><td>先决条件</td><td>无</td></tr><tr><td>被调用函数</td><td>无</td></tr></table>

例：  
/\* Selects the Polarity high for TIM1 channel 4 output compare \*/TIM1_OC4PolarityConfig(TIM1_OCPolarity_High);

# 20.2.64 函数TIM1_CCxCmd

Table 676. 描述了TIM1_CCxCmd  
Table 676. 函数 TIM1_CCxCmd  

<table><tr><td>函数名</td><td>TIM1_CCxCmd</td></tr><tr><td>函数原形</td><td>void TIM1_CCxCmd(u16 TIM1_Channel, FunctionalState Newstate)</td></tr><tr><td>功能描述</td><td>使能或者失能 TIM1 捕获比较通道 x</td></tr><tr><td>输入参数 1</td><td>TIM1_Channel: TIM1 通道
参阅 Section: TIM1_Channel 查阅更多该参数允许取值范围</td></tr><tr><td>输入参数 2</td><td>NewState: TIM1 通道 CCxE 位的新状态
这个参数可以取: ENABLE 或者 DISABLE</td></tr><tr><td>输出参数</td><td>无</td></tr><tr><td>返回值</td><td>无</td></tr><tr><td>先决条件</td><td>无</td></tr><tr><td>被调用函数</td><td>无</td></tr></table>

例：  
/\*Enables the TIM1 channel 4 \*/TIM1_CCxCmd(TIM1_Channel_4，ENABLE);

# 20.2.65 函数TIM1_CCxCmd

Table 677. 描述了TIM1_CCxCNcmd

Table 677. 函数 TIM1_CCxCmd  

<table><tr><td>函数名</td><td>TIM1_CCxNCmd</td></tr><tr><td>函数原形</td><td>void TIM1_CCxNCmd(u16 TIM1_Channel, FunctionalState Newstate)</td></tr><tr><td>功能描述</td><td>使能或者失能 TIM1 捕获比较通道 xN</td></tr><tr><td>输入参数 1</td><td>TIM1_Channel: TIM1 通道
参阅 Section: TIM1_Channel 查阅更多该参数允许取值范围</td></tr><tr><td>输入参数 2</td><td>NewState: TIM1 通道 CCxNE 位的新状态
这个参数可以取: ENABLE 或者 DISABLE</td></tr><tr><td>输出参数</td><td>无</td></tr><tr><td>返回值</td><td>无</td></tr><tr><td>先决条件</td><td>无</td></tr><tr><td>被调用函数</td><td>无</td></tr></table>

例：
/* Enables the TIM1 channel 3N */
TIM1_CCxNCmd(TIM1_Channel_3, ENABLE);

# 20.2.66 函数TIM1_SelectOCxM

Table 678. 描述了TIM1_SelectionOCxM

Table 678. 函数 TIM1_SelectOCxM  

<table><tr><td>函数名</td><td>TIM1_SelectOCxM</td></tr><tr><td>函数原形</td><td>void TIM1_SelectOCxM(u16 TIM1_Channel, u16 TIM1_OCMode)</td></tr><tr><td>功能描述</td><td>选择TIM1输出比较模式。本函数在改变输出比较模式前失能选中的通道。用户必须使用函数TIM1_CCxCmd和TIM1_CCxCNcmd来使能这个通道。</td></tr><tr><td>输入参数1</td><td>TIM1_Channel: TIM1通道参阅Section: TIM1_Channel查阅更多该参数允许取值范围</td></tr><tr><td>输入参数2</td><td>TIM1_OCMode: TIM1通道CCxNE位的新状态参阅Section: TIM1_OCMode查阅更多该参数允许取值范围</td></tr><tr><td>输出参数</td><td>无</td></tr><tr><td>返回值</td><td>无</td></tr><tr><td>先决条件</td><td>无</td></tr><tr><td>被调用函数</td><td>无</td></tr></table>

# TIM1_OCMode

TIM1_OCMode 选择定时器模式。该参数取值见下表。

Table 679. TIM1_OCMode 定义  

<table><tr><td>TIM1_OCMode</td><td>描述</td></tr><tr><td>TIM1_OCMode_TIM1ing</td><td>TIM1 输出比较时间模式</td></tr><tr><td>TIM1_OCMode_Active</td><td>TIM1 输出比较主动模式</td></tr><tr><td>TIM1_OCMode_Inactive</td><td>TIM1 输出比较非主动模式</td></tr><tr><td>TIM1_OCMode_Toggle</td><td>TIM1 输出比较触发模式</td></tr><tr><td>TIM1_OCMode_PWM1</td><td>TIM1 脉冲宽度调制模式 1</td></tr><tr><td>TIM1_OCMode_PWM2</td><td>TIM1 脉冲宽度调制模式 2</td></tr><tr><td>TIM1_ForcedAction_Active</td><td>置活动电平为 OCxREF</td></tr></table>

```txt
TIM1
```

<table><tr><td>TIM1_ForcedAction_InActive</td><td>置非活动电平为 OCxREF</td></tr></table>

例：

```txt
/\* Selects the TIM1 Channel 1 PWM2 Mode \*/TIM1_SelectOCxM(TIM1_Channel_1，TIM1_OCMode_PWM2);
```

# 20.2.67 函数TIM1_SetCounter

Table 680. 描述了函数TIM1_SetCounter  
Table 680. 函数 TIM1_SetCounter  

<table><tr><td>函数名</td><td>TIM1_SetCounter</td></tr><tr><td>函数原形</td><td>void TIM1_SetCounter(TIM1_TYPEDef* TIM1, u16 Counter)</td></tr><tr><td>功能描述</td><td>设置TIM1计数器寄存器值</td></tr><tr><td>输入参数</td><td>Counter: 计数器寄存器新值</td></tr><tr><td>输出参数</td><td>无</td></tr><tr><td>返回值</td><td>无</td></tr><tr><td>先决条件</td><td>无</td></tr><tr><td>被调用函数</td><td>无</td></tr></table>

例：

```txt
/\* Sets the TIM1 new Counter value \*/ u16 TIM1Counter  $=$  0xFFFF; TIM1_SetCounter(TIM1Counter);
```

# 20.2.68 函数TIM1_SetAutoreload

Table 681. 描述了函数TIM1_SetAutoreload  
Table 681. 函数 TIM1_SetAutoreload  

<table><tr><td>函数名</td><td>TIM1_SetAutoreload</td></tr><tr><td>函数原形</td><td>void TIM1_SetCounter(TIM1_TYPEDef* TIM1, u16 Counter)</td></tr><tr><td>功能描述</td><td>设置 TIM1 自动重装载寄存器值</td></tr><tr><td>输入参数</td><td>Autoreload: 自动重装载寄存器新值</td></tr><tr><td>输出参数</td><td>无</td></tr><tr><td>返回值</td><td>无</td></tr><tr><td>先决条件</td><td>无</td></tr><tr><td>被调用函数</td><td>无</td></tr></table>

例：

```c
/\* Sets the TIM1 new Autoreload value \*/ u16 TIM1Autoreload  $=$  0xFFFF; TIM1_SetAutoreload(TIM1Autoreload);
```

# 20.2.69 函数TIM1_SetCompare1

Table 682. 描述了函数TIM1_SetCompare1  
Table 682. 函数 TIM1_SetCompare1  

<table><tr><td>函数名</td><td>TIM1_SetCompare1</td></tr><tr><td>函数原形</td><td>void TIM1_SetCompare1(TIM1_TYPEDef* TIM1, u16 Compare1)</td></tr><tr><td>功能描述</td><td>设置 TIM1 捕获比较 1 寄存器值</td></tr><tr><td>输入参数</td><td>Compare1: 捕获比较 1 寄存器新值</td></tr><tr><td>输出参数</td><td>无</td></tr><tr><td>返回值</td><td>无</td></tr><tr><td>先决条件</td><td>无</td></tr><tr><td>被调用函数</td><td>无</td></tr></table>

例：

```javascript
/\* Sets the TIM1 new Output Compare 1 value \*/ u16 TIM1Compare1  $= 0x7FFF$  TIM1_SetCompare1(TIM1Compare1);
```

# 20.2.70 函数TIM1_SetCompare2

Table 683. 描述了函数TIM1_SetCompare2  
Table 683. 函数 TIM1_SetCompare2  

<table><tr><td>函数名</td><td>TIM1_SetCompare2</td></tr><tr><td>函数原形</td><td>void TIM1_SetCompare2(TIM1_TYPEDef* TIM1, u16 Compare2)</td></tr><tr><td>功能描述</td><td>设置TIM1捕获比较2寄存器值</td></tr><tr><td>输入参数</td><td>Compare2: 捕获比较2寄存器新值</td></tr><tr><td>输出参数</td><td>无</td></tr><tr><td>返回值</td><td>无</td></tr><tr><td>先决条件</td><td>无</td></tr><tr><td>被调用函数</td><td>无</td></tr></table>

例：

```javascript
/\* Sets the TIM1 new Output Compare 2 value \*/ u16 TIM1Compare2  $= 0\mathrm{x}7\mathrm{FFF}$  TIM1_SetCompare2(TIM1Compare2);
```

# 20.2.71 函数TIM1_SetCompare3

Table 684. 描述了函数TIM1_SetCompare3  
Table 684. 函数 TIM1_SetCompare3  

<table><tr><td>函数名</td><td>TIM1_SetCompare3</td></tr><tr><td>函数原形</td><td>void TIM1_SetCompare3(TIM1_TYPEDef* TIM1, u16 Compare3)</td></tr><tr><td>功能描述</td><td>设置 TIM1 捕获比较 3 寄存器值</td></tr><tr><td>输入参数</td><td>Compare1: 捕获比较 3 寄存器新值</td></tr><tr><td>输出参数</td><td>无</td></tr><tr><td>返回值</td><td>无</td></tr><tr><td>先决条件</td><td>无</td></tr><tr><td>被调用函数</td><td>无</td></tr></table>

例：  
/\* Sets the TIM1 new Output Compare 3 value \*/ u16 TIM1Compare3  $= 0\mathrm{x}7\mathrm{FFF}$  TIM1_SetCompare1(TIM1Compare3);

# 20.2.72 函数TIM1_SetCompare4

Table 685. 描述了函数TIM1_SetCompare4  
Table 685. 函数 TIM1_SetCompare4  

<table><tr><td>函数名</td><td>TIM1_SetCompare4</td></tr><tr><td>函数原形</td><td>void TIM1_SetCompare4(TIM1_TYPEDef* TIM1, u16 Compare4)</td></tr><tr><td>功能描述</td><td>设置TIM1捕获比较4寄存器值</td></tr><tr><td>输入参数</td><td>Compare4: 捕获比较4寄存器新值</td></tr><tr><td>输出参数</td><td>无</td></tr><tr><td>返回值</td><td>无</td></tr><tr><td>先决条件</td><td>无</td></tr><tr><td>被调用函数</td><td>无</td></tr></table>

例：  
/\* Sets the TIM1 new Output Compare 4 value \*/ u16 TIM1Compare4  $= 0\mathrm{x}7\mathrm{FFF}$  TIM1_SetCompare1(TIM1Compare4);

# 20.2.73 函数TIM1_SetIC1Prescaler

Table 686. 描述了函数TIM1_SetIC1Prescaler

Table 686. 函数 TIM1_SetIC1Prescaler  

<table><tr><td>函数名</td><td>TIM1_SetIC1Prescaler</td></tr><tr><td>函数原形</td><td>void TIM1_SetIC1Prescaler(TIM1_TYPEDef* TIM1, u16 TIM1_IC1Prescaler)</td></tr><tr><td>功能描述</td><td>设置 TIM1 输入捕获 1 预分频</td></tr><tr><td>输入参数</td><td>TIM1_IC1Prescaler: 输入捕获 1 预分频
参阅 Section: TIM1_IC1Prescaler 查阅更多该参数允许取值范围</td></tr><tr><td>输出参数</td><td>无</td></tr><tr><td>返回值</td><td>无</td></tr><tr><td>先决条件</td><td>无</td></tr><tr><td>被调用函数</td><td>无</td></tr></table>

# TIM1_ICPrescaler

TIM1_ICPrescaler设置输入捕获预分频器。该参数取值见下表。

Table 687. TIM1_ICPrescaler 值  

<table><tr><td>TIM1_ICPrescaler</td><td>描述</td></tr><tr><td>TIM1_ICPSC_DIV1</td><td>TIM1 捕获在捕获输入上每探测到一个边沿执行一次</td></tr><tr><td>TIM1_ICPSC_DIV2</td><td>TIM1 捕获每 2 个事件执行一次</td></tr><tr><td>TIM1_ICPSC_DIV3</td><td>TIM1 捕获每 3 个事件执行一次</td></tr><tr><td>TIM1_ICPSC_DIV4</td><td>TIM1 捕获每 4 个事件执行一次</td></tr></table>

例：

```javascript
/\* Sets the TIM1 Input Capture 1 Prescaler \*/TIM1_SetIC1Prescaler(TIM1_ICPSC_Div2);
```

# 20.2.74 函数TIM1_SetIC2Prescaler

Table 688. 描述了函数TIM1_SetIC2Prescaler

Table 688. 函数 TIM1_SetIC2Prescaler  

<table><tr><td>函数名</td><td>TIM1_SetIC2Prescaler</td></tr><tr><td>函数原形</td><td>void TIM1_SetIC2Prescaler(TIM1_TYPEDef* TIM1, u16 TIM1_IC2Prescaler)</td></tr><tr><td>功能描述</td><td>设置 TIM1 输入捕获 2 预分频</td></tr><tr><td>输入参数</td><td>TIM1_IC2Prescaler: 输入捕获 2 预分频
参阅 Section: TIM1_IC1Prescaler 查阅更多该参数允许取值范围</td></tr><tr><td>输出参数</td><td>无</td></tr><tr><td>返回值</td><td>无</td></tr><tr><td>先决条件</td><td>无</td></tr><tr><td>被调用函数</td><td>无</td></tr></table>

例：

```javascript
/\* Sets the TIM1 Input Capture 2 Prescaler \*/TIM1_SetIC2Prescaler(TIM1_ICPSC_Div2);
```

# 20.2.75 函数TIM1_SetIC3Prescaler

Table 689. 描述了函数TIM1_SetIC3Prescaler

Table 689. 函数 TIM1_SetIC3Prescaler  

<table><tr><td>函数名</td><td>TIM1_SetIC3Prescaler</td></tr><tr><td>函数原形</td><td>void TIM1_SetIC3Prescaler(TIM1_TYPEDef* TIM1, u16 TIM1_IC3Prescaler)</td></tr><tr><td>功能描述</td><td>设置 TIM1 输入捕获 3 预分频</td></tr><tr><td>输入参数</td><td>TIM1_IC1Prescaler: 输入捕获 3 预分频
参阅 Section: TIM1_IC1Prescaler 查阅更多该参数允许取值范围</td></tr><tr><td>输出参数</td><td>无</td></tr><tr><td>返回值</td><td>无</td></tr><tr><td>先决条件</td><td>无</td></tr><tr><td>被调用函数</td><td>无</td></tr></table>

例：  
/\* Sets the TIM1 Input Capture 3 Prescaler \*/TIM1_SetIC3Prescaler(TIM1_ICPSC_Div2);

# 20.2.76 函数TIM1_SetIC4Prescaler

Table 690. 描述了函数TIM1_SetIC4Prescaler  
Table 690. 函数 TIM1_SetIC4Prescaler  

<table><tr><td>函数名</td><td>TIM1_SetIC4Prescaler</td></tr><tr><td>函数原形</td><td>void TIM1_SetIC1Prescaler(TIM1_TYPEDef* TIM1, u16 TIM1_IC4Prescaler)</td></tr><tr><td>功能描述</td><td>设置 TIM1 输入捕获 4 预分频</td></tr><tr><td>输入参数</td><td>TIM1_IC1Prescaler: 输入捕获 4 预分频
参阅 Section: TIM1_IC1Prescaler 查阅更多该参数允许取值范围</td></tr><tr><td>输出参数</td><td>无</td></tr><tr><td>返回值</td><td>无</td></tr><tr><td>先决条件</td><td>无</td></tr><tr><td>被调用函数</td><td>无</td></tr></table>

例：  
/\* Sets the TIM1 Input Capture 4 Prescaler \*/TIM1_SetIC4Prescaler(TIM1_ICPSC_Div2);

# 20.2.77 函数TIM1_SetClockDivision

Table 691. 描述了函数TIM1_SetClockDivision

Table 691. 函数 TIM1_SetClockDivision  

<table><tr><td>函数名</td><td>TIM1_SetClockDivision</td></tr><tr><td>函数原形</td><td>void TIM1_SetClockDivision(TIM1TypeDef* TIM1, u16 TIM1_CKD)</td></tr><tr><td>功能描述</td><td>设置TIM1的时钟分割值</td></tr><tr><td>输入参数</td><td>TIM1_CKD: 时钟分割值
参阅 Section: TIM1_ClockDivision 查阅更多该参数允许取值范围</td></tr><tr><td>输出参数</td><td>无</td></tr><tr><td>返回值</td><td>无</td></tr><tr><td>先决条件</td><td>无</td></tr><tr><td>被调用函数</td><td>无</td></tr></table>

# TIM1_CKD

TIM1_CKD选择了TIM1的时钟分割。（见Table692.）

Table 692. TIM1_CKD 值  

<table><tr><td>TIM1_CKD</td><td>描述</td></tr><tr><td>TIM1_CKD_DIV1</td><td>TDDS = Tck_TIM1</td></tr><tr><td>TIM1_CKD_DIV2</td><td>TDDS = 2Tck_TIM1</td></tr><tr><td>TIM1_CKD_DIV4</td><td>TDDS = 4Tck_TIM1</td></tr></table>

例：
/* Sets the TIM1_CKD value */
TIM1_SetClockDivision(TIM1_CKD_DIV4);

# 20.2.78 函数TIM1_GetCapture1

Table 693. 描述了函数TIM1_GetCapture1

Table 693. 函数 TIM1_GetCapture1  

<table><tr><td>函数名</td><td>TIM1_GetCapture1</td></tr><tr><td>函数原形</td><td>u16 TIM1_GetCapture1(TIM1_TYPEDef* TIM1)</td></tr><tr><td>功能描述</td><td>获得TIM1输入捕获1的值</td></tr><tr><td>输入参数</td><td>无</td></tr><tr><td>输出参数</td><td>无</td></tr><tr><td>返回值</td><td>输入捕获1的值</td></tr><tr><td>先决条件</td><td>无</td></tr><tr><td>被调用函数</td><td>无</td></tr></table>

例：
/* Gets the Input Capture 1 value of the TIM1 */
u16 IC1value = TIM1_GetCapture1();

# 20.2.79 函数TIM1_GetCapture2

Table 694. 描述了函数TIM1_GetCapture2  
Table 694. 函数 TIM1_GetCapture2  

<table><tr><td>函数名</td><td>TIM1_GetCapture2</td></tr><tr><td>函数原形</td><td>u16 TIM1_GetCapture2(TIM1TypeDef* TIM1)</td></tr><tr><td>功能描述</td><td>获得TIM1输入捕获2的值</td></tr><tr><td>输入参数</td><td>无</td></tr><tr><td>输出参数</td><td>无</td></tr><tr><td>返回值</td><td>输入捕获2的值</td></tr><tr><td>先决条件</td><td>无</td></tr><tr><td>被调用函数</td><td>无</td></tr></table>

例：  
/* Gets the Input Capture 2 value of the TIM1 */  
u16 IC2value = TIM1_GetCapture2();

# 20.2.80 函数TIM1_GetCapture3

Table 695. 描述了函数TIM1_GetCaptur3  
Table 695. 函数 TIM1_GetCapture3  

<table><tr><td>函数名</td><td>TIM1_GetCapture3</td></tr><tr><td>函数原形</td><td>u16 TIM1_GetCapture3(TIM1TypeDef* TIM1)</td></tr><tr><td>功能描述</td><td>获得TIM1输入捕获3的值</td></tr><tr><td>输入参数</td><td>无</td></tr><tr><td>输出参数</td><td>无</td></tr><tr><td>返回值</td><td>输入捕获3的值</td></tr><tr><td>先决条件</td><td>无</td></tr><tr><td>被调用函数</td><td>无</td></tr></table>

例：  
/\* Gets the Input Capture 3 value of the TIM1 \*/  
u16 IC3value = TIM1_GetCapture3();

# 20.2.81 函数TIM1_GetCapture4

Table 696. 描述了函数TIM1_GetCapture4  
Table 696. 函数 TIM1_GetCapture4  

<table><tr><td>函数名</td><td>TIM1_GetCapture4</td></tr><tr><td>函数原形</td><td>u16 TIM1_GetCapture4(TIM1_TYPEDef* TIM1)</td></tr><tr><td>功能描述</td><td>获得TIM1输入捕获4的值</td></tr><tr><td>输入参数</td><td>无</td></tr><tr><td>输出参数</td><td>无</td></tr><tr><td>返回值</td><td>输入捕获4的值</td></tr><tr><td>先决条件</td><td>无</td></tr><tr><td>被调用函数</td><td>无</td></tr></table>

例：  
/\* Gets the Input Capture 4 value of the TIM1 \*/  
ul6 IC4value = TIM1_GetIC4();

# 20.2.82 函数TIM1_GetCounter

Table 697. 描述了函数TIM1_GetCounter

Table 697. 函数 TIM1_GetCounter  

<table><tr><td>函数名</td><td>TIM1_GetCounter</td></tr><tr><td>函数原形</td><td>u16 TIM1_GetCounter(TIM1_TYPEDef* TIM1)</td></tr><tr><td>功能描述</td><td>获得TIM1计数器的值</td></tr><tr><td>输入参数</td><td>无</td></tr><tr><td>输出参数</td><td>无</td></tr><tr><td>返回值</td><td>计数器的值</td></tr><tr><td>先决条件</td><td>无</td></tr><tr><td>被调用函数</td><td>无</td></tr></table>

例：
/* Gets TIM1 counter value */
u16 TIM1Counter = TIM1_GetCounter();

# 20.2.83 函数TIM1_GetPrescaler

Table 698. 描述了函数TIM1_GetPrescaler

Table 698. 函数 TIM1_GetPrescaler  

<table><tr><td>函数名</td><td>TIM1_GetPrescaler</td></tr><tr><td>函数原形</td><td>u16 TIM1_GetPrescaler (TIM1TypeDef* TIM1)</td></tr><tr><td>功能描述</td><td>获得TIM1预分频值</td></tr><tr><td>输入参数</td><td>无</td></tr><tr><td>输出参数</td><td>无</td></tr><tr><td>返回值</td><td>预分频的值</td></tr><tr><td>先决条件</td><td>无</td></tr><tr><td>被调用函数</td><td>无</td></tr></table>

例：
/* Gets TIM1 prescaler value */
u16 TIM1Prescaler = TIM1_GetPrescaler();

# 20.2.84 函数TIM1_GetFlagStatus

Table 699. 描述了函数TIM1_GetFlagStatus

Table 699. 函数 TIM1_GetFlagStatus  

<table><tr><td>函数名</td><td>TIM1_GetFlagStatus</td></tr><tr><td>函数原形</td><td>FlagStatus TIM1_GetFlagStatus(TIM1_TYPEDef* TIM1, u16 TIM1_FLAG)</td></tr><tr><td>功能描述</td><td>检查指定的 TIM 标志位设置与否</td></tr><tr><td>输入参数</td><td>TIM1_FLAG: 待检查的 TIM 标志位
参阅 Section: TIM1_FLAG 查阅更多该参数允许取值范围</td></tr><tr><td>输出参数</td><td>无</td></tr><tr><td>返回值</td><td>TIM1_FLAG 的新状态 (SET 或者 RESET)</td></tr><tr><td>先决条件</td><td>无</td></tr><tr><td>被调用函数</td><td>无</td></tr></table>

# TIM1_FLAG

Table 700. 给出了所有可以被函数TIM1_GetFlagStatus检查的标志位列表

Table 700. TIM1_FLAG 值  

<table><tr><td>TIM1_FLAG</td><td>描述</td></tr><tr><td>TIM1_FLAG_Update</td><td>TIM1 更新标志位</td></tr><tr><td>TIM1_FLAG_CC1</td><td>TIM1 捕获/比较 1 标志位</td></tr><tr><td>TIM1_FLAG_CC2</td><td>TIM1 捕获/比较 2 标志位</td></tr><tr><td>TIM1_FLAG_CC3</td><td>TIM1 捕获/比较 3 标志位</td></tr><tr><td>TIM1_FLAG_CC4</td><td>TIM1 捕获/比较 4 标志位</td></tr><tr><td>TIM1_FLAG_COM</td><td>TIM1 COM 标志位</td></tr><tr><td>TIM1_FLAG_Trigger</td><td>TIM1 触发标志位</td></tr><tr><td>TIM1_FLAG_BRK</td><td>TIM1 刹车标志位</td></tr><tr><td>TIM1_FLAG_CC1OF</td><td>TIM1 捕获/比较 1 溢出标志位</td></tr><tr><td>TIM1_FLAG_CC2OF</td><td>TIM1 捕获/比较 2 溢出标志位</td></tr><tr><td>TIM1_FLAG_CC3OF</td><td>TIM1 捕获/比较 3 溢出标志位</td></tr><tr><td>TIM1_FLAG_CC4OF</td><td>TIM1 捕获/比较 4 溢出标志位</td></tr></table>

例：

```txt
/\* Check if the TIM1 Capture Compare 1 flag is set or reset \*/ if(TIM1_GetFlagStatus(TIM1_FLAG_CC1)  $= =$  SET) {
```

# 20.2.85 函数TIM1_ClearFlag

Table 701. 描述了函数TIM1_ClearFlag

Table 701. 函数 TIM1_ClearFlag  

<table><tr><td>函数名</td><td>TIM1_ClearFlag</td></tr><tr><td>函数原形</td><td>void TIM1_ClearFlag(TIM1_TYPEDef* TIM1, u32 TIM1_FLAG)</td></tr><tr><td>功能描述</td><td>清除TIM1的待处理标志位</td></tr><tr><td>输入参数</td><td>TIM1_FLAG: 待清除的TIM标志位
参阅Section: TIM1_FLAG 查阅更多该参数允许取值范围</td></tr><tr><td>输出参数</td><td>无</td></tr><tr><td>返回值</td><td>无</td></tr><tr><td>先决条件</td><td>无</td></tr><tr><td>被调用函数</td><td>无</td></tr></table>

例：
/* Clear the TIM1 Capture Compare 1 flag */
TIM1_ClearFlag(TIM1_FLAG_CC1);

# 20.2.86 函数TIM1_GetITStatus

Table 702. 描述了函数TIM1_GetITStatus  
Table 702. 函数 TIM1_GetITStatus  

<table><tr><td>函数名</td><td>TIM1_GetITStatus</td></tr><tr><td>函数原形</td><td>ITStatus TIM1_GetITStatus(TIM1_TYPEDef* TIM1, u16 TIM1_IT)</td></tr><tr><td>功能描述</td><td>检查指定的 TIM 中断发生与否</td></tr><tr><td>输入参数</td><td>TIM1_IT: 待检查的 TIM 中断源
参阅 Section: TIM1_IT 查阅更多该参数允许取值范围</td></tr><tr><td>输出参数</td><td>无</td></tr><tr><td>返回值</td><td>TIM1_IT 的新状态</td></tr><tr><td>先决条件</td><td>无</td></tr><tr><td>被调用函数</td><td>无</td></tr></table>

例：  
/*Check if the TIM1 Capture Compare 1 interrupt has occured or not*/  
if(TIM1_GetITStatus(TIM1_IT_CC1) == SET)  
{

# 20.2.87 函数TIM1_ClearITPendingBit

Table 703. 描述了函数TIM1_ClearITPendingBit  
Table 703. 函数 TIM1_ClearITPendingBit  

<table><tr><td>函数名</td><td>TIM1_ClearITPendingBit</td></tr><tr><td>函数原形</td><td>void TIM1_ClearITPendingBit(TIM1TypeDef* TIM1, u16 TIM1_IT)</td></tr><tr><td>功能描述</td><td>清除TIM1的中断待处理位</td></tr><tr><td>输入参数</td><td>TIM1_IT: 待检查的TIM中断待处理位
参阅Section: TIM1_IT 查阅更多该参数允许取值范围</td></tr><tr><td>输出参数</td><td>无</td></tr><tr><td>返回值</td><td>无</td></tr><tr><td>先决条件</td><td>无</td></tr><tr><td>被调用函数</td><td>无</td></tr></table>

例：  
/* Clear the TIM1 Capture Compare 1 interrupt pending bit */
TIM1_ClearITPendingBit(TIM1_IT_CC1);

# 21 通用同步异步收发器（USART）

通用同步异步收发器（USART）提供了一种灵活的方法来与使用工业标准NRZ异步串行数据格式的外部设备之间进行全双工数据交换。USART利用分数波特率发生器提供宽范围的波特率选择。它支持同步单向通信和半双工单线通信。它也支持LIN(局部互连网)，智能卡协议和IrDA(红外数据组织)SIRENDEC规范，以及调制解调器(CTS/RTS)操作。它还允许多处理器通信。使用多缓冲器配置的DMA方式，可以实现高速数据通信。

Section 21.1USART寄存器结构描述了固件函数库所使用的数据结构，Section 21.2固件库函数介绍了函数库里的所有函数。

# 21.1USART寄存器结构

USART 寄存器结构，USART_TypeDeff，在文件“stm32f10x_map.h”中定义如下：

```c
typedef struct  
{  
vu16 SR;  
u16 RESERVED1;  
vu16 DR;  
u16 RESERVED2;  
vu16 BRR;  
u16 RESERVED3;  
vu16 CR1;  
u16 RESERVED4;  
vu16 CR2;  
u16 RESERVED5;  
vu16 CR3;  
u16 RESERVED6;  
vu16 GTPR;  
u16 RESERVED7;  
}USART_TYPEDef;
```

Table 704.例举了USART所有寄存器

Table 704.USART 寄存器  

<table><tr><td>寄存器</td><td>描述</td></tr><tr><td>SR</td><td>USART 状态寄存器</td></tr><tr><td>DR</td><td>USART 数据寄存器</td></tr><tr><td>BRR</td><td>USART 波特率寄存器</td></tr><tr><td>CR1</td><td>USART 控制寄存器 1</td></tr><tr><td>CR2</td><td>USART 控制寄存器 2</td></tr><tr><td>CR3</td><td>USART 控制寄存器 3</td></tr><tr><td>GTPR</td><td>USART 保护时间和预分频寄存器</td></tr></table>

3个USART外设声明于文件“stm32f10x_map.h”：

```c
define PERIPH_BASE ((u32)0x40000000)   
#define APB1PERIPH_BASE PERIPH_BASE   
#define APB2PERIPH_BASE (PERIPH_BASE + 0x10000)   
#define AHBPERIPH_BASE (PERIPH_BASE + 0x20000)   
#defineUSART1_BASE (APB2PERIPH_BASE + 0x3800)   
#defineUSART2_BASE (APB1PERIPH_BASE + 0x4400)   
#defineUSART3_BASE (APB1PERIPH_BASE + 0x4800)   
#ifndef DEBUG   
#ifdef_USART1   
#define_USART1 ((USART_TYPEDef*)USART1_BASE)
```

# ST

译文英文原版为UM0427 Oct. 2007 Rev 2, 译文仅供参考，与英文版冲突的，以英文版为准

USART  
```c
endif /*USART1 */
ifdef_USART2
define_USART2 ((USARTTypeDef *)USART2_BASE)
endif /*_USART2 */
ifdef_USART3
#define_USART3 ((USARTTypeDef *)USART3_BASE)
endif /*_USART3 */
...
else /* DEBUG */
...
ifdef_USART1
EXT_USARTTypeDef *USART1;
endif /*_USART1 */
ifdef_USART2
EXT_USARTTypeDef *USART2;
endif /*_USART2 */
ifdef_USART3
EXT_USARTTypeDef *USART3;
endif /*_USART3 */
...
endif
```

使用Debug模式时，初始化指针USART1,USART2和USART3于文件“stm32f10x_lib.c”：

```c
...  
#ifdef _USART1  
USART1 = (USARTTypeDef *) USART1_BASE;  
#endif /*_USART1 */  
#ifdef _USART2  
USART2 = (USARTTypeDef *) USART2_BASE;  
#endif /*_USART2 */  
#ifdef _USART3  
USART3 = (USARTTypeDef *) USART3_BASE;  
#endif /*_USART3 */
```

为了访问USART寄存器，,__USART,__USART1,__USART2和__USART3必须在文件“stm32f10x_conf.h”中定义如下：

```m4
define _USART
#define _USART1
#define _USART2
#define _USART3
```

# 21.2USART库函数

Table 705. 例举了USART的库函数  
Table 705.USART库函数  

<table><tr><td>函数名</td><td>描述</td></tr><tr><td>USART_DeInit</td><td>将外设USARTx寄存器重设为缺省值</td></tr><tr><td>USART_Init</td><td>根据USART_InitStruct中指定的参数初始化外设USARTx寄存器</td></tr><tr><td>USARTSTRUCTInit</td><td>把USART_InitStruct中的每一个参数按缺省值填入</td></tr><tr><td>USART_Cmd</td><td>使能或者失能USART外设</td></tr><tr><td>USART_ITConfig</td><td>使能或者失能指定的USART中断</td></tr><tr><td>USART_DMAcmd</td><td>使能或者失能指定USART的DMA请求</td></tr><tr><td>USART_SetAddress</td><td>设置USART节点的地址</td></tr><tr><td>USART_WakeUpConfig</td><td>选择USART的唤醒方式</td></tr><tr><td>USART_ReceiverWakeUpCmd</td><td>检查USART是否处于静默模式</td></tr><tr><td>USART_LINBreakDetectLengthConfig</td><td>设置USARTLIN中断检测长度</td></tr><tr><td>USART_LINCmd</td><td>使能或者失能USARTx的LIN模式</td></tr><tr><td>USART_S新闻发布</td><td>通过外设USARTx发送单个数据</td></tr></table>

USART  

<table><tr><td>USART_ReceiveData</td><td>返回USARTx最近接收到的数据</td></tr><tr><td>USART_SendlBreak</td><td>发送中断字</td></tr><tr><td>USART_SetGuardTime</td><td>设置指定的USART保护时间</td></tr><tr><td>USART_SetPrescaler</td><td>设置USART时钟预分频</td></tr><tr><td>USART_SmartCardCmd</td><td>使能或者失能指定USART的智能卡模式</td></tr><tr><td>USART_SmartCardNackCmd</td><td>使能或者失能NACK传输</td></tr><tr><td>USART_HalfDuplexCmd</td><td>使能或者失能USART半双工模式</td></tr><tr><td>USART_IrDAConfig</td><td>设置USART IrDA模式</td></tr><tr><td>USART_IrDACmd</td><td>使能或者失能USART IrDA模式</td></tr><tr><td>USART_GetFlagStatus</td><td>检查指定的USART标志位设置与否</td></tr><tr><td>USART_ClearFlag</td><td>清除USARTx的待处理标志位</td></tr><tr><td>USART_GetITStatus</td><td>检查指定的USART中断发生与否</td></tr><tr><td>USART_ClearITPendingBit</td><td>清除USARTx的中断待处理位</td></tr></table>

# 21.2.1 函数USART_DeInit

Table 706. 描述了函数USART_DeInit  
Table 706. 函数USART_DeInit  

<table><tr><td>函数名</td><td>USART_DeInit</td></tr><tr><td>函数原形</td><td>void USART_DeInit(USART_TYPEDef* USARTx)</td></tr><tr><td>功能描述</td><td>将外设USARTx寄存器重设为缺省值</td></tr><tr><td>输入参数</td><td>USARTx: x可以是1,2或者3,来选择USART外设</td></tr><tr><td>输出参数</td><td>无</td></tr><tr><td>返回值</td><td>无</td></tr><tr><td>先决条件</td><td>无</td></tr><tr><td>被调用函数</td><td>RCC_APB2PeriphResetCmd()
RCC_APB1PeriphResetCmd()</td></tr></table>

例：

/* Resets the USART1 registers to their default reset value */ USART_DeInit(USART1);

# 21.2.2 函数USART_Init

Table 707. 描述了函数USART_Init

Table 707. 函数USART_Init  

<table><tr><td>函数名</td><td>USART_Init</td></tr><tr><td>函数原形</td><td>void USART_Init(USARTTypeDef* USARTx, USART_InitTypeDef* USART_InitStruct)</td></tr><tr><td>功能描述</td><td>根据USART_InitStruct中指定的参数初始化外设USARTx寄存器</td></tr><tr><td>输入参数1</td><td>USARTx: x可以是1,2或者3,来选择USART外设</td></tr><tr><td>输入参数2</td><td>USART_InitStruct: 指向结构USART_InitTypeDef的指针,包含了外设USART的配置信息。参阅Section: USART_InitTypeDef查阅更多该参数允许取值范围</td></tr><tr><td>输出参数</td><td>无</td></tr><tr><td>返回值</td><td>无</td></tr><tr><td>先决条件</td><td>无</td></tr><tr><td>被调用函数</td><td>无</td></tr></table>

# USART_InitTypeDef structure

USART_InitTypeDef 定义于文件“stm32f10x_usart.h”：

```c
typedef struct   
{   
u32USART_BaudRate;   
u16USARTWordLength;   
u16USART_StopBits;   
u16USART_Parity;   
u16USART_HardwareFlowControl;   
u16USART_Mode;   
u16USART_Clock;   
u16USART_CPOL;   
u16USART_CPHA;   
u16USART_LastBit;   
}USART_InitTypeDef;
```

Table 708. 描述了结构USART_InitTypeDef在同步和异步模式下使用的不同成员。

Table 708.USART_InitTypeDef 成员USART 模式对比  

<table><tr><td>成员</td><td>异步模式</td><td>同步模式</td></tr><tr><td>USART_BaudRate</td><td>X</td><td>X</td></tr><tr><td>USARTWordLength</td><td>X</td><td>X</td></tr><tr><td>USART_StopBits</td><td>X</td><td>X</td></tr><tr><td>USART_Parity</td><td>X</td><td>X</td></tr><tr><td>USART_HardwareFlowControl</td><td>X</td><td>X</td></tr><tr><td>USART_Mode</td><td>X</td><td>X</td></tr><tr><td>USART_Clock</td><td></td><td>X</td></tr><tr><td>USART_CPOL</td><td></td><td>X</td></tr><tr><td>USART_CPHA</td><td></td><td>X</td></tr><tr><td>USART_LastBit</td><td></td><td>X</td></tr></table>

# USART_BaudRate

该成员设置了USART传输的波特率，波特率可以由以下公式计算：

IntegerDivider = ((APBClock) / (16 * (USART_InitStruct->USART_BaudRate)))

FractionalDivider = ((IntegerDivider - ((u32 IntegerDivider)) * 16) + 0.5

# USARTWordLength

USARTWordLength 提示了在一个帧中传输或者接收到的数据位数。Table 709. 给出了该参数可取的值。

Table 709.USART WORDLength 定义  

<table><tr><td>USARTWordLength</td><td>描述</td></tr><tr><td>USARTWordLength_8b</td><td>8位数据</td></tr><tr><td>USARTWordLength_9b</td><td>9位数据</td></tr></table>

# USART_StopBits

USART_StopBits 定义了发送的停止位数目。Table 710. 给出了该参数可取的值。

Table 710.USART_StopBits 定义  

<table><tr><td>USART_StopBits</td><td>描述</td></tr><tr><td>USART_StopBits_1</td><td>在帧结尾传输 1 个停止位</td></tr><tr><td>USART_StopBits_0.5</td><td>在帧结尾传输 0.5 个停止位</td></tr><tr><td>USART_StopBits_2</td><td>在帧结尾传输 2 个停止位</td></tr><tr><td>USART_StopBits_1.5</td><td>在帧结尾传输 1.5 个停止位</td></tr></table>

# USART_Parity

USART_Parity 定义了奇偶模式。Table 711. 给出了该参数可取的值。

Table 711.USART_Parity 定义  

<table><tr><td>USART_Parity</td><td>描述</td></tr><tr><td>USART_Parity_No</td><td>奇偶失能</td></tr><tr><td>USART_Parity_Even</td><td>偶模式</td></tr><tr><td>USART_Parity_Odd</td><td>奇模式</td></tr></table>

注意：奇偶校验一旦使能，在发送数据的MSB位插入经计算的奇偶位（字长9位时的第9位，字长8位时的第8位）。

# USART_HardwareFlowControl

USART_HardwareFlowControl指定了硬件流控制模式使能还是失能。Table712.给出了该参数可取的值。

Table 712.USART_HardwareFlowControl 定义  

<table><tr><td>USART_HardwareFlowControl</td><td>描述</td></tr><tr><td>USART_HardwareFlowControl_None</td><td>硬件流控制失能</td></tr><tr><td>USART_HardwareFlowControl_RTS</td><td>发送请求RTS使能</td></tr><tr><td>USART_HardwareFlowControl_CTS</td><td>清除发送CTS使能</td></tr><tr><td>USART_HardwareFlowControl_RTS_CTS</td><td>RTS和CTS使能</td></tr></table>

# USART_Mode

USART_Mode 指定了使能或者失能发送和接收模式。Table 713. 给出了该参数可取的值。

Table 713.USART_Mode 定义  

<table><tr><td>USART_Mode</td><td>描述</td></tr><tr><td>USART_Mode_Tx</td><td>发送使能</td></tr><tr><td>USART_Mode_Rx</td><td>接收使能</td></tr></table>

# USART CLOCK

USART_CLOCK 提示了USART时钟使能还是失能。Table 714. 给出了该参数可取的值。

Table 714.USART_CLOCK定义  

<table><tr><td>USART_CLOCK</td><td>描述</td></tr><tr><td>USART_Clock_Enable</td><td>时钟高电平活动</td></tr><tr><td>USART_Clock_Disable</td><td>时钟低电平活动</td></tr></table>

# USART_CPOL

USART_CPOL指定了下SLCK引脚上时钟输出的极性。Table715.给出了该参数可取的值。

Table 715.USART_CPOL定义  

<table><tr><td>USART_CPOL</td><td>描述</td></tr><tr><td>USART_CPOL_High</td><td>时钟高电平</td></tr><tr><td>USART_CPOL_Low</td><td>时钟低电平</td></tr></table>

# USART CPHA

USART_CPHA 指定了下 SLCK 引脚上时钟输出的相位，和 CPOL 位一起配合来产生用户希望的时钟/数据的采样关系。Table 716. 给出了该参数可取的值。

Table 716.USART CPHA定义  

<table><tr><td>USART_CPHA</td><td>描述</td></tr><tr><td>USART_CPHA_1Edge</td><td>时钟第一个边沿进行数据捕获</td></tr><tr><td>USART_CPHA_2Edge</td><td>时钟第二个边沿进行数据捕获</td></tr></table>

# USART_LastBit

USART_LastBit 来控制是否在同步模式下，在 SCLK 引脚上输出最后发送的那个数据字 (MSB) 对应的时钟脉冲。Table 717. 给出了该参数可取的值。

Table 717.USART_LastBit 定义  

<table><tr><td>USART_LastBit</td><td>描述</td></tr><tr><td>USART_LastBit_Disable</td><td>最后一位数据的时钟脉冲不从SCLK输出</td></tr><tr><td>USART_LastBit_Enable</td><td>最后一位数据的时钟脉冲从SCLK输出</td></tr></table>

例：

```txt
/\* The following example illustrates how to configure theUSART1 \*/   
USART_InitTypeDef USART_InitStructure;   
USART_InitStructure.USART_BaudRate  $= 9600$  .   
USART_InitStructure.USARTWordLength  $=$  USART WORDLength_8b;   
USART_InitStructure.USART_StopBits  $=$  USART_StopBits_1;   
USART_InitStructure.USART_Parity  $=$  USART_Parity_Odd;   
USART_InitStructure.USART_HardwareFlowControl  $=$    
USART_HardwareFlowControl_RTS_CTS;   
USART_InitStructure.USART_Mode  $=$  USART_Mode_Tx | USART_Mode_Rx;   
USART_InitStructure.USART_Clock  $=$  USART_Clock_Disable;   
USART_InitStructure.USART_CPOL  $=$  USART_CPOL_High;   
USART_InitStructure.USART_CPHA  $=$  USART_CPHA_1Edge;   
USART_InitStructure.USART_LastBit  $=$  USART_LastBit_Enable;   
USART_Init(USART1，&USART_InitStructure);
```

# 21.2.3 函数USARTSTRUCTInit

Table 718. 描述了函数USARTSTRUCTInit

Table 718. 函数USARTSTRUCTInit  

<table><tr><td>函数名</td><td>USART_StractInit</td></tr><tr><td>函数原形</td><td>void USART_StractInit(USART_InitTypeDef* USART_InitStruct)</td></tr><tr><td>功能描述</td><td>把USART_InitStruct中的每一个参数按缺省值填入</td></tr><tr><td>输入参数</td><td>USART_InitStruct: 指向结构USART_InitTypeDef的指针, 待初始化</td></tr><tr><td>输出参数</td><td>无</td></tr><tr><td>返回值</td><td>无</td></tr><tr><td>先决条件</td><td>无</td></tr><tr><td>被调用函数</td><td>无</td></tr></table>

Table 719. 给出了USART_InitStruct各个成员的缺省值  
Table 719.USART_InitStruct缺省值  

<table><tr><td>成员</td><td>缺省值</td></tr><tr><td>USART_BaudRate</td><td>9600</td></tr><tr><td>USARTWordLength</td><td>USARTWordLength_8b</td></tr><tr><td>USART_StopBits</td><td>USART_StopBits_1</td></tr><tr><td>USART_Parity</td><td>USART_Parity_No</td></tr><tr><td>USART_HardwareFlowControl</td><td>USART_HardwareFlowControl_None</td></tr><tr><td>USART_Mode</td><td>USART_Mode_Rx | USART_Mode_Tx</td></tr><tr><td>USART_Clock</td><td>USART_Clock_Disable</td></tr><tr><td>USART_CPOL</td><td>USART_CPOL_Low</td></tr><tr><td>USART_CPHA</td><td>USART_CPHA_1Edge</td></tr><tr><td>USART_LastBit</td><td>USART_LastBit_Disable</td></tr></table>

例：

```txt
/\* The following example illustrates how to initialize aUSART_InitTypeDef structure \*/   
USART_InitTypeDef USART_InitStructure;   
USARTSTRUCTInit(&USART_InitStructure);
```

# 21.2.4 函数USART_Cmd

Table 720. 描述了函数USART_Cmd  
Table 720. 函数USART_Cmd  

<table><tr><td>函数名</td><td>USART_Cmd</td></tr><tr><td>函数原形</td><td>void USART_Cmd(USART_TYPEDef* USARTx, FunctionalState NewState)</td></tr><tr><td>功能描述</td><td>使能或者失能USART外设</td></tr><tr><td>输入参数1</td><td>USARTx: x可以是1,2或者3,来选择USART外设</td></tr><tr><td>输入参数2</td><td>NewState: 外设USARTx的新状态
这个参数可以取: ENABLE或者DISABLE</td></tr><tr><td>输出参数</td><td>无</td></tr><tr><td>返回值</td><td>无</td></tr><tr><td>先决条件</td><td>无</td></tr><tr><td>被调用函数</td><td>无</td></tr></table>

例：

```javascript
/\*Enable theUSART1\*/USART_Cmd(USART1，ENABLE);
```

# 21.2.5 函数USART_ITConfig

Table 721. 描述了函数USART_ITConfig  
Table 721. 函数USART_ITConfig  

<table><tr><td>函数名</td><td>USART_ITConfig</td></tr><tr><td>函数原形</td><td>void USART_ITConfig(USART_TYPEDef* USARTx, u16 USART_IT, FunctionalState NewState)</td></tr><tr><td>功能描述</td><td>使能或者失能指定的USART中断</td></tr><tr><td>输入参数1</td><td>USARTx: x可以是1,2或者3,来选择USART外设</td></tr><tr><td>输入参数2</td><td>USART_IT: 待使能或者失能的USART中断源
参阅 Section: USART_IT 查阅更多该参数允许取值范围</td></tr><tr><td>输入参数3</td><td>NewState: USARTx中断的新状态
这个参数可以取: ENABLE或者 DISABLE</td></tr><tr><td>输出参数</td><td>无</td></tr><tr><td>返回值</td><td>无</td></tr><tr><td>先决条件</td><td>无</td></tr><tr><td>被调用函数</td><td>无</td></tr></table>

# USART IT

输入参数USART_IT使能或者失能USART的中断。可以取下表的一个或者多个取值的组合作为该参数的值。

Table 722.USART_IT值  

<table><tr><td>USART_IT</td><td>描述</td></tr><tr><td>USART_IT_PE</td><td>奇偶错误中断</td></tr><tr><td>USART_IT_TXE</td><td>发送中断</td></tr><tr><td>USART_IT_TC</td><td>传输完成中断</td></tr><tr><td>USART_IT_RXNE</td><td>接收中断</td></tr><tr><td>USART_IT_IDLE</td><td>空闲总线中断</td></tr><tr><td>USART_IT_LBD</td><td>LIN中断检测中断</td></tr><tr><td>USART_IT_CTS</td><td>CTS中断</td></tr><tr><td>USART_IT_ERR</td><td>错误中断</td></tr></table>

例：

/\*Enables theUSART1 transmit interrupt \*/USART_ITConfig(USART1，USART_IT_Transmit ENABLE);

# 21.2.6 函数USART_DMAcmd

Table 723. 描述了函数USART_DMACmd  
Table 723. 函数USART_DMAcmd  

<table><tr><td>函数名</td><td>USART_DMAcmd</td></tr><tr><td>函数原形</td><td>USART_DMAcmd(USART_TYPEDef* USARTx, FunctionalState NewState)</td></tr><tr><td>功能描述</td><td>使能或者失能指定 USART 的 DMA 请求</td></tr><tr><td>输入参数 1</td><td>USARTx: x 可以是 1, 2 或者 3, 来选择 USART 外设</td></tr><tr><td>输入参数 2</td><td>USART_DMAreq: 指定 DMA 请求
参阅 Section: USART_DMAreq 查阅更多该参数允许取值范围</td></tr><tr><td>输入参数 3</td><td>NewState: USARTx DMA 请求源的新状态
这个参数可以取: ENABLE 或者 DISABLE</td></tr><tr><td>输出参数</td><td>无</td></tr><tr><td>返回值</td><td>无</td></tr><tr><td>先决条件</td><td>无</td></tr><tr><td>被调用函数</td><td>无</td></tr></table>

# USART_DMAreq

USART_DMAreq选择待使能或者失能的DMA请求。Table 724. 给出了该参数可取的值。

Table 724.USART_LastBit值  

<table><tr><td>USART_DMAreq</td><td>描述</td></tr><tr><td>USART_DMAReq_Tx</td><td>发送 DMA 请求</td></tr><tr><td>USART_DMAReq_Rx</td><td>接收 DMA 请求</td></tr></table>

例：  
/* Enable the DMA transfer on Rx and Tx action forUSART2 */  
USART_DMACmd (USART2,USART_DMAReq_Rx |USART_DMAReq_Tx，ENABLE)；

# 21.2.7 函数USART_SetAddress

Table 725. 描述了函数USART_SetAddress  
Table 725. 函数USART_SetAddress  

<table><tr><td>函数名</td><td>USART_SetAddress</td></tr><tr><td>函数原形</td><td>void USART_SetAddress(USART_TYPEDef* USARTx, u8 USART_Address)</td></tr><tr><td>功能描述</td><td>设置USART节点的地址</td></tr><tr><td>输入参数1</td><td>USARTx: x可以是1, 2或者3, 来选择USART外设</td></tr><tr><td>输入参数2</td><td>USART_Address: 提示USART节点的地址。</td></tr><tr><td>输出参数</td><td>无</td></tr><tr><td>返回值</td><td>无</td></tr><tr><td>先决条件</td><td>无</td></tr><tr><td>被调用函数</td><td>无</td></tr></table>

例：  
/\* Sets theUSART2 address node to 0x5 \*/USART_SetAddress(USART2，0x5);

# 21.2.8 函数USART_WakeUpConfig

Table 726. 描述了函数USART_WakeUpConfig

Table 726. 函数USART_WakeUpConfig  

<table><tr><td>函数名</td><td>USART_WakeUpConfig</td></tr><tr><td>函数原形</td><td>void USART_WakeUpConfig(USART_TYPEDef* USARTx, u16 USART_WakeUp)</td></tr><tr><td>功能描述</td><td>选择USART的唤醒方式</td></tr><tr><td>输入参数1</td><td>USARTx: x可以是1, 2或者3, 来选择USART外设</td></tr><tr><td>输入参数2</td><td>USART_WakeUp: USART的唤醒方式
参阅Section: USART_WakeUp 查阅更多该参数允许取值范围</td></tr><tr><td>输出参数</td><td>无</td></tr><tr><td>返回值</td><td>无</td></tr><tr><td>先决条件</td><td>无</td></tr><tr><td>被调用函数</td><td>无</td></tr></table>

# USART_WakeUp

USART_WakeUp选择USART的唤醒方式。Table 727. 给出了该参数可取的值。

Table 727.USART_WakeUp 值  

<table><tr><td>USART_WakeUp</td><td>描述</td></tr><tr><td>USART_WakeUp_IdleLine</td><td>空闲总线唤醒</td></tr><tr><td>USART_WakeUp_AddressMark</td><td>地址标记唤醒</td></tr></table>

例：

```txt
/\* Selects the IDLE Line asUSART1 WakeUp \*/USART_WakeUpConfig(USART1,USART_WakeUpIdleLine
```

# 21.2.9 函数USART_ReceiverWakeUpCmd

Table 728. 描述了函数USART_ReceiverWakeUpCmd

Table 728. 函数USART_ReceiverWakeUpCmd  

<table><tr><td>函数名</td><td>USART_ReceiverWakeUpCmd</td></tr><tr><td>函数原形</td><td>void USART_ReceiverWakeUpCmd(USART_TYPEDef* USARTx, FunctionalState Newstate)</td></tr><tr><td>功能描述</td><td>检查USART是否处于静默模式</td></tr><tr><td>输入参数1</td><td>USARTx: x可以是1, 2或者3, 来选择USART外设</td></tr><tr><td>输入参数2</td><td>NewState: USART 静默模式的新状态
这个参数可以取: ENABLE 或者 DISABLE</td></tr><tr><td>输出参数</td><td>无</td></tr><tr><td>返回值</td><td>无</td></tr><tr><td>先决条件</td><td>无</td></tr><tr><td>被调用函数</td><td>无</td></tr></table>

例：

```c
/\*USART3 in normal mode \*/   
USART_ReceiverWakeUpCmd(USART3，DISABLE);
```

# 21.2.10 函数USART_LINBreakDetectiLengthConfig

Table 729. 描述了函数USART_LINBreakDetectiLengthConfig  
Table 729. 函数USART_LINBreakDetectiLengthConfig  

<table><tr><td>函数名</td><td>USART_LINBreakDetectiLengthConfig</td></tr><tr><td>函数原形</td><td>void USART_LINBreakDetectiLengthConfig(USART_TYPEDef* USARTx, u16 USART_LINBreakDetectiLength)</td></tr><tr><td>功能描述</td><td>设置USART LIN中断检测长度</td></tr><tr><td>输入参数1</td><td>USARTx: x可以是1,2或者3,来选择USART外设</td></tr><tr><td>输入参数2</td><td>USART_LINBreakDetectiLength: LIN中断检测长度
参阅Section: USART_LINBreakDetectiLength 查阅更多该参数允许取值范围</td></tr><tr><td>输出参数</td><td>无</td></tr><tr><td>返回值</td><td>无</td></tr><tr><td>先决条件</td><td>无</td></tr><tr><td>被调用函数</td><td>无</td></tr></table>

# USART_LINBreakDetectLength

USART_LINBreakDetectLength选择USART的唤醒方式。Table 730. 给出了该参数可取的值。

Table 730.USART_LINBreakDetectLength值  

<table><tr><td>USART_LINBreakDetectLength</td><td>描述</td></tr><tr><td>USART_LINBreakDetectLength_10b</td><td>10位中断检测</td></tr><tr><td>USART_LINBreakDetectLength_11b</td><td>11位中断检测</td></tr></table>

例：

```txt
/\* Selects 10 bit break detection forUSART1 \*/USART_LINBreakDetectLengthConfig(USART1,USART_LINDetectLength_10b);
```

# 21.2.11 函数USART_LINCmd

Table 731. 描述了函数USART_LINCmd  
Table 731. 函数USART_LINCmd  

<table><tr><td>函数名</td><td>USART_LINCmd</td></tr><tr><td>函数原形</td><td>void USART_LINCmd(USART_TYPEDef* USARTx, FunctionalState Newstate)</td></tr><tr><td>功能描述</td><td>使能或者失能USARTx的LIN模式</td></tr><tr><td>输入参数1</td><td>USARTx: x可以是1, 2或者3, 来选择USART外设</td></tr><tr><td>输入参数2</td><td>NewState: USART LIN模式的新状态
这个参数可以取: ENABLE或者 DISABLE</td></tr><tr><td>输出参数</td><td>无</td></tr><tr><td>返回值</td><td>无</td></tr><tr><td>先决条件</td><td>无</td></tr><tr><td>被调用函数</td><td>无</td></tr></table>

例：

```txt
/\*Enable theUSART2LINmode\*/USART_LINCmd(USART2，ENABLE);
```

# 21.2.12 函数USART_SendData

Table 732. 描述了函数USART_SendData

Table 732. 函数USART_SendData  

<table><tr><td>函数名</td><td>USART_SendDate</td></tr><tr><td>函数原形</td><td>void USART_SendDate(USART_TYPEDef* USARTx, u8 Data)</td></tr><tr><td>功能描述</td><td>通过外设USARTx发送单个数据</td></tr><tr><td>输入参数1</td><td>USARTx: x可以是1, 2或者3, 来选择USART外设</td></tr><tr><td>输入参数2</td><td>Data: 待发送的数据</td></tr><tr><td>输出参数</td><td>无</td></tr><tr><td>返回值</td><td>无</td></tr><tr><td>先决条件</td><td>无</td></tr><tr><td>被调用函数</td><td>无</td></tr></table>

例：  
/* Send one HalfWord on USART3 */
USART_SendData(USART3, 0x26);

# 21.2.13 函数USART_ReceiveData

Table 733. 描述了函数USART_ReceiveData  
Table 733. 函数 USART_ReceiveData  

<table><tr><td>函数名</td><td>USART_ReceiveData</td></tr><tr><td>函数原形</td><td>u8 USART_ReceiveData(USART_TYPEDef* USARTx)</td></tr><tr><td>功能描述</td><td>返回USARTx最近接收到的数据</td></tr><tr><td>输入参数</td><td>USARTx: x可以是1,2或者3,来选择USART外设</td></tr><tr><td>输出参数</td><td>无</td></tr><tr><td>返回值</td><td>接收到的字</td></tr><tr><td>先决条件</td><td>无</td></tr><tr><td>被调用函数</td><td>无</td></tr></table>

例：  
/\*Receive one halfword onUSART2\*/ u16 RxData; RxData  $=$  USART_ReceiveData(USART2);

# 21.2.14 函数USART_SendBreak

Table 734. 描述了函数USART_SendBreak  
Table 734. 函数USART_SendBreak  

<table><tr><td>函数名</td><td>USART_SendBreak</td></tr><tr><td>函数原形</td><td>void USART_SendBreak(USART_TYPEDef* USARTx)</td></tr><tr><td>功能描述</td><td>发送中断字</td></tr><tr><td>输入参数</td><td>USARTx: x 可以是 1, 2 或者 3, 来选择 USART 外设</td></tr><tr><td>输出参数</td><td>无</td></tr><tr><td>返回值</td><td>无</td></tr><tr><td>先决条件</td><td>无</td></tr><tr><td>被调用函数</td><td>无</td></tr></table>

例：
/* Send break character on USART1 */
USART_SendBreak(USART1);

# 21.2.15 函数USART_SetGuardTime

Table 735. 描述了函数USART_SetGuardTime  
Table 735. 函数USART_SetGuardTime  

<table><tr><td>函数名</td><td>USART_SetGuardTime</td></tr><tr><td>函数原形</td><td>void USART_SetGuardTime(USART_TYPEDef* USARTx, u8 USART_GuardTime)</td></tr><tr><td>功能描述</td><td>设置指定的USART保护时间</td></tr><tr><td>输入参数1</td><td>USARTx: x可以是1,2或者3,来选择USART外设</td></tr><tr><td>输入参数2</td><td>USART_GuardTime: 指定的保护时间</td></tr><tr><td>输出参数</td><td>无</td></tr><tr><td>返回值</td><td>无</td></tr><tr><td>先决条件</td><td>无</td></tr><tr><td>被调用函数</td><td>无</td></tr></table>

例：
/* Set the guard time to 0x78 */
USART_SetGuardTime(0x78);

# 21.2.16 函数USART_SetPrescaler

Table 736. 描述了函数USART_SetPrescaler

Table 736. 函数USART_SetPrescaler  

<table><tr><td>函数名</td><td>USART_SetPrescaler</td></tr><tr><td>函数原形</td><td>void USART_SetPrescaler(USART_TYPEDef* USARTx, u8 USART_Prescaler)</td></tr><tr><td>功能描述</td><td>设置USART时钟预分频</td></tr><tr><td>输入参数1</td><td>USARTx: x可以是1, 2或者3, 来选择USART外设</td></tr><tr><td>输入参数2</td><td>USART_Prescaler: 时钟预分频</td></tr><tr><td>输出参数</td><td>无</td></tr><tr><td>返回值</td><td>无</td></tr><tr><td>先决条件</td><td>无</td></tr><tr><td>被调用函数</td><td>无</td></tr></table>

例：  
/\* Set the system clock prescaler to 0x56 \*/USART_SetPrescaler(0x56);

# 21.2.17 函数USART_SmartCardCmd

Table 737. 描述了函数USART_SmartCardCmd  
Table 737. 函数USART_SmartCardCmd  

<table><tr><td>函数名</td><td>USART_SmartCardCmd</td></tr><tr><td>函数原形</td><td>void USART_SmartCardCmd(USART_TYPEDef* USARTx, FunctionalState Newstate)</td></tr><tr><td>功能描述</td><td>使能或者失能指定 USART 的智能卡模式</td></tr><tr><td>输入参数 1</td><td>USARTx: x 可以是 1, 2 或者 3, 来选择 USART 外设</td></tr><tr><td>输入参数 2</td><td>NewState: USART 智能卡模式的新状态
这个参数可以取: ENABLE 或者 DISABLE</td></tr><tr><td>输出参数</td><td>无</td></tr><tr><td>返回值</td><td>无</td></tr><tr><td>先决条件</td><td>无</td></tr><tr><td>被调用函数</td><td>无</td></tr></table>

例：  
/\*Enable theUSART1SmartCardmode\*/USART_SmartCardCmd(USART1，ENABLE);

# 21.2.18 函数USART_SmartCardNackCmd

Table 738. 描述了函数USART_SmartCardNackCmd

Table 738. 函数USART_SmartCardNackCmd  

<table><tr><td>函数名</td><td>USART_SmartCardNackCmd</td></tr><tr><td>函数原形</td><td>void USART_SmartCardNACKCmd(USART_TYPEDef* USARTx, FunctionalState Newstate)</td></tr><tr><td>功能描述</td><td>使能或者失能 NACK 传输</td></tr><tr><td>输入参数1</td><td>USARTx: x 可以是 1, 2 或者 3, 来选择 USART 外设</td></tr><tr><td>输入参数2</td><td>NewState: NACK 传输的新状态
这个参数可以取: ENABLE 或者 DISABLE</td></tr><tr><td>输出参数</td><td>无</td></tr><tr><td>返回值</td><td>无</td></tr><tr><td>先决条件</td><td>无</td></tr><tr><td>被调用函数</td><td>无</td></tr></table>

例：  
/* Enable theUSART1 NACK transmission during parity error */
USART_SmartCardNACKCmd(USART1, ENABLE);

# 21.2.19 函数USART_HalfDuplexCmd

Table 739. 描述了函数USART_HalfDuplexCmd

Table 739. 函数USART_HalfDuplexCmd  

<table><tr><td>函数名</td><td>USART_HalfDuplexCmd</td></tr><tr><td>函数原形</td><td>void USART_HalfDuplexCmd(USARTTypeDef* USARTx, FunctionalState Newstate)</td></tr><tr><td>功能描述</td><td>使能或者失能USART半双工模式</td></tr><tr><td>输入参数1</td><td>USARTx: x可以是1, 2或者3, 来选择USART外设</td></tr><tr><td>输入参数2</td><td>NewState: USART半双工模式传输的新状态
这个参数可以取: ENABLE或者 DISABLE</td></tr><tr><td>输出参数</td><td>无</td></tr><tr><td>返回值</td><td>无</td></tr><tr><td>先决条件</td><td>无</td></tr><tr><td>被调用函数</td><td>无</td></tr></table>

例：  
/\*EnabeHalfDuplexmodeforUSART2\*/USART_HalfDuplexCmd(USART2，ENABLE);

# 21.2.20 函数USART_IrDACConfig

Table 740. 描述了函数USART_IrDACConfig

Table 740. 函数USART_IrDACConfig  

<table><tr><td>函数名</td><td>USART_IrDAConfig</td></tr><tr><td>函数原形</td><td>void USART_IrDAConfig(USART_TYPEDef* USARTx, u16 USART_IrDAMode)</td></tr><tr><td>功能描述</td><td>设置USART IrDA模式</td></tr><tr><td>输入参数1</td><td>USARTx: x可以是1, 2或者3, 来选择USART外设</td></tr><tr><td>输入参数2</td><td>USART_IrDAMode: LIN中断检测长度
参阅Section: USART_IrDAMode 查阅更多该参数允许取值范围</td></tr><tr><td>输出参数</td><td>无</td></tr><tr><td>返回值</td><td>无</td></tr><tr><td>先决条件</td><td>无</td></tr><tr><td>被调用函数</td><td>无</td></tr></table>

# USART_IrDAMode

USART_IrDAMode选择IrDA的模式。Table 741. 给出了该参数可取的值。

Table 741.USART_IrDAMode值  

<table><tr><td>USART_IrDAMode</td><td>描述</td></tr><tr><td>USART_IrDAMode_LowPower</td><td>IrDA 低功耗模式</td></tr><tr><td>USART_IrDAMode_Normal</td><td>IrDA 正常模式</td></tr></table>

例：

```javascript
/\*USART2IrDA Low Power Selection \*/USART_IrDACConfig(USART2,USART_IrDAMode_LowPower);
```

# 21.2.21 函数USART_IrDACmd

Table 742. 描述了函数USART_IrDACmd

Table 742. 函数USART_IrDACmd  

<table><tr><td>函数名</td><td>USART_IrDACmd</td></tr><tr><td>函数原形</td><td>void USART_IrDACmd(USART_TYPEDef* USARTx, FunctionalState Newstate)</td></tr><tr><td>功能描述</td><td>使能或者失能USART IrDA模式</td></tr><tr><td>输入参数1</td><td>USARTx: x可以是1,2或者3,来选择USART外设</td></tr><tr><td>输入参数2</td><td>NewState: USART IrDA模式的新状态
这个参数可以取: ENABLE或者 DISABLE</td></tr><tr><td>输出参数</td><td>无</td></tr><tr><td>返回值</td><td>无</td></tr><tr><td>先决条件</td><td>无</td></tr><tr><td>被调用函数</td><td>无</td></tr></table>

例：

```c
/\*Enable theUSART1IrDA Mode \*/USART_IrDACmd(USART1，ENABLE);
```

# 21.2.22 函数USART_GetFlagStatus

Table 743. 描述了函数USART_GetFlagStatus

Table 743. 函数USART_GetFlagStatus  

<table><tr><td>函数名</td><td>USART_GetFlagStatus</td></tr><tr><td>函数原形</td><td>FlagStatus USART_GetFlagStatus(USART_TYPEDef* USARTx, u16 USART_FLAG)</td></tr><tr><td>功能描述</td><td>检查指定的USART标志位设置与否</td></tr><tr><td>输入参数1</td><td>USARTx: x可以是1,2或者3,来选择USART外设</td></tr><tr><td>输入参数2</td><td>USART_FLAG: 待检查的USART标志位
参阅Section: USART_FLAG查阅更多该参数允许取值范围</td></tr><tr><td>输出参数</td><td>无</td></tr><tr><td>返回值</td><td>USART_FLAG的新状态 (SET或者RESET)</td></tr><tr><td>先决条件</td><td>无</td></tr><tr><td>被调用函数</td><td>无</td></tr></table>

# USART_FLAG

Table 744. 给出了所有可以被函数USART_GetFlagStatus检查的标志位列表

Table 744.USART_FLAG值  

<table><tr><td>USART_FLAG</td><td>描述</td></tr><tr><td>USART_FLAG_CTS</td><td>CTS 标志位</td></tr><tr><td>USART_FLAG_LBD</td><td>LIN 中断检测标志位</td></tr><tr><td>USART_FLAG_TXE</td><td>发送数据寄存器空标志位</td></tr><tr><td>USART_FLAG_TC</td><td>发送完成标志位</td></tr><tr><td>USART_FLAG_RXNE</td><td>接收数据寄存器非空标志位</td></tr><tr><td>USART_FLAG_IDLE</td><td>空闲总线标志位</td></tr><tr><td>USART_FLAG_ORE</td><td>溢出错误标志位</td></tr><tr><td>USART_FLAG_NE</td><td>噪声错误标志位</td></tr><tr><td>USART_FLAG_FE</td><td>帧错误标志位</td></tr><tr><td>USART_FLAG_PE</td><td>奇偶错误标志位</td></tr></table>

例：

/* Check if the transmit data register is full or not */

FlagStatus Status;

Status =USART_GetFlagStatus(USART1,USART_FLAG_TXE);

# 21.2.23 函数USART_ClearFlag

Table 745. 描述了函数USART_ClearFlag

Table 745. 函数USART_ClearFlag  

<table><tr><td>函数名</td><td>USART_ClearFlag</td></tr><tr><td>函数原形</td><td>void USART_ClearFlag(USART_TYPEDef* USARTx, u16 USART_FLAG)</td></tr><tr><td>功能描述</td><td>清除USARTx的待处理标志位</td></tr><tr><td>输入参数1</td><td>USARTx: x可以是1, 2或者3, 来选择USART外设</td></tr><tr><td>输入参数2</td><td>USART_FLAG: 待清除的USART标志位
参阅Section: USART_FLAG 查阅更多该参数允许取值范围</td></tr><tr><td>输出参数</td><td>无</td></tr><tr><td>返回值</td><td>无</td></tr><tr><td>先决条件</td><td>无</td></tr><tr><td>被调用函数</td><td>无</td></tr></table>

例：  
/\* Clear Overrun error flag \*/USART_ClearFlag(USART1,USART_FLAG_OR);

# 21.2.24 函数USART_GetITStatus

Table 746. 描述了函数USART_GetITStatus

Table 746. 函数USART_GetITStatus  

<table><tr><td>函数名</td><td>USART_GetITStatus</td></tr><tr><td>函数原形</td><td>ITStatus USART_GetITStatus(USART_TYPEDef* USARTx, u16 USART_IT)</td></tr><tr><td>功能描述</td><td>检查指定的USART中断发生与否</td></tr><tr><td>输入参数1</td><td>USARTx: x可以是1, 2或者3, 来选择USART外设</td></tr><tr><td>输入参数2</td><td>USART_IT: 待检查的USART中断源
参阅Section: USART_IT查阅更多该参数允许取值范围</td></tr><tr><td>输出参数</td><td>无</td></tr><tr><td>返回值</td><td>USART_IT的新状态</td></tr><tr><td>先决条件</td><td>无</td></tr><tr><td>被调用函数</td><td>无</td></tr></table>

# USART IT

Table 747. 给出了所有可以被函数USART_GetITStatus检查的中断标志位列表

Table 747.USART IT值  

<table><tr><td>USART_IT</td><td>描述</td></tr><tr><td>USART_IT_PE</td><td>奇偶错误中断</td></tr><tr><td>USART_IT_TXE</td><td>发送中断</td></tr><tr><td>USART_IT_TC</td><td>发送完成中断</td></tr><tr><td>USART_IT_RXNE</td><td>接收中断</td></tr><tr><td>USART_IT_IDLE</td><td>空闲总线中断</td></tr><tr><td>USART_IT_LBD</td><td>LIN中断探测中断</td></tr><tr><td>USART_IT_CTS</td><td>CTS中断</td></tr><tr><td>USART_IT_ORE</td><td>溢出错误中断</td></tr><tr><td>USART_IT_NE</td><td>噪音错误中断</td></tr><tr><td>USART_IT_FE</td><td>帧错误中断</td></tr></table>

例：

# ST

译文英文原版为UM0427 Oct. 2007 Rev 2, 译文仅供参考，与英文版冲突的，以英文版为准

```c
/\*Get theUSART1Overrun Error interrupt status \*/   
ITStatus ErrorITStatus;   
ErrorITStatus  $=$  USART_GetITStatus(USART1，USART_IT_OverrunError);
```

# 21.2.25 函数USART_ClearITPendingBit

Table 748. 描述了函数USART_ClearITPendingBit  
Table 748. 函数USART_ClearITPendingBit  

<table><tr><td>函数名</td><td>USART_ClearITPendingBit</td></tr><tr><td>函数原形</td><td>void USART_ClearITPendingBit(USARTTypeDef* USARTx, u16 USART_IT)</td></tr><tr><td>功能描述</td><td>清除USARTx的中断待处理位</td></tr><tr><td>输入参数1</td><td>USARTx: x可以是1, 2或者3, 来选择USART外设</td></tr><tr><td>输入参数2</td><td>USART_IT: 待检查的USART中断源
参阅Section: USART_IT查阅更多该参数允许取值范围</td></tr><tr><td>输出参数</td><td>无</td></tr><tr><td>返回值</td><td>无</td></tr><tr><td>先决条件</td><td>无</td></tr><tr><td>被调用函数</td><td>无</td></tr></table>

例：

```txt
/\* Clear the Overrun Error interrupt pending bit \*/USART_ClearITPendingBit(USART1,USART_IT_OverrunError);
```

# 22 窗口看门狗（WWDG）

窗口看门狗用来检测是否发生过软件错误。通常软件错误是由外部干涉或者不可预见的逻辑冲突引起的，这些错误将打断正常的程序流程。

Section 22.1 WWDG 寄存器结构描述了固件函数库所使用的数据结构, Section 22.2 固件库函数介绍了函数库里的所有函数。

# 22.1 WWDG寄存器结构

WWDG寄存器结构，WWDG_TYPEDeff，在文件“stm32f10x_map.h”中定义如下：

```txt
typedef struct   
{   
vu32 CR;   
vu32 CFR;   
vu32 SR;   
} WWDG_TYPEDef;
```

Table 749.例举了WWDG所有寄存器

Table 749. WWDG 寄存器  

<table><tr><td>寄存器</td><td>描述</td></tr><tr><td>CR</td><td>WWDG 控制寄存器</td></tr><tr><td>CFR</td><td>WWDG 设置寄存器</td></tr><tr><td>SR</td><td>WWDG 状态寄存器</td></tr></table>

WWDG外设声明于文件“stm32f10x_map.h”：

```c
define PERIPH_BASE((u32)0x40000000)
#define APB1PERIPH_BASE PERIPH_BASE
#define APB2PERIPH_BASE (PERIPH_BASE + 0x10000)
#define AHBPERIPH_BASE (PERIPH_BASE + 0x20000)
#define WWDG_BASE (APB1PERIPH_BASE + 0x2C00)
#ifndef DEBUG
...
#ifndef_WWDG
#define_WWDG ((WWDG_TYPEDef *) WWDG_BASE)
#endif /*_WWDG */
...
#else /* DEBUG */
...
#ifndef_WWDG
EXT WWDG_TYPEDef *WWDG;
#endif /*_WWDG */
...
#endif
使用Debug模式时，初始化指针WWDG于文件“stm32f10x_lib.c”:
#ifdef_WWDG
WWDG = (WWDG_TYPEDef *) WWDG_BASE;
#endif /*_WWDG */
为了访问WWDG寄存器，_WWDG必须在文件“stm32f10x_conf.h”中定义如下:
#define_WWDG
```

# 22.2 WWDG库函数

Table 750. 例举了WWDG的库函数  
Table 750. WWDG 库函数  

<table><tr><td>函数名</td><td>描述</td></tr><tr><td>WWDG_DeInit</td><td>将外设 WWDG 寄存器重设为缺省值</td></tr><tr><td>WWDG_SetPrescaler</td><td>设置 WWDG 预分频值</td></tr><tr><td>WWDG_SetWindowValue</td><td>设置 WWDG 窗口值</td></tr><tr><td>WWDG_EnableIT</td><td>使能 WWDG 早期唤醒中断 (EWI)</td></tr><tr><td>WWDG_SetCounter</td><td>设置 WWDG 计数器值</td></tr><tr><td>WWDG_Enable</td><td>使能 WWDG 并装入计数器值</td></tr><tr><td>WWDG_GetFlagStatus</td><td>检查 WWDG 早期唤醒中断标志位被设置与否</td></tr><tr><td>WWDG_ClearFlag</td><td>清除早期唤醒中断标志位</td></tr></table>

# 22.1.1 函数WWDG_DeInit

Table 751. 描述了函数 WWDG_DeInit  
Table 751. 函数 WWDG_DeInit  

<table><tr><td>函数名</td><td>WWDG_DeInit</td></tr><tr><td>函数原形</td><td>void WWDG_DeInit(WWDG_TYPEDef* WWDGx)</td></tr><tr><td>功能描述</td><td>将外设 WWDG 寄存器重设为缺省值</td></tr><tr><td>输入参数</td><td>无</td></tr><tr><td>输出参数</td><td>无</td></tr><tr><td>返回值</td><td>无</td></tr><tr><td>先决条件</td><td>无</td></tr><tr><td>被调用函数</td><td>RCC_AP1PeriphResetCmd()</td></tr></table>

例：
/* Deinitialize the WWDG registers */
WWDG_DeInit();

# 22.1.2 函数WWDG_SetPrescaler

Table 752. 描述了函数 WWDG_SetPrescaler  
Table 752. 函数 WWDG_SetPrescaler  

<table><tr><td>函数名</td><td>WWDG_SetPrescaler</td></tr><tr><td>函数原形</td><td>void WWDG_SetPrescaler(u32 WWDG_Prescaler)</td></tr><tr><td>功能描述</td><td>设置 WWDG 预分频值</td></tr><tr><td>输入参数</td><td>WWDG_Prescaler: 指定 WWDG 预分频
参阅 Section: WWDG_Prescaler 查阅更多该参数允许取值范围</td></tr><tr><td>输出参数</td><td>无</td></tr><tr><td>返回值</td><td>无</td></tr><tr><td>先决条件</td><td>无</td></tr><tr><td>被调用函数</td><td>无</td></tr></table>

# WWDG_Prescaler

该参数设置 WWDG 预分频值（见 Table. 753）。

Table 753. WWDG_Prescaler 值  

<table><tr><td>WWDG_Prescaler</td><td>描述</td></tr><tr><td>WWDG_Prescaler_1</td><td>WWDG计数器时钟为（PCLK/4096）/1</td></tr><tr><td>WWDG_Prescaler_2</td><td>WWDG计数器时钟为（PCLK/4096）/2</td></tr><tr><td>WWDG_Prescaler_4</td><td>WWDG计数器时钟为（PCLK/4096）/4</td></tr><tr><td>WWDG_Prescaler_8</td><td>WWDG计数器时钟为（PCLK/4096）/8</td></tr></table>

例：

```javascript
/\*Set WWDG prescaler to 8 \*/ WWDG_SetPrescaler(WWDG_Prescaler_8);
```

# 22.1.3 函数WWDG_SetWindowValue

Table 754. 描述了函数 WWDG_SetWindowValue  
Table 754. 函数 WWDG_SetWindowValue  

<table><tr><td>函数名</td><td>WWDG_SetWindowValue</td></tr><tr><td>函数原形</td><td>void WWDG_SetWindowValue(u8 WindowValue)</td></tr><tr><td>功能描述</td><td>设置 WWDG 窗口值</td></tr><tr><td>输入参数</td><td>WindowValue r: 指定的窗口值。该参数取值必须在 0x40 与 0x7F 之间。</td></tr><tr><td>输出参数</td><td>无</td></tr><tr><td>返回值</td><td>无</td></tr><tr><td>先决条件</td><td>无</td></tr><tr><td>被调用函数</td><td>无</td></tr></table>

例：

```javascript
/\*SetWWDGwindowvalueto0x50\*/ WWDG_SetWindowValue(0x50);
```

# 22.1.4 函数WWDG_EnableIT

Table 755. 描述了函数 WWDG_EnableIT  
Table 755. 函数 WWDG_EnableIT  

<table><tr><td>函数名</td><td>WWDG_EnableIT</td></tr><tr><td>函数原形</td><td>void WWDG_EnableIT(void)</td></tr><tr><td>功能描述</td><td>使能 WWDG 早期唤醒中断 (EWI)</td></tr><tr><td>输入参数</td><td>无</td></tr><tr><td>输出参数</td><td>无</td></tr><tr><td>返回值</td><td>无</td></tr><tr><td>先决条件</td><td>无</td></tr><tr><td>被调用函数</td><td>无</td></tr></table>

例：

```javascript
/\*EnableWWDGEarlywakeupinterrupt\*/ WWDGEnableIT();
```

# 22.1.5 函数WWDG_SetCounter

Table 756. 描述了函数 WWDG_SetCounter

Table 756. 函数 WWDG_SetCounter  

<table><tr><td>函数名</td><td>WWDG_SetCounter</td></tr><tr><td>函数原形</td><td>void WWDG_SetCounter(u8 Counter)</td></tr><tr><td>功能描述</td><td>设置 WWDG 计数器值</td></tr><tr><td>输入参数</td><td>Counter: 指定看门狗计数器值。该参数取值必须在 0x40 与 0x7F 之间。</td></tr><tr><td>输出参数</td><td>无</td></tr><tr><td>返回值</td><td>无</td></tr><tr><td>先决条件</td><td>无</td></tr><tr><td>被调用函数</td><td>无</td></tr></table>

例：/\*SetWWDGcountervalueto0x70\*/WWDG_SetCounter(0x70);

# 22.1.6 函数WWDG_Enable

Table 757. 描述了函数 WWDG_Enable

Table 757. 函数 WWDG_Enable  

<table><tr><td>函数名</td><td>WWDG_Enable</td></tr><tr><td>函数原形</td><td>Void WWDG_Enable(u8 Counter)</td></tr><tr><td>功能描述</td><td>使能 WWDG 并装入计数器值(1)</td></tr><tr><td>输入参数</td><td>Counter: 指定看门狗计数器值。该参数取值必须在 0x40 与 0x7F 之间。</td></tr><tr><td>输出参数</td><td>无</td></tr><tr><td>返回值</td><td>无</td></tr><tr><td>先决条件</td><td>无</td></tr><tr><td>被调用函数</td><td>无</td></tr></table>

1.WWDG一旦被使能就不能被失能。

例：
/* Enable WWDG and set counter value to 0x7F */
WWDG_Enable(0x7F);

# 22.1.7 函数WWDG_GetFlagStatus

Table 758. 描述了函数WWDG_GetFlagStatus  
Table 758. 函数 WWDG_GetFlagStatus  

<table><tr><td>函数名</td><td>WWDG_GetFlagStatus</td></tr><tr><td>函数原形</td><td>FlagStatus WWDG_GetFlagStatus(void)</td></tr><tr><td>功能描述</td><td>检查 WWDG 早期唤醒中断标志位被设置与否</td></tr><tr><td>输入参数</td><td>无</td></tr><tr><td>输出参数</td><td>无</td></tr><tr><td>返回值</td><td>早期唤醒中断标志位的新状态 (SET 或者 RESET)</td></tr><tr><td>先决条件</td><td>无</td></tr><tr><td>被调用函数</td><td>无</td></tr></table>

```proto
例：
/* Test if the counter has reached the value 0x40 */
FlagStatus Status;
Status = WWDG_GetFlagStatus();
if (Status == RESET)
{
...
} else
{
...
}
```

# 22.1.8 函数WWDG_ClearFlag

Table 759. 描述了函数WWDG_ClearFlag  
Table 759. 函数 WWDG_ClearFlag  

<table><tr><td>函数名</td><td>WWDG_ClearFlag</td></tr><tr><td>函数原形</td><td>void WWDG_ClearFlag(void)</td></tr><tr><td>功能描述</td><td>清除早期唤醒中断标志位</td></tr><tr><td>输入参数</td><td>无</td></tr><tr><td>输出参数</td><td>无</td></tr><tr><td>返回值</td><td>无</td></tr><tr><td>先决条件</td><td>无</td></tr><tr><td>被调用函数</td><td>无</td></tr></table>

例：

```txt
/* Clear EWI flag */
WWDG_ClearFlag();
```

# 23 修订记录

参考英文版。

# 版权声明

参考英文版。