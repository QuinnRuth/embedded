/* ========== 文件说明 ========== */
// 本程序演示 STM32 通过 USART1 双向通信（发送+接收）
// 学习目标：
// 1. 掌握串口接收中断的配置方法（USART_IT_RXNE + NVIC）
// 2. 理解"中断接收 + 主循环处理"的异步编程模型
// 3. 实现数据回显（Echo）功能
// 4. 在 OLED 上显示接收到的数据
/* ============================== */

#include "stm32f10x.h"                  // Device header
#include "Delay.h"
#include "OLED.h"
#include "Serial.h"

/* ========== 全局变量 ========== */
// RxData：存储从串口接收到的最新一个字节
// 说明：这是应用层的缓存变量，从 Serial_GetRxData() 获取后可安全使用
uint8_t RxData;

int main(void)
{
	/* ========== 初始化模块 ========== */
	OLED_Init();		// OLED 显示屏初始化（用于显示接收到的数据）
	
	/* ========== 显示静态提示信息 ========== */
	// 在 OLED 第 1 行第 1 列显示 "RxData:" 标签
	// 后续会在第 1 行第 8 列动态显示接收到的数据
	OLED_ShowString(1, 1, "RxData:");
	
	/* ========== 串口初始化 ========== */
	// 配置 PA9(TX) + PA10(RX) 为双向通信
	// 开启接收中断：每收到一个字节，触发 USART1_IRQHandler
	Serial_Init();
	
	/* ========== 主循环：轮询处理接收到的数据 ========== */
	// 【异步编程模型】
	// - 中断服务函数（ISR）：快速接收数据并置标志位（耗时 <1μs）
	// - 主循环：轮询标志位，处理接收到的数据（可执行复杂逻辑）
	// 优点：
	//   1. 中断响应快，不会丢失数据
	//   2. 主循环处理逻辑简单，易于调试
	//   3. 避免在中断中执行耗时操作（如 OLED 显示）
	while (1)
	{
		/* ========== 步骤 1：检查接收标志位 ========== */
		// Serial_GetRxFlag()：检查是否收到新数据
		// - 返回 1：有新数据，标志位自动清零
		// - 返回 0：无新数据
		if (Serial_GetRxFlag() == 1)
		{
			/* ========== 步骤 2：读取接收到的数据 ========== */
			// Serial_GetRxData()：返回最新接收到的字节
			RxData = Serial_GetRxData();
			
			/* ========== 步骤 3：回显数据（Echo）========== */
			// 将接收到的数据原样发送回串口
			// 用途：
			//   - 串口调试助手可看到"发送什么，就回显什么"
			//   - 验证接收功能是否正常
			Serial_SendByte(RxData);
			
			/* ========== 步骤 4：在 OLED 显示数据 ========== */
			// OLED_ShowHexNum()：以 16 进制显示接收到的字节
			// 参数：第 1 行，第 8 列，数据值，显示 2 位（如 0x41 显示为 "41"）
			// 示例：
			//   - 串口发送 'A' (0x41) → OLED 显示 "41"
			//   - 串口发送 0xFF → OLED 显示 "FF"
			OLED_ShowHexNum(1, 8, RxData, 2);
		}
		
		// 【优化提示】
		// 如果主循环有其他任务（如按键扫描、传感器读取），可在此添加
		// 例如：
		//   Key_Scan();
		//   Sensor_Read();
	}
}
